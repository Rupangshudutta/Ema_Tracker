const axios = require('axios');
const colors = require('colors');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');

let initialLoadComplete = false;

// Configuration (Consider externalizing these variables or using environment variables)
let EMA_PERIOD = parseInt(process.env.EMA_PERIOD, 10) || 200;
let TIMEFRAME = process.env.TIMEFRAME || '15m';
let VOLUME_THRESHOLD = parseInt(process.env.VOLUME_THRESHOLD, 10) || 100_000_000;
const CHECK_INTERVAL = parseInt(process.env.CHECK_INTERVAL, 10) || 5 * 60 * 1000; // 5 minutes
const ALERT_COOLDOWN = parseInt(process.env.ALERT_COOLDOWN, 10) || 15 * 60 * 1000; // 15 minutes cooldown for alerts

// Telegram configuration with your provided credentials
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Store last alert times and states for each symbol
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring

// Create a log directory for persistent logging
const LOG_DIR = path.join(__dirname, 'logs');
if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR);
}

// Log function that writes to both console and file
function log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;
    
    // Console logging with colors
    switch(type) {
        case 'error':
            console.error(logMessage.red);
            break;
        case 'success':
            console.log(logMessage.green);
            break;
        case 'warning':
            console.log(logMessage.yellow);
            break;
        default:
            console.log(logMessage);
    }
    
    // File logging
    const logFile = path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logMessage + '\n');
}

// Show desktop notification using node-notifier
function showDesktopNotification(title, message, type = 'info') {
    try {
        notifier.notify({
            title: title,
            message: message,
            sound: true,
            wait: true,
            icon: path.join(__dirname, type === 'error' ? 'error.png' : 
                           type === 'warning' ? 'warning.png' : 'info.png')
        });
        
        log(`Desktop notification shown: ${title} - ${message}`);
    } catch (error) {
        log(`Failed to show desktop notification: ${error.message}`, 'error');
    }
}
// Function to send Telegram message


// Initialize terminal
function initializeTerminal() {
    console.clear();
    console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);
    console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
    console.log(`Configuration: ${EMA_PERIOD} EMA | ${TIMEFRAME} Timeframe | Volume > ${VOLUME_THRESHOLD.toLocaleString()}`.cyan);
    console.log(`Alert Cooldown: ${ALERT_COOLDOWN / 60000} minutes`.magenta);
    console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
    console.log('='.repeat(80).dim);
    console.log('\nCROSSOVER EVENTS:'.cyan.bold);
    
    log(`EMA Tracker started with configuration: EMA=${EMA_PERIOD}, Timeframe=${TIMEFRAME}, Volume Threshold=${VOLUME_THRESHOLD}`);
}

// Helper function to format volume
function formatVolume(volume) {
    if (volume >= 1_000_000_000) {
        return (volume / 1_000_000_000).toFixed(2) + 'B';
    } else if (volume >= 1_000_000) {
        return (volume / 1_000_000).toFixed(2) + 'M';
    } else if (volume >= 1_000) {
        return (volume / 1_000).toFixed(2) + 'K';
    }
    return volume.toFixed(2);
}

// Function to get 24hr stats for a symbol
async function get24HrStats(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            params: { symbol }
        });
        return {
            priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
            quoteVolume: parseFloat(response.data.quoteVolume)
        };
    } catch (error) {
        log(`Error fetching 24hr stats for ${symbol}: ${error.message}`, 'error');
        return { priceChangePercent: '0.00', quoteVolume: '0' };
    }
}

// Fetch Binance Futures pairs with 24hr quote volume above the threshold
async function getFuturesPairs() {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        const newPairs = [];
        
        const pairs = response.data
            .filter(pair => {
                const volume = parseFloat(pair.quoteVolume);
                const symbol = pair.symbol;
                
                if (volume > VOLUME_THRESHOLD) {
                    // Only track new pairs that cross threshold after initial load
                    if (initialLoadComplete && !trackedPairs.has(symbol)) {
                        newPairs.push({
                            symbol,
                            volume,
                            price: parseFloat(pair.lastPrice),
                            change: parseFloat(pair.priceChangePercent)
                        });
                    }
                    trackedPairs.add(symbol);
                    return true;
                }
                return false;
            })
            .map(pair => pair.symbol);
        
        // Alert for new pairs that crossed the volume threshold (only after initial load)
        if (newPairs.length > 0) {
            alertNewHighVolumePairs(newPairs);
        }
        
        return pairs;
    } catch (error) {
        log(`Error fetching futures pairs: ${error.message}`, 'error');
        return [];
    }
}

// Alert when new pairs cross the volume threshold
async function alertNewHighVolumePairs(newPairs) {
    for (const pair of newPairs) {
        const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
                      `*Symbol:* ${pair.symbol}\n` +
                      `*Volume:* ${formatVolume(pair.volume)}\n` +
                      `*Price:* ${formatPrice(pair.price)}\n` +
                      `*24h Change:* ${pair.change.toFixed(2)}%\n` +
                      `*Time:* ${new Date().toLocaleString()}\n\n` +
                      `This pair has been added to the monitoring list.`;
        
        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
            
            // Show desktop notification
            showDesktopNotification(
                'New High Volume Pair',
                `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
                'info'
            );
            
            log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');
        } catch (error) {
            log(`Error sending new pair alert for ${pair.symbol}: ${error.message}`, 'error');
        }
    }
}

// Retrieve historical candlestick data for the given symbol
async function getKlines(symbol) {
    try {
        const limit = EMA_PERIOD + 100; // Request extra candles to be safe
        
        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: { symbol, interval: TIMEFRAME, limit: limit }
        });
         // Log the number of candles received for debugging
         //log(`Received ${response.data.length} candles for ${symbol} on ${TIMEFRAME} timeframe`, 'info');
        
         if (response.data.length < EMA_PERIOD) {
             log(`Warning: Not enough candles for ${symbol}. Needed ${EMA_PERIOD}, got ${response.data.length}`, 'warning');
         }

        return response.data.map(k => ({ time: k[0], close: parseFloat(k[4]) }));
    } catch (error) {
        log(`Error fetching klines for ${symbol}: ${error.message}`, 'error');
        return [];
    }
}

// Calculate the EMA for an array of prices given a period
function calculateEMA(prices, period) {
    if (prices.length < period) {
        log(`Warning: Not enough prices for EMA calculation. Needed ${period}, got ${prices.length}`, 'warning');
        return [];
    }
    
    const k = 2 / (period + 1);
    let emaArray = [];
    
    // Start with the simple moving average as the first EMA
    let sma = prices.slice(0, period).reduce((sum, p) => sum + p, 0) / period;
    let ema = sma;
    
    // Add the first EMA (which is the SMA)
    emaArray.push(ema);
    
    // Calculate EMA for the remaining prices
    for (let i = period; i < prices.length; i++) {
        ema = (prices[i] - ema) * k + ema;
        emaArray.push(ema);
    }
    
    return emaArray;
}

// Format price with appropriate precision based on value
function formatPrice(price) {
    if (price < 0.001) return price.toFixed(8);
    if (price < 1) return price.toFixed(6);
    if (price < 100) return price.toFixed(4);
    return price.toFixed(2);
}

// Send Telegram notification with enhanced formatting
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);
        
        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);
        
        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;
        
        const message = `${emoji} *${signal}* ${emoji}\n\n` +
                        `*Symbol:* ${symbol}\n` +
                        `*Price:* ${formattedPrice}\n` +
                        `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
                        `*Difference:* ${difference.toFixed(2)}%\n` +
                        `*24h Change:* ${stats.priceChangePercent}%\n` +
                        `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
                        `*Timeframe:* ${TIMEFRAME}\n\n` +
                        `*Time:* ${new Date().toLocaleString()}\n\n` +
                        `[View Chart on TradingView](${tradingViewUrl})`;
        
        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { 
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });
        
        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );
        
        log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending Telegram message: ${error.message}`, 'error');
        
        // Retry with simpler message if parse_mode might be the issue
        try {
            const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
            await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
            log(`Sent simplified alert for ${symbol} after error`, 'warning');
        } catch (retryError) {
            log(`Failed to send even simplified message: ${retryError.message}`, 'error');
        }
    }
}

// Check if we should alert for this symbol based on direction change and cooldown
function shouldAlert(symbol, currentState) {
    const now = Date.now();
    const previousState = coinStates.get(symbol);
    const lastAlertTime = lastAlerts.get(symbol) || 0;

    if (previousState !== currentState) {
        coinStates.set(symbol, currentState);
        if (now - lastAlertTime >= ALERT_COOLDOWN) {
            lastAlerts.set(symbol, now);
            return true;
        } else {
            log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
        }
    }
    return false; // No alert if state hasn't changed or cooldown active
}

// Check for EMA crossovers
async function checkEMACross() {
    try {
        const pairs = await getFuturesPairs();
        const timestamp = new Date().toLocaleString();

        console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
        process.stdout.write('Processing: '.cyan);
        
        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair => 
            getKlines(pair)
                .then(klines => ({ pair, klines, error: null }))
                .catch(error => ({ pair, klines: [], error }))
        );
        
        const results = await Promise.all(klinesPromises);

        for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');

            if (error || klines.length < EMA_PERIOD) {
                if (klines.length < EMA_PERIOD) {
                    log(`Skipping ${pair}: Not enough candles (${klines.length}/${EMA_PERIOD})`, 'warning');
                }
                continue;
            }
            
            const closes = klines.map(k => k.close);
            const ema = calculateEMA(closes, EMA_PERIOD);
            
            // Make sure we have enough EMA values
            if (ema.length < 2) {
                log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
            continue;
            }
            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];
            const difference = (lastPrice - lastEMA) / lastEMA * 100;

            // Determine current state (above or below EMA)
            const currentState = lastPrice > lastEMA ? 'above' : 'below';

            // Upward crossover: price crossing from below to above EMA
            if (prevPrice < prevEMA && lastPrice > lastEMA) {
                console.log('\n');
                console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + pair.bold);
                console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
                console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
                console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);
                
                if (shouldAlert(pair, currentState)) {
                    await sendTelegramAlert(pair, 'up', lastPrice, lastEMA, difference);
                }
            }
            // Downward crossover: price crossing from above to below EMA
            else if (prevPrice > prevEMA && lastPrice < lastEMA) {
                console.log('\n');
                console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + pair.bold);
                console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
                console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
                console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);
                
                if (shouldAlert(pair, currentState)) {
                    await sendTelegramAlert(pair, 'down', lastPrice, lastEMA, difference);
                }
            } else {
                // Update state even if no crossover
                coinStates.set(pair, currentState);
            }
        }
        
        console.log('\n');
        console.log(`Check completed at ${timestamp}. Next check in ${(CHECK_INTERVAL / 1000 / 60).toFixed(1)} minutes.`.gray);
        console.log('='.repeat(80).dim);
    } catch (error) {
        log(`Error in checkEMACross: ${error.message}`, 'error');
        console.error('Stack trace:', error.stack);
    }
}

// Command handler
function handleMessage(msg) {
    const chatId = msg.chat.id;
    
    if (msg.text === '/start' || msg.text === '/menu') {
        sendMainMenu(chatId);
    } else if (msg.text === '/status') {
        sendStatusUpdate(chatId);
    } else if (msg.text === '/settings') {
        sendSettingsMenu(chatId);
    } else if (msg.text === '/help') {
        sendHelpMessage(chatId);
    } else if (msg.text === '/top') {
        sendTopPerformers(chatId);
    }
}

// Callback query handler for inline buttons
async function handleCallbackQuery(callbackQuery) {
    const action = callbackQuery.data;
    const chatId = callbackQuery.message.chat.id;
    
    try {
        if (action === 'status') {
            await sendStatusUpdate(chatId);
        } else if (action === 'settings') {
            await sendSettingsMenu(chatId);
        } else if (action === 'top_gainers') {
            await sendTopPerformers(chatId, 'gainers');
        } else if (action === 'top_losers') {
            await sendTopPerformers(chatId, 'losers');
        } else if (action === 'top_volume') {
            await sendTopPerformers(chatId, 'volume');
        } else if (action === 'menu') {
            await sendMainMenu(chatId);
        } else if (action === 'help') {
            await sendHelpMessage(chatId);
        } else if (action.startsWith('timeframe_')) {
            const newTimeframe = action.replace('timeframe_', '');
            // Update the timeframe
            TIMEFRAME = newTimeframe;
            log(`Timeframe updated to ${newTimeframe}`, 'success');
            saveSettings();
            await bot.sendMessage(chatId, `âœ… Timeframe updated to ${newTimeframe}`);
            await sendSettingsMenu(chatId);
        } else if (action.startsWith('ema_')) {
            const newEma = parseInt(action.replace('ema_', ''), 10);
            // Update the EMA period
            EMA_PERIOD = newEma;
            log(`EMA period updated to ${newEma}`, 'success');
            saveSettings();
            await bot.sendMessage(chatId, `âœ… EMA period updated to ${newEma}`);
            await sendSettingsMenu(chatId);
        }
            
        // Answer callback query to remove loading state
        await bot.answerCallbackQuery(callbackQuery.id);
    } catch (error) {
        log(`Error handling callback query: ${error.message}`, 'error');
        await bot.answerCallbackQuery(callbackQuery.id, { text: 'An error occurred' });
    }
}

// Add this function to save settings to a file
function saveSettings() {
    try {
        const settings = {
            EMA_PERIOD,
            TIMEFRAME,
            VOLUME_THRESHOLD,
            CHECK_INTERVAL,
            ALERT_COOLDOWN
        };
        
        fs.writeFileSync(
            path.join(__dirname, 'settings.json'), 
            JSON.stringify(settings, null, 2)
        );
        log('Settings saved to file', 'success');
    } catch (error) {
        log(`Error saving settings: ${error.message}`, 'error');
    }
}

// Add this function to load settings from file
function loadSettings() {
    try {
        const settingsPath = path.join(__dirname, 'settings.json');
        if (fs.existsSync(settingsPath)) {
            const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
            
            // Update variables with saved settings
            // Set EMA_PERIOD to the value from settings file, or keep existing if not found
            EMA_PERIOD = settings.EMA_PERIOD || EMA_PERIOD;
            // Set TIMEFRAME to the value from settings file, or keep existing if not found
            TIMEFRAME = settings.TIMEFRAME || TIMEFRAME;
            // You can also load other settings if needed
            VOLUME_THRESHOLD = settings.VOLUME_THRESHOLD || VOLUME_THRESHOLD;
            
            
            log('Settings loaded from file', 'success');
        }
        
    } catch (error) {
        log(`Error loading settings: ${error.message}`, 'error');
    }
}

// Send main menu
async function sendMainMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [{ text: 'ðŸ“Š Status', callback_data: 'status' }],
            [{ text: 'âš™ï¸ Settings', callback_data: 'settings' }],
            [
                { text: 'ðŸ“ˆ Top Gainers', callback_data: 'top_gainers' },
                { text: 'ðŸ“‰ Top Losers', callback_data: 'top_losers' }
            ],
            [{ text: 'ðŸ’° Highest Volume', callback_data: 'top_volume' }],
            [{ text: 'â“ Help', callback_data: 'help' }]
        ]
    };
    
    await bot.sendMessage(chatId, '*EMA Tracker Bot Menu*\nSelect an option:', {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}
    
// Send status update
async function sendStatusUpdate(chatId) {
    try {
        const pairs = await getFuturesPairs();
        const message = `*EMA Tracker Status*\n\n` +
                        `*Active Configuration:*\n` +
                        `- EMA Period: ${EMA_PERIOD}\n` +
                        `- Timeframe: ${TIMEFRAME}\n` +
                        `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
                        `- Monitoring: ${pairs.length} pairs\n` +
                        `- Last Check: ${new Date().toLocaleString()}\n\n` +
                        `Bot is actively monitoring for EMA crossovers.`;
        
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
            }
        });
    } catch (error) {
        log(`Error sending status update: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching status');
    }
}
    
// Send settings menu
async function sendSettingsMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [
                { text: '1m', callback_data: 'timeframe_1m' },
                { text: '5m', callback_data: 'timeframe_5m' },
                { text: '15m', callback_data: 'timeframe_15m' },
                { text: '1h', callback_data: 'timeframe_1h' },
                { text: '4h', callback_data: 'timeframe_4h' }
            ],
            [
                { text: 'EMA 50', callback_data: 'ema_50' },
                { text: 'EMA 100', callback_data: 'ema_100' },
                { text: 'EMA 200', callback_data: 'ema_200' }
            ],
            [
                { text: 'Vol 50M', callback_data: 'volume_50000000' },
                { text: 'Vol 100M', callback_data: 'volume_100000000' },
                { text: 'Vol 200M', callback_data: 'volume_200000000' }
            ],
            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
        ]
    };
    
    await bot.sendMessage(chatId, `*Settings*\n\nCurrent Configuration:\n- EMA: ${EMA_PERIOD}\n- Timeframe: ${TIMEFRAME}\n\n- Volume Threshold: ${formatVolume(VOLUME_THRESHOLD)}\n\nSelect a new setting:`, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}
    
// Send help message
async function sendHelpMessage(chatId) {
    const helpText = `*EMA Tracker Bot Help*\n\n` +
                    `This bot monitors Binance Futures markets for EMA crossovers and sends alerts when they occur.\n\n` +
                    `*Available Commands:*\n` +
                    `/menu - Show the main menu\n` +
                    `/status - Check bot status\n` +
                    `/settings - Configure bot settings\n` +
                    `/top - View top performing coins\n` +
                    `/help - Show this help message\n\n` +
                    `*How It Works:*\n` +
                    `The bot tracks when price crosses above or below the ${EMA_PERIOD} EMA on the ${TIMEFRAME} timeframe for high-volume coins.\n\n` +
                    `*Volume Alerts:*\n` +
                    `You'll also receive alerts when new coins cross the ${VOLUME_THRESHOLD.toLocaleString()} volume threshold.`;
    
    await bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
        }
    });
}
    
// Send top performers (gainers, losers, or by volume)
async function sendTopPerformers(chatId, type = 'gainers') {
    try {
        await bot.sendMessage(chatId, 'â³ Fetching data...');
        
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        let coins = response.data.filter(coin => coin.symbol.endsWith('USDT'));
        
        // Sort based on type
        if (type === 'gainers') {
            coins.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 gainers
        } else if (type === 'losers') {
            coins.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 losers
        } else if (type === 'volume') {
            coins.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            coins = coins.slice(0, 10); // Top 10 by volume
        }
        
        let title;
        if (type === 'gainers') title = 'ðŸ“ˆ *Top Gainers (24h)*';
        else if (type === 'losers') title = 'ðŸ“‰ *Top Losers (24h)*';
        else title = 'ðŸ’° *Highest Volume (24h)*';
        
        let message = `${title}\n\n`;
        
        coins.forEach((coin, index) => {
            const symbol = coin.symbol;
            const price = formatPrice(parseFloat(coin.lastPrice));
            const change = parseFloat(coin.priceChangePercent).toFixed(2);
            const volume = formatVolume(parseFloat(coin.quoteVolume));
            
            const changeEmoji = parseFloat(change) >= 0 ? 'ðŸŸ¢' : 'ðŸ”´';
            message += `${index + 1}. ${symbol}: ${price} (${changeEmoji} ${change}%) - Vol: ${volume}\n`;
        });
        
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“ˆ Gainers', callback_data: 'top_gainers' },
                        { text: 'ðŸ“‰ Losers', callback_data: 'top_losers' },
                        { text: 'ðŸ’° Volume', callback_data: 'top_volume' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error fetching top performers: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching data');
    }
}
    
// Send initial startup message to Telegram
async function sendStartupMessage() {
    try {
        const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
                        `*Configuration:*\n` +
                        `- EMA Period: ${EMA_PERIOD}\n` +
                        `- Timeframe: ${TIMEFRAME}\n` +
                        `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
                        `- Check Interval: ${(CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
                        `- Alert Cooldown: ${(ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n\n` +
                        `Bot is now monitoring for EMA crossovers...`;
        
        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
        log('Startup message sent to Telegram', 'success');
        
        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Started',
            `Monitoring ${TIMEFRAME} timeframe with ${EMA_PERIOD} EMA`,
            'info'
        );
        
        // Send the menu after startup message
        await sendMainMenu(TELEGRAM_CHAT_ID);
    } catch (error) {
        log(`Error sending startup message: ${error.message}`, 'error');
    }
}
    
// Set up message and callback query handlers
bot.on('message', handleMessage);
bot.on('callback_query', handleCallbackQuery);
    
// Handle process termination gracefully
process.on('SIGINT', async () => {
    try {
        log('Received SIGINT. Shutting down gracefully...', 'warning');
        await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');
        
        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Shutting Down',
            'The bot is shutting down gracefully',
            'warning'
        );
        
        process.exit(0);
    } catch (error) {
        log(`Error during shutdown: ${error.message}`, 'error');
        process.exit(1);
    }
});
    
// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');
    
    // Show desktop notification for unhandled rejection
    showDesktopNotification(
        'Error in EMA Tracker',
        'An unhandled rejection occurred. Check logs for details.',
        'error'
    );
});

// Initialize the terminal and start monitoring
initializeTerminal();
loadSettings(); // Load saved settings from file
console.log('\nStarting initial check...'.green);
sendStartupMessage().then(async () => {
    // Do initial check without notifications
    await checkEMACross();
    
    // Now set flag to enable volume threshold notifications for subsequent checks
    initialLoadComplete = true;
    log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');
    
    // Run the check at the specified interval indefinitely
    monitoringInterval = setInterval(checkEMACross, CHECK_INTERVAL);
}).catch(error => {
    log(`Failed to start: ${error.message}`, 'error');
    
    // Show desktop notification for startup failure
    showDesktopNotification(
        'EMA Tracker Failed to Start',
        `Error: ${error.message}`,
        'error'
    );
});




--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------

not tested for now last 2 is checked



-

const axios = require('axios');
const colors = require('colors');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');
const WebSocket = require('ws');
const { createObjectCsvWriter } = require('csv-writer');

let initialLoadComplete = false;
// ML configuration
let ML_ENABLED = true;

// Configuration (Consider externalizing these variables or using environment variables)
let EMA_PERIOD = parseInt(process.env.EMA_PERIOD, 10) || 200;
let TIMEFRAME = process.env.TIMEFRAME || '15m';
let VOLUME_THRESHOLD = parseInt(process.env.VOLUME_THRESHOLD, 10) || 100_000_000;
const CHECK_INTERVAL = parseInt(process.env.CHECK_INTERVAL, 10) || 5 * 60 * 1000; // 5 minutes
const ALERT_COOLDOWN = parseInt(process.env.ALERT_COOLDOWN, 10) || 15 * 60 * 1000; // 15 minutes cooldown for alerts

// Telegram configuration with your provided credentials
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Store last alert times and states for each symbol
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring

// WebSocket related variables
const activeWebSockets = new Map(); // Track active WebSocket connections
const klineCache = new Map(); // Cache for kline data
const emaCache = new Map(); // Cache for calculated EMAs
const trainingData = new Map(); // Store historical data for ML training
// Track model performance
const modelPerformance = new Map();

// ML directories
const ML_DATA_DIR = path.join(__dirname, 'ml_data');
const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
const MODEL_PATH = path.join(__dirname, 'ml_models');

// At the top of your file, after other requires
const brainML = require('./ml_alternative');

// Create a log directory for persistent logging
const LOG_DIR = path.join(__dirname, 'logs');
if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR);
}

// Create ML directories
if (!fs.existsSync(ML_DATA_DIR)) {
    fs.mkdirSync(ML_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(CSV_DATA_DIR)) {
    fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(MODEL_PATH)) {
    fs.mkdirSync(MODEL_PATH, { recursive: true });
}

// Log function that writes to both console and file
function log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;

    // Console logging with colors
    switch (type) {
        case 'error':
            console.error(logMessage.red);
            break;
        case 'success':
            console.log(logMessage.green);
            break;
        case 'warning':
            console.log(logMessage.yellow);
            break;
        default:
            console.log(logMessage);
    }

    // File logging
    const logFile = path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logMessage + '\n');
}

// Check if TensorFlow.js can be loaded
function checkTensorFlowAvailability() {
    try {
        require('@tensorflow/tfjs-node');
        log('TensorFlow.js is available', 'success');
        return true;
    } catch (e) {
        try {
            require('@tensorflow/tfjs-node-cpu');
            log('TensorFlow.js CPU version is available', 'warning');
            return true;
        } catch (e2) {
            log(`TensorFlow.js is not available: ${e2.message}`, 'error');
            log('ML predictions will be disabled', 'warning');
            return false;
        }
    }
}

// Show desktop notification using node-notifier
function showDesktopNotification(title, message, type = 'info') {
    try {
        notifier.notify({
            title: title,
            message: message,
            sound: true,
            wait: true,
            icon: path.join(__dirname, type === 'error' ? 'error.png' :
                type === 'warning' ? 'warning.png' : 'info.png')
        });

        log(`Desktop notification shown: ${title} - ${message}`);
    } catch (error) {
        log(`Failed to show desktop notification: ${error.message}`, 'error');
    }
}

// Initialize terminal
function initializeTerminal() {
    console.clear();
    console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);
    console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
    console.log(`Configuration: ${EMA_PERIOD} EMA | ${TIMEFRAME} Timeframe | Volume > ${VOLUME_THRESHOLD.toLocaleString()}`.cyan);
    console.log(`Alert Cooldown: ${ALERT_COOLDOWN / 60000} minutes`.magenta);
    console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
    console.log(`WebSocket Real-Time Monitoring: Enabled`.green);
    console.log(`Machine Learning: ${ML_ENABLED ? 'Enabled'.green : 'Disabled'.red}`);
    console.log('='.repeat(80).dim);
    console.log('\nCROSSOVER EVENTS:'.cyan.bold);

    log(`EMA Tracker started with configuration: EMA=${EMA_PERIOD}, Timeframe=${TIMEFRAME}, Volume Threshold=${VOLUME_THRESHOLD}, ML=${ML_ENABLED}`);
}

// Helper function to format volume
function formatVolume(volume) {
    if (volume >= 1_000_000_000) {
        return (volume / 1_000_000_000).toFixed(2) + 'B';
    } else if (volume >= 1_000_000) {
        return (volume / 1_000_000).toFixed(2) + 'M';
    } else if (volume >= 1_000) {
        return (volume / 1_000).toFixed(2) + 'K';
    }
    return volume.toFixed(2);
}

// Format price with appropriate precision based on value
function formatPrice(price) {
    if (price < 0.001) return price.toFixed(8);
    if (price < 1) return price.toFixed(6);
    if (price < 100) return price.toFixed(4);
    return price.toFixed(2);
}

// Function to get 24hr stats for a symbol
async function get24HrStats(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            params: { symbol }
        });
        return {
            priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
            quoteVolume: parseFloat(response.data.quoteVolume)
        };
    } catch (error) {
        log(`Error fetching 24hr stats for ${symbol}: ${error.message}`, 'error');
        return { priceChangePercent: '0.00', quoteVolume: '0' };
    }
}

// Fetch Binance Futures pairs with 24hr quote volume above the threshold
async function getFuturesPairs() {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        const newPairs = [];

        const pairs = response.data
            .filter(pair => {
                const volume = parseFloat(pair.quoteVolume);
                const symbol = pair.symbol;

                if (volume > VOLUME_THRESHOLD) {
                    // Only track new pairs that cross threshold after initial load
                    if (initialLoadComplete && !trackedPairs.has(symbol)) {
                        newPairs.push({
                            symbol,
                            volume,
                            price: parseFloat(pair.lastPrice),
                            change: parseFloat(pair.priceChangePercent)
                        });
                    }
                    trackedPairs.add(symbol);
                    return true;
                }
                return false;
            })
            .map(pair => pair.symbol);

        // Alert for new pairs that crossed the volume threshold (only after initial load)
        if (newPairs.length > 0) {
            alertNewHighVolumePairs(newPairs);
        }

        return pairs;
    } catch (error) {
        log(`Error fetching futures pairs: ${error.message}`, 'error');
        return [];
    }
}

// Alert when new pairs cross the volume threshold
async function alertNewHighVolumePairs(newPairs) {
    for (const pair of newPairs) {
        const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
            `*Symbol:* ${pair.symbol}\n` +
            `*Volume:* ${formatVolume(pair.volume)}\n` +
            `*Price:* ${formatPrice(pair.price)}\n` +
            `*24h Change:* ${pair.change.toFixed(2)}%\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `This pair has been added to the monitoring list.`;

        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

            // Show desktop notification
            showDesktopNotification(
                'New High Volume Pair',
                `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
                'info'
            );

            log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');

            // Setup WebSocket for the new pair
            setupSymbolWebSocket(pair.symbol);
        } catch (error) {
            log(`Error sending new pair alert for ${pair.symbol}: ${error.message}`, 'error');
        }
    }
}

// Retrieve historical candlestick data for the given symbol
async function getKlines(symbol) {
    try {
        const limit = EMA_PERIOD + 100; // Request extra candles to be safe

        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: { symbol, interval: TIMEFRAME, limit: limit }
        });

        const klines = response.data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));

        // Update the kline cache
        klineCache.set(symbol, klines);

        // Calculate and cache EMA
        const closes = klines.map(k => k.close);
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        if (klines.length < EMA_PERIOD) {
            log(`Warning: Not enough candles for ${symbol}. Needed ${EMA_PERIOD}, got ${klines.length}`, 'warning');
        }

        return klines;
    } catch (error) {
        log(`Error fetching klines for ${symbol}: ${error.message}`, 'error');
        return [];
    }
}

// Calculate the EMA for an array of prices given a period
function calculateEMA(prices, period) {
    if (prices.length < period) {
        log(`Warning: Not enough prices for EMA calculation. Needed ${period}, got ${prices.length}`, 'warning');
        return [];
    }

    const k = 2 / (period + 1);
    let emaArray = [];

    // Start with the simple moving average as the first EMA
    let sma = prices.slice(0, period).reduce((sum, p) => sum + p, 0) / period;
    let ema = sma;

    // Add the first EMA (which is the SMA)
    emaArray.push(ema);

    // Calculate EMA for the remaining prices
    for (let i = period; i < prices.length; i++) {
        ema = (prices[i] - ema) * k + ema;
        emaArray.push(ema);
    }

    return emaArray;
}

// Update EMA with a new price (for real-time updates)
function updateEMA(symbol, newPrice) {
    // Get cached EMA values
    let emaValues = emaCache.get(symbol);

    // If no cached values, we need to fetch historical data first
    if (!emaValues || emaValues.length === 0) {
        log(`No cached EMA values for ${symbol}, fetching historical data...`, 'warning');
        return false;
    }

    const k = 2 / (EMA_PERIOD + 1);
    const lastEMA = emaValues[emaValues.length - 1];
    const newEMA = (newPrice - lastEMA) * k + lastEMA;

    // Add the new EMA to the cache
    emaValues.push(newEMA);

    // Keep the cache size reasonable by removing older values
    if (emaValues.length > EMA_PERIOD * 2) {
        emaValues = emaValues.slice(-EMA_PERIOD * 2);
    }

    emaCache.set(symbol, emaValues);
    return true;
}

// Send Telegram notification with enhanced formatting
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending Telegram message: ${error.message}`, 'error');

        // Retry with simpler message if parse_mode might be the issue
        try {
            const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
            await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
            log(`Sent simplified alert for ${symbol} after error`, 'warning');
        } catch (retryError) {
            log(`Failed to send even simplified message: ${retryError.message}`, 'error');
        }
    }
}

// Check if we should alert for this symbol based on direction change and cooldown
function shouldAlert(symbol, currentState) {
    const now = Date.now();
    const previousState = coinStates.get(symbol);
    const lastAlertTime = lastAlerts.get(symbol) || 0;

    if (previousState !== currentState) {
        coinStates.set(symbol, currentState);
        if (now - lastAlertTime >= ALERT_COOLDOWN) {
            lastAlerts.set(symbol, now);
            return true;
        } else {
            log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
        }
    }
    return false; // No alert if state hasn't changed or cooldown active
}

// WebSocket setup for a symbol
function setupSymbolWebSocket(symbol) {
    // Close existing connection if any
    if (activeWebSockets.has(symbol)) {
        try {
            activeWebSockets.get(symbol).close();
        } catch (e) {
            // Ignore errors when closing
        }
    }

    // Create WebSocket URL based on timeframe
    const wsSymbol = symbol.toLowerCase();
    const wsUrl = `wss://fstream.binance.com/ws/${wsSymbol}@kline_${TIMEFRAME}`;

    // Only log to file, not to console
    fs.appendFileSync(
        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
        `[${new Date().toISOString()}] Setting up WebSocket for ${symbol} on ${TIMEFRAME} timeframe\n`
    );

    try {
        const ws = new WebSocket(wsUrl);

        ws.on('open', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection established for ${symbol}\n`
            );
        });

        ws.on('message', (data) => {
            try {
                const message = JSON.parse(data);

                // Process kline data
                if (message.e === 'kline') {
                    const kline = message.k;

                    // Only process if the candle is closed or if we want to process real-time
                    if (kline.x === true) { // Candle closed
                        processClosedCandle(symbol, kline);
                    } else {
                        // Process real-time candle updates without logging unconfirmed events
                        processRealtimeCandle(symbol, kline, false); // Added parameter to suppress logging
                    }
                }
            } catch (error) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Error processing WebSocket message for ${symbol}: ${error.message}\n`
                );
            }
        });

        ws.on('error', (error) => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket error for ${symbol}: ${error.message}\n`
            );
            // Try to reconnect after a delay
            setTimeout(() => setupSymbolWebSocket(symbol), 5000);
        });

        ws.on('close', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection closed for ${symbol}\n`
            );
            // Try to reconnect after a delay if it wasn't intentionally closed
            if (trackedPairs.has(symbol)) {
                setTimeout(() => setupSymbolWebSocket(symbol), 5000);
            }
        });

        // Store the WebSocket connection
        activeWebSockets.set(symbol, ws);

        // Initialize with historical data
        getKlines(symbol).then(() => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Historical data loaded for ${symbol}\n`
            );
        }).catch(error => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error loading historical data for ${symbol}: ${error.message}\n`
            );
        });

        return ws;
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSocket for ${symbol}: ${error.message}\n`
        );
        return null;
    }
}

// Helper function to calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) return null;

    const trueRanges = [];

    // Calculate True Range for each candle
    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        trueRanges.push(Math.max(tr1, tr2, tr3));
    }

    // Calculate ATR as average of true ranges
    if (trueRanges.length < period) return null;

    const atr = trueRanges.slice(-period).reduce((sum, tr) => sum + tr, 0) / period;
    return atr;
}

// Process a closed candle from WebSocket with improved ML data collection
async function processClosedCandle(symbol, kline) {
    try {
        // Get cached klines or initialize if not exists
        let klines = klineCache.get(symbol) || [];

        // Create new kline object
        const newKline = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
        };

        // Add new kline to cache
        klines.push(newKline);

        // Keep cache size reasonable
        if (klines.length > EMA_PERIOD * 2) {
            klines = klines.slice(-EMA_PERIOD * 2);
        }

        klineCache.set(symbol, klines);

        // Get closes for EMA calculation
        const closes = klines.map(k => k.close);
        const volumes = klines.map(k => k.volume);

        // Calculate new EMA values
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        // Collect data for ML training if we have enough data
        if (klines.length >= 30 && ML_ENABLED) {
            // Calculate additional indicators
            const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
            const rsi = calculateRSI(closes);
            const macd = calculateMACD(closes);
            const bb = calculateBollingerBands(closes);

            // Calculate ATR
            const atr = calculateATR(klines);

            // Create feature vector
            const dataPoint = {
                timestamp: kline.t,
                symbol: symbol,
                open: newKline.open,
                high: newKline.high,
                low: newKline.low,
                close: newKline.close,
                volume: newKline.volume,
                ema: emaValues[emaValues.length - 1],
                ema_diff: ((newKline.close - emaValues[emaValues.length - 1]) / emaValues[emaValues.length - 1] * 100),
                rsi: rsi[rsi.length - 1],
                macd: macd.macd[macd.macd.length - 1],
                macd_signal: macd.signal[macd.signal.length - 1],
                macd_hist: macd.histogram[macd.histogram.length - 1],
                bb_upper: bb.upper[bb.upper.length - 1],
                bb_middle: bb.middle[bb.middle.length - 1],
                bb_lower: bb.lower[bb.lower.length - 1],
                bb_width: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.middle[bb.middle.length - 1],
                atr: atr,
                volume_change: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
                // Target variable (to be filled later)
                future_price_change: null,
                label: null // 1 for price increase, 0 for decrease
            };

            // Store data in memory
            if (!trainingData.has(symbol)) {
                trainingData.set(symbol, []);
            }
            trainingData.get(symbol).push(dataPoint);

            // Keep training data size manageable (last 1000 candles)
            if (trainingData.get(symbol).length > 1000) {
                trainingData.set(symbol, trainingData.get(symbol).slice(-1000));
            }

            // Save to JSON file
            saveDataPoint(symbol, dataPoint);

            // Export to CSV periodically
            if (trainingData.get(symbol).length % 10 === 0) {
                exportToCSV(symbol);
            }

            // Schedule update of future price change (after 24 hours)
            setTimeout(() => updateFuturePriceChange(symbol, kline.t), 24 * 60 * 60 * 1000);
        }

        // Check for crossover
        if (emaValues.length >= 2) {
            const lastPrice = closes[closes.length - 1];
            const prevPrice = closes[closes.length - 2];
            const lastEMA = emaValues[emaValues.length - 1];
            const prevEMA = emaValues[emaValues.length - 2];

            checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA);
        }
    } catch (error) {
        log(`Error processing closed candle for ${symbol}: ${error.message}`, 'error');
    }
}

// Save data point to JSON file
function saveDataPoint(symbol, dataPoint) {
    try {
        // Create directory for this symbol if it doesn't exist
        const symbolDir = path.join(ML_DATA_DIR, symbol);
        if (!fs.existsSync(symbolDir)) {
            fs.mkdirSync(symbolDir, { recursive: true });
        }

        // Use current month for filename to organize data
        const date = new Date();
        const filename = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}.json`;
        const filePath = path.join(symbolDir, filename);

        // Load existing data or create new array
        let data = [];
        if (fs.existsSync(filePath)) {
            try {
                data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (e) {
                log(`Error reading data file for ${symbol}: ${e.message}`, 'error');
                // If file is corrupted, start fresh
                data = [];
            }
        }

        // Add new data point
        data.push(dataPoint);

        // Save data back to file
        fs.writeFileSync(filePath, JSON.stringify(data, null, 2));

        // Only log occasionally to avoid excessive logging
        if (data.length % 100 === 0) {
            log(`Collected ${data.length} data points for ${symbol} (${filename})`, 'info');
        }

        return true;
    } catch (error) {
        log(`Error saving data point for ${symbol}: ${error.message}`, 'error');
        return false;
    }
}

// Export training data to CSV for easier model training
function exportToCSV(symbol) {
    try {
        if (!trainingData.has(symbol) || trainingData.get(symbol).length === 0) {
            return;
        }

        const data = trainingData.get(symbol);

        // Create directory for this symbol if it doesn't exist
        const symbolDir = path.join(CSV_DATA_DIR, symbol);
        if (!fs.existsSync(symbolDir)) {
            fs.mkdirSync(symbolDir, { recursive: true });
        }

        // Create CSV file path
        const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

        // Define CSV writer
        const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
                { id: 'timestamp', title: 'TIMESTAMP' },
                { id: 'symbol', title: 'SYMBOL' },
                { id: 'open', title: 'OPEN' },
                { id: 'high', title: 'HIGH' },
                { id: 'low', title: 'LOW' },
                { id: 'close', title: 'CLOSE' },
                { id: 'volume', title: 'VOLUME' },
                { id: 'ema', title: 'EMA' },
                { id: 'ema_diff', title: 'EMA_DIFF' },
                { id: 'rsi', title: 'RSI' },
                { id: 'macd', title: 'MACD' },
                { id: 'macd_signal', title: 'MACD_SIGNAL' },
                { id: 'macd_hist', title: 'MACD_HIST' },
                { id: 'bb_upper', title: 'BB_UPPER' },
                { id: 'bb_middle', title: 'BB_MIDDLE' },
                { id: 'bb_lower', title: 'BB_LOWER' },
                { id: 'bb_width', title: 'BB_WIDTH' },
                { id: 'atr', title: 'ATR' },
                { id: 'volume_change', title: 'VOLUME_CHANGE' },
                { id: 'future_price_change', title: 'FUTURE_PRICE_CHANGE' },
                { id: 'label', title: 'LABEL' }
            ]
        });

        // Write data to CSV
        csvWriter.writeRecords(data)
            .then(() => {
                log(`CSV export completed for ${symbol} with ${data.length} records`, 'success');
            })
            .catch(error => {
                log(`Error writing CSV for ${symbol}: ${error.message}`, 'error');
            });
    } catch (error) {
        log(`Error exporting to CSV for ${symbol}: ${error.message}`, 'error');
    }
}

// Export all training data to CSV
function exportAllDataToCSV() {
    try {
        log('Exporting all training data to CSV...', 'info');

        for (const [symbol, data] of trainingData.entries()) {
            if (data.length > 0) {
                exportToCSV(symbol);
            }
        }

        log('All training data exported to CSV successfully', 'success');
    } catch (error) {
        log(`Error exporting all data to CSV: ${error.message}`, 'error');
    }
}

// Process real-time candle updates
function processRealtimeCandle(symbol, kline, logUnconfirmed = true) {
    try {
        // Get cached klines
        const klines = klineCache.get(symbol);
        if (!klines || klines.length === 0) {
            return; // No historical data yet
        }

        // Get current price
        const currentPrice = parseFloat(kline.c);

        // Get cached EMA values
        const emaValues = emaCache.get(symbol);
        if (!emaValues || emaValues.length < 2) {
            return; // Not enough EMA values yet
        }

        // Get the last closed price and EMA
        const lastClosedPrice = klines[klines.length - 1].close;
        const lastEMA = emaValues[emaValues.length - 1];

        // Determine current state (above or below EMA)
        const prevState = lastClosedPrice > lastEMA ? 'above' : 'below';
        const currentState = currentPrice > lastEMA ? 'above' : 'below';

        // If state changed, we have a potential real-time crossover
        if (prevState !== currentState) {
            // Calculate difference percentage
            const difference = (currentPrice - lastEMA) / lastEMA * 100;

            // Only log if explicitly requested (for debugging)
            if (logUnconfirmed) {
                // Log the potential crossover but don't send alert yet
                console.log('\n');
                const crossType = currentState === 'above' ? 'up' : 'down';
                const crossLabel = crossType === 'up' ?
                    'â–²'.yellow + ' POTENTIAL UPWARD CROSSOVER '.black.bgYellow :
                    'â–¼'.yellow + ' POTENTIAL DOWNWARD CROSSOVER '.black.bgYellow;

                console.log(crossLabel + ' ' + symbol.bold);
                console.log(`  Current Price: ${formatPrice(currentPrice)[crossType === 'up' ? 'green' : 'red']}`);
                console.log(`  EMA(${EMA_PERIOD}): ${formatPrice(lastEMA).cyan}`);
                console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);
                console.log(`  Status: ${'REAL-TIME (Unconfirmed)'.yellow}`);
            }

            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Potential ${currentState === 'above' ? 'upward' : 'downward'} crossover detected for ${symbol} (unconfirmed)\n`
            );
        }
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error processing real-time candle for ${symbol}: ${error.message}\n`
        );
    }
}

// Function to update future price change for training data
async function updateFuturePriceChange(symbol, timestamp) {
    try {
        if (!trainingData.has(symbol)) return;

        const data = trainingData.get(symbol);
        const dataPoint = data.find(d => d.timestamp === timestamp);

        if (!dataPoint) return;

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);
        const originalPrice = dataPoint.close;

        // Calculate price change percentage
        const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);

        // Update the data point
        dataPoint.future_price_change = priceChange;
        dataPoint.label = priceChange >= 0 ? 1 : 0;

        log(`Updated future price change for ${symbol}: ${priceChange.toFixed(2)}%`, 'info');

        // Update the data in JSON files
        updateStoredDataPoint(symbol, timestamp, priceChange);

        // Update CSV file
        exportToCSV(symbol);
    } catch (error) {
        log(`Error updating future price change: ${error.message}`, 'error');
    }
}

// Update a stored data point in JSON files
function updateStoredDataPoint(symbol, timestamp, priceChange) {
    try {
        // Find the file containing this timestamp
        const symbolDir = path.join(ML_DATA_DIR, symbol);
        if (!fs.existsSync(symbolDir)) {
            return false;
        }

        const files = fs.readdirSync(symbolDir).filter(f => f.endsWith('.json'));

        for (const file of files) {
            const filePath = path.join(symbolDir, file);
            const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));

            // Find the data point with matching timestamp
            const index = data.findIndex(d => d.timestamp === timestamp);
            if (index !== -1) {
                // Update the future price change
                data[index].future_price_change = priceChange;
                data[index].label = priceChange >= 0 ? 1 : 0;

                // Save the updated data
                fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
                return true;
            }
        }

        return false;
    } catch (error) {
        log(`Error updating stored data point for ${symbol}: ${error.message}`, 'error');
        return false;
    }
}

// Function to get current price
async function getCurrentPrice(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/price', {
            params: { symbol }
        });
        return parseFloat(response.data.price);
    } catch (error) {
        log(`Error getting current price for ${symbol}: ${error.message}`, 'error');
        throw error;
    }
}

// Check for crossover and send alerts if needed with ML prediction
async function checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA) {
    try {
        // Determine current state (above or below EMA)
        const currentState = lastPrice > lastEMA ? 'above' : 'below';
        const difference = (lastPrice - lastEMA) / lastEMA * 100;

        // Get ML prediction if available
        let prediction = null;
        if (ML_ENABLED) {
            try {
                prediction = await predictPriceMovement(symbol, lastPrice, lastEMA, difference);
            } catch (predictionError) {
                log(`Error getting prediction for ${symbol}: ${predictionError.message}`, 'warning');
                // Continue without prediction
            }
        }

        // Upward crossover: price crossing from below to above EMA
        if (prevPrice < prevEMA && lastPrice > lastEMA) {
            console.log('\n');
            console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (prediction !== null) {
                console.log(`  ML Prediction: ${prediction.toFixed(2)}% expected change`.cyan);
            }

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'up', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'up', lastPrice, lastEMA, difference);
                }
            }
        }
        // Downward crossover: price crossing from above to below EMA
        else if (prevPrice > prevEMA && lastPrice < lastEMA) {
            console.log('\n');
            console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (prediction !== null) {
                console.log(`  ML Prediction: ${prediction.toFixed(2)}% expected change`.cyan);
            }

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'down', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'down', lastPrice, lastEMA, difference);
                }
            }
        } else {
            // Update state even if no crossover
            coinStates.set(symbol, currentState);
        }
    } catch (error) {
        log(`Error checking for crossover for ${symbol}: ${error.message}`, 'error');
    }
}

// Function to make price movement prediction
async function predictPriceMovement(symbol, price, ema, emaDiff) {
    try {
        if (!ML_ENABLED) return null;

        // Get the ML model module
        const mlModel = require('./ml_model');

        // Get additional features for prediction
        const klines = klineCache.get(symbol) || [];
        if (klines.length < 30) return null;

        const closes = klines.map(k => k.close);
        const volumes = klines.map(k => k.volume || 0);

        // Calculate indicators
        const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
        const rsi = calculateRSI(closes);
        const macd = calculateMACD(closes);
        const bb = calculateBollingerBands(closes);
        const atr = calculateATR(klines);

        // Create feature object for prediction
        const features = {
            priceDiff: emaDiff,
            volume24h: volumes[volumes.length - 1],
            volumeChange: volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1,
            relativeVolume: volumes[volumes.length - 1] / volumes.slice(-10).reduce((sum, vol) => sum + vol, 0) * 10,
            atr: atr || 0,
            bbWidth: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.middle[bb.middle.length - 1],
            rsi: rsi[rsi.length - 1],
            macdHist: macd.histogram[macd.histogram.length - 1]
        };

        // Make prediction
        const prediction = await mlModel.predictPriceChange(symbol, features);

        // Update model performance tracking
        if (prediction !== null) {
            if (!modelPerformance.has(symbol)) {
                modelPerformance.set(symbol, {
                    predictions: 1,
                    correctPredictions: 0,
                    accuracy: 0,
                    lastTraining: '',
                    dataPoints: 0
                });
            } else {
                const perf = modelPerformance.get(symbol);
                perf.predictions++;
                modelPerformance.set(symbol, perf);
            }

            // Schedule accuracy update
            setTimeout(() => updateModelAccuracy(symbol, price, prediction), 24 * 60 * 60 * 1000);
        }

        return prediction;
    } catch (error) {
        log(`Error predicting price movement for ${symbol}: ${error.message}`, 'error');
        return null;
    }
}

// Update model accuracy after 24 hours
async function updateModelAccuracy(symbol, originalPrice, prediction) {
    try {
        // Get current price
        const currentPrice = await getCurrentPrice(symbol);

        // Calculate actual price change
        const actualChange = ((currentPrice - originalPrice) / originalPrice * 100);

        // Determine if prediction was correct (same direction)
        const predictionCorrect = (prediction > 0 && actualChange > 0) || (prediction < 0 && actualChange < 0);

        // Update model performance
        if (modelPerformance.has(symbol)) {
            const perf = modelPerformance.get(symbol);
            if (predictionCorrect) {
                perf.correctPredictions++;
            }
            perf.accuracy = perf.correctPredictions / perf.predictions;
            modelPerformance.set(symbol, perf);

            log(`Updated model accuracy for ${symbol}: ${(perf.accuracy * 100).toFixed(2)}% (${perf.correctPredictions}/${perf.predictions})`, 'info');
        }

        // Save performance data
        saveTrainingData();
    } catch (error) {
        log(`Error updating model accuracy for ${symbol}: ${error.message}`, 'error');
    }
}

// Setup WebSockets for all tracked pairs
async function setupAllWebSockets() {
    try {
        const pairs = await getFuturesPairs();

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Setting up WebSockets for ${pairs.length} pairs\n`
        );

        // Close any existing WebSockets for pairs that are no longer tracked
        for (const [symbol, ws] of activeWebSockets.entries()) {
            if (!pairs.includes(symbol)) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Closing WebSocket for ${symbol} (no longer tracked)\n`
                );
                try {
                    ws.close();
                } catch (e) {
                    // Ignore errors when closing
                }
                activeWebSockets.delete(symbol);
            }
        }

        // Setup WebSockets for all tracked pairs
        for (const symbol of pairs) {
            if (!activeWebSockets.has(symbol) || activeWebSockets.get(symbol).readyState !== WebSocket.OPEN) {
                setupSymbolWebSocket(symbol);

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] WebSocket setup completed for ${pairs.length} pairs\n`
        );
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSockets: ${error.message}\n`
        );
    }
}

// Check for EMA crossovers (traditional method, still used for initial load and periodic checks)
async function checkEMACross() {
    try {
        const pairs = await getFuturesPairs();
        const timestamp = new Date().toLocaleString();

        console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
        process.stdout.write('Processing: '.cyan);

        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair =>
            getKlines(pair)
                .then(klines => ({ pair, klines, error: null }))
                .catch(error => ({ pair, klines: [], error }))
        );

        const results = await Promise.all(klinesPromises);

        for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');

            if (error || klines.length < EMA_PERIOD) {
                if (klines.length < EMA_PERIOD) {
                    log(`Skipping ${pair}: Not enough candles (${klines.length}/${EMA_PERIOD})`, 'warning');
                }
                continue;
            }

            const closes = klines.map(k => k.close);
            const ema = calculateEMA(closes, EMA_PERIOD);

            // Make sure we have enough EMA values
            if (ema.length < 2) {
                log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
                continue;
            }

            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];

            // Check for crossover
            checkForCrossover(pair, prevPrice, lastPrice, prevEMA, lastEMA);
        }

        console.log('\n');
        console.log(`Check completed at ${timestamp}. WebSockets are now monitoring in real-time.`.gray);
        console.log('='.repeat(80).dim);
    } catch (error) {
        log(`Error in checkEMACross: ${error.message}`, 'error');
        console.error('Stack trace:', error.stack);
    }
}

// Save training data to disk (both JSON and CSV)
function saveTrainingData() {
    try {
        log('Saving training data...', 'info');

        // Save each symbol's data
        for (const [symbol, data] of trainingData.entries()) {
            // Save to JSON
            const symbolDir = path.join(ML_DATA_DIR, symbol);
            if (!fs.existsSync(symbolDir)) {
                fs.mkdirSync(symbolDir, { recursive: true });
            }

            // Use current month for filename
            const date = new Date();
            const filename = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}.json`;
            const filePath = path.join(symbolDir, filename);

            fs.writeFileSync(filePath, JSON.stringify(data, null, 2));

            // Export to CSV
            exportToCSV(symbol);
        }

        // Save model performance data
        fs.writeFileSync(
            path.join(ML_DATA_DIR, 'model_performance.json'),
            JSON.stringify(Array.from(modelPerformance.entries()), null, 2)
        );

        log(`Saved training data for ${trainingData.size} symbols`, 'success');
    } catch (error) {
        log(`Error saving training data: ${error.message}`, 'error');
    }
}

// Load training data from disk
function loadTrainingData() {
    try {
        log('Loading training data...', 'info');

        if (!fs.existsSync(ML_DATA_DIR)) {
            fs.mkdirSync(ML_DATA_DIR, { recursive: true });
            log('Created ML data directory', 'info');
            return;
        }

        // Get all symbol directories
        const symbols = fs.readdirSync(ML_DATA_DIR)
            .filter(item => fs.statSync(path.join(ML_DATA_DIR, item)).isDirectory());

        for (const symbol of symbols) {
            const symbolDir = path.join(ML_DATA_DIR, symbol);
            const files = fs.readdirSync(symbolDir).filter(f => f.endsWith('.json'));

            let symbolData = [];

            for (const file of files) {
                try {
                    const filePath = path.join(symbolDir, file);
                    const fileData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                    symbolData = symbolData.concat(fileData);
                } catch (error) {
                    log(`Error loading data file ${file} for ${symbol}: ${error.message}`, 'warning');
                }
            }

            if (symbolData.length > 0) {
                trainingData.set(symbol, symbolData);
                log(`Loaded ${symbolData.length} data points for ${symbol}`, 'info');
            }
        }

        // Load model performance data
        const perfPath = path.join(ML_DATA_DIR, 'model_performance.json');
        if (fs.existsSync(perfPath)) {
            try {
                const perfData = JSON.parse(fs.readFileSync(perfPath, 'utf8'));
                for (const [symbol, data] of perfData) {
                    modelPerformance.set(symbol, data);
                }
                log(`Loaded performance data for ${modelPerformance.size} models`, 'info');
            } catch (error) {
                log(`Error loading model performance data: ${error.message}`, 'warning');
            }
        }

        log(`Loaded training data for ${trainingData.size} symbols`, 'success');
    } catch (error) {
        log(`Error loading training data: ${error.message}`, 'error');
    }
}

// Function to train all models
async function trainAllModels(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§  Starting model training. This may take some time...');

        // Get all symbols with sufficient data
        const symbolsToTrain = Array.from(trainingData.keys())
            .filter(symbol => {
                const data = trainingData.get(symbol);
                // Only use data points with future price change values
                const validData = data.filter(d => d.future_price_change !== null);
                return validData.length >= 100;
            });

        if (symbolsToTrain.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No symbols have enough data for training yet.');
            return;
        }

        await bot.sendMessage(chatId, `Training models for ${symbolsToTrain.length} symbols...`);

        let trainedCount = 0;
        let failedCount = 0;

        // Train models sequentially
        for (const symbol of symbolsToTrain) {
            try {
                const { trainModelForSymbol } = require('./ml_model');

                // Filter data to only include points with future price change
                const allData = trainingData.get(symbol);
                const validData = allData.filter(d => d.future_price_change !== null);

                if (validData.length < 100) {
                    log(`Not enough valid data points for ${symbol}: ${validData.length}`, 'warning');
                    failedCount++;
                    continue;
                }

                const result = await trainModelForSymbol(symbol);

                if (result) {
                    trainedCount++;

                    // Update model performance tracking
                    if (!modelPerformance.has(symbol)) {
                        modelPerformance.set(symbol, {
                            predictions: 0,
                            correctPredictions: 0,
                            accuracy: 0,
                            lastTraining: new Date().toISOString(),
                            dataPoints: validData.length
                        });
                    } else {
                        const perf = modelPerformance.get(symbol);
                        perf.lastTraining = new Date().toISOString();
                        perf.dataPoints = validData.length;
                        modelPerformance.set(symbol, perf);
                    }

                    // Send progress updates every 5 models
                    if (trainedCount % 5 === 0) {
                        await bot.sendMessage(
                            chatId,
                            `Progress: ${trainedCount}/${symbolsToTrain.length} models trained`
                        );
                    }
                } else {
                    failedCount++;
                }

                // Add a small delay between training sessions
                await new Promise(resolve => setTimeout(resolve, 5000));
            } catch (error) {
                log(`Error training model for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        // Save updated model performance data
        saveTrainingData();

        await bot.sendMessage(
            chatId,
            `ðŸ§  *ML Training Complete*\n\n` +
            `âœ… Successfully trained: ${trainedCount} models\n` +
            `âŒ Failed: ${failedCount} models\n\n` +
            `Use /mlstatus to check model performance.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in trainAllModels: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error training models: ${error.message}`);
    }
}

// Enhanced Telegram alert with ML confidence
async function sendTelegramAlertWithML(symbol, crossType, price, ema, difference, prediction) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Format ML prediction with confidence emoji
        let confidenceEmoji = 'âš ï¸'; // Neutral/uncertain
        if (Math.abs(prediction) > 3) {
            confidenceEmoji = prediction > 0 ? 'ðŸ”¥' : 'â„ï¸'; // Strong signal
        } else if (Math.abs(prediction) > 1) {
            confidenceEmoji = prediction > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰'; // Moderate signal
        }

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n` +
            `*ML Prediction:* ${confidenceEmoji} ${prediction.toFixed(2)}% (24h)\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, ML Prediction: ${prediction.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`ML-enhanced Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending ML-enhanced Telegram message: ${error.message}`, 'error');

        // Fall back to regular alert
        sendTelegramAlert(symbol, crossType, price, ema, difference);
    }
}

// Command handler
function handleMessage(msg) {
    const chatId = msg.chat.id;

    if (msg.text === '/start' || msg.text === '/menu') {
        sendMainMenu(chatId);
    } else if (msg.text === '/status') {
        sendStatusUpdate(chatId);
    } else if (msg.text === '/settings') {
        sendSettingsMenu(chatId);
    } else if (msg.text === '/help') {
        sendHelpMessage(chatId);
    } else if (msg.text === '/top') {
        sendTopPerformers(chatId);
    } else if (msg.text === '/refresh') {
        refreshWebSockets(chatId);
    } else if (msg.text === '/mlstatus') {
        sendModelPerformance(chatId);
    } else if (msg.text === '/train') {
        trainAllModels(chatId);
    } else if (msg.text === '/collectdata') {
        startManualDataCollection(chatId);
    } else if (msg.text === '/exportcsv') {
        exportAllDataToCSV();
        bot.sendMessage(chatId, 'ðŸ“Š All training data exported to CSV format successfully!');
    }
}

// Function to manually collect data for all tracked pairs
async function startManualDataCollection(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ“Š Starting manual data collection for all tracked pairs...');

        const pairs = await getFuturesPairs();
        if (pairs.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No pairs are currently being tracked.');
            return;
        }

        await bot.sendMessage(chatId, `Collecting data for ${pairs.length} pairs...`);

        let successCount = 0;
        let failedCount = 0;

        for (const symbol of pairs) {
            try {
                // Get historical klines
                const klines = await getKlines(symbol);
                if (klines.length < 30) {
                    log(`Skipping ${symbol}: Not enough candles`, 'warning');
                    failedCount++;
                    continue;
                }

                // Process each candle
                for (let i = 0; i < klines.length; i++) {
                    // Skip very old candles
                    if (i < klines.length - 100) continue;

                    const candle = klines[i];

                    // Create kline object in the format expected by processClosedCandle
                    const klineObj = {
                        t: candle.time,
                        o: candle.open.toString(),
                        h: candle.high.toString(),
                        l: candle.low.toString(),
                        c: candle.close.toString(),
                        v: candle.volume.toString()
                    };

                    // Process this candle
                    await processClosedCandle(symbol, klineObj);
                }

                successCount++;

                // Send progress updates
                if ((successCount + failedCount) % 10 === 0) {
                    await bot.sendMessage(
                        chatId,
                        `Progress: ${successCount + failedCount}/${pairs.length} pairs processed`
                    );
                }

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                log(`Error collecting data for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        // Save all collected data
        saveTrainingData();

        // Export to CSV
        exportAllDataToCSV();

        // Send completion message
        await bot.sendMessage(
            chatId,
            `ðŸ“Š *Data Collection Complete*\n\n` +
            `âœ… Successfully collected data for ${successCount} pairs\n` +
            `âŒ Failed: ${failedCount} pairs\n\n` +
            `Future price changes will be updated in 24 hours.\n` +
            `Data has been exported to CSV format for easier analysis.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in manual data collection: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error during data collection: ${error.message}`);
    }
}

// Refresh WebSockets command
async function refreshWebSockets(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ”„ Refreshing WebSocket connections...');

        // Close all existing WebSockets
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
            } catch (e) {
                // Ignore errors when closing
            }
            activeWebSockets.delete(symbol);
        }

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        await bot.sendMessage(chatId, 'âœ… WebSocket connections refreshed successfully!');
    } catch (error) {
        log(`Error refreshing WebSockets: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error refreshing WebSockets: ${error.message}`);
    }
}

// Callback query handler for inline buttons
async function handleCallbackQuery(callbackQuery) {
    const action = callbackQuery.data;
    const chatId = callbackQuery.message.chat.id;

    try {
        if (action === 'status') {
            await sendStatusUpdate(chatId);
        } else if (action === 'settings') {
            await sendSettingsMenu(chatId);
        } else if (action === 'top_gainers') {
            await sendTopPerformers(chatId, 'gainers');
        } else if (action === 'top_losers') {
            await sendTopPerformers(chatId, 'losers');
        } else if (action === 'top_volume') {
            await sendTopPerformers(chatId, 'volume');
        } else if (action === 'menu') {
            await sendMainMenu(chatId);
        } else if (action === 'help') {
            await sendHelpMessage(chatId);
        } else if (action === 'refresh_ws') {
            await refreshWebSockets(chatId);
        } else if (action === 'export_csv') {
            exportAllDataToCSV();
            await bot.sendMessage(chatId, 'ðŸ“Š All training data exported to CSV format successfully!');
        } else if (action.startsWith('timeframe_')) {
            const newTimeframe = action.replace('timeframe_', '');
            // Update the timeframe
            TIMEFRAME = newTimeframe;
            log(`Timeframe updated to ${newTimeframe}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new timeframe
            await bot.sendMessage(chatId, `âœ… Timeframe updated to ${newTimeframe}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('ema_')) {
            const newEma = parseInt(action.replace('ema_', ''), 10);
            // Update the EMA period
            EMA_PERIOD = newEma;
            log(`EMA period updated to ${newEma}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new EMA period
            await bot.sendMessage(chatId, `âœ… EMA period updated to ${newEma}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('volume_')) {
            const newVolume = parseInt(action.replace('volume_', ''), 10);
            // Update the volume threshold
            VOLUME_THRESHOLD = newVolume;
            log(`Volume threshold updated to ${newVolume}`, 'success');
            saveSettings();

            // Refresh tracked pairs based on new volume threshold
            await bot.sendMessage(chatId, `âœ… Volume threshold updated to ${formatVolume(newVolume)}. Refreshing tracked pairs...`);
            await setupAllWebSockets();

            await sendSettingsMenu(chatId);
        } else if (action === 'ml_status') {
            await sendModelPerformance(chatId);
        } else if (action === 'train_models') {
            await trainAllModels(chatId);
        } else if (action === 'toggle_ml') {
            ML_ENABLED = !ML_ENABLED;
            saveSettings();
            await bot.sendMessage(
                chatId,
                `ðŸ§  Machine Learning is now ${ML_ENABLED ? 'enabled' : 'disabled'}`
            );
            await sendSettingsMenu(chatId);
        }

        // Answer callback query to remove loading state
        await bot.answerCallbackQuery(callbackQuery.id);
    } catch (error) {
        log(`Error handling callback query: ${error.message}`, 'error');
        await bot.answerCallbackQuery(callbackQuery.id, { text: 'An error occurred' });
    }
}

// Add this function to save settings to a file
function saveSettings() {
    try {
        const settings = {
            EMA_PERIOD,
            TIMEFRAME,
            VOLUME_THRESHOLD,
            CHECK_INTERVAL,
            ALERT_COOLDOWN,
            ML_ENABLED
        };

        fs.writeFileSync(
            path.join(__dirname, 'settings.json'),
            JSON.stringify(settings, null, 2)
        );
        log('Settings saved to file', 'success');
    } catch (error) {
        log(`Error saving settings: ${error.message}`, 'error');
    }
}

// Add this function to load settings from file
function loadSettings() {
    try {
        const settingsPath = path.join(__dirname, 'settings.json');
        if (fs.existsSync(settingsPath)) {
            const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

            // Update variables with saved settings
            EMA_PERIOD = settings.EMA_PERIOD || EMA_PERIOD;
            TIMEFRAME = settings.TIMEFRAME || TIMEFRAME;
            VOLUME_THRESHOLD = settings.VOLUME_THRESHOLD || VOLUME_THRESHOLD;
            ML_ENABLED = settings.ML_ENABLED !== undefined ? settings.ML_ENABLED : ML_ENABLED;

            log('Settings loaded from file', 'success');
        }
    } catch (error) {
        log(`Error loading settings: ${error.message}`, 'error');
    }
}

// Send main menu with ML options
async function sendMainMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [{ text: 'ðŸ“Š Status', callback_data: 'status' }],
            [{ text: 'âš™ï¸ Settings', callback_data: 'settings' }],
            [
                { text: 'ðŸ“ˆ Top Gainers', callback_data: 'top_gainers' },
                { text: 'ðŸ“‰ Top Losers', callback_data: 'top_losers' }
            ],
            [{ text: 'ðŸ’° Highest Volume', callback_data: 'top_volume' }],
            [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
            [
                { text: 'ðŸ§  ML Status', callback_data: 'ml_status' },
                { text: 'ðŸ”¬ Train Models', callback_data: 'train_models' }
            ],
            [
                { text: 'ðŸ“Š Export CSV', callback_data: 'export_csv' },
                { text: 'â“ Help', callback_data: 'help' }
            ]
        ]
    };

    await bot.sendMessage(chatId, '*EMA Tracker Bot Menu*\nSelect an option:', {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send status update
async function sendStatusUpdate(chatId) {
    try {
        const pairs = await getFuturesPairs();
        const activeWsCount = Array.from(activeWebSockets.values())
            .filter(ws => ws.readyState === WebSocket.OPEN).length;

        const message = `*EMA Tracker Status*\n\n` +
            `*Active Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Monitoring: ${pairs.length} pairs\n` +
            `- Active WebSockets: ${activeWsCount}/${pairs.length}\n` +
            `- Machine Learning: ${ML_ENABLED ? 'Enabled âœ…' : 'Disabled âŒ'}\n` +
            `- Last Check: ${new Date().toLocaleString()}\n\n` +
            `Bot is actively monitoring for EMA crossovers in real-time.`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending status update: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching status');
    }
}

// Send settings menu with ML toggle
async function sendSettingsMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [
                { text: '1m', callback_data: 'timeframe_1m' },
                { text: '5m', callback_data: 'timeframe_5m' },
                { text: '15m', callback_data: 'timeframe_15m' },
                { text: '1h', callback_data: 'timeframe_1h' },
                { text: '4h', callback_data: 'timeframe_4h' }
            ],
            [
                { text: 'EMA 50', callback_data: 'ema_50' },
                { text: 'EMA 100', callback_data: 'ema_100' },
                { text: 'EMA 200', callback_data: 'ema_200' }
            ],
            [
                { text: 'Vol 50M', callback_data: 'volume_50000000' },
                { text: 'Vol 100M', callback_data: 'volume_100000000' },
                { text: 'Vol 200M', callback_data: 'volume_200000000' }
            ],
            [
                { text: `ML: ${ML_ENABLED ? 'Enabled âœ…' : 'Disabled âŒ'}`, callback_data: 'toggle_ml' }
            ],
            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
        ]
    };

    await bot.sendMessage(chatId, `*Settings*\n\nCurrent Configuration:\n- EMA: ${EMA_PERIOD}\n- Timeframe: ${TIMEFRAME}\n- Volume Threshold: ${formatVolume(VOLUME_THRESHOLD)}\n- Machine Learning: ${ML_ENABLED ? 'Enabled âœ…' : 'Disabled âŒ'}\n\nSelect a new setting:`, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send help message
async function sendHelpMessage(chatId) {
    const helpText = `*EMA Tracker Bot Help*\n\n` +
        `This bot monitors Binance Futures markets for EMA crossovers and sends alerts when they occur.\n\n` +
        `*Available Commands:*\n` +
        `/menu - Show the main menu\n` +
        `/status - Check bot status\n` +
        `/settings - Configure bot settings\n` +
        `/top - View top performing coins\n` +
        `/refresh - Refresh WebSocket connections\n` +
        `/mlstatus - Check ML model performance\n` +
        `/train - Train ML models manually\n` +
        `/collectdata - Manually collect training data\n` +
        `/exportcsv - Export data to CSV format\n` +
        `/help - Show this help message\n\n` +
        `*How It Works:*\n` +
        `The bot uses WebSockets to track price movements in real-time and detect when price crosses above or below the ${EMA_PERIOD} EMA on the ${TIMEFRAME} timeframe for high-volume coins.\n\n` +
        `*Machine Learning:*\n` +
        `When enabled, ML models predict future price movements after crossovers to enhance signal quality.`;

    await bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
        }
    });
}

// Send top performers (gainers, losers, or by volume)
async function sendTopPerformers(chatId, type = 'gainers') {
    try {
        await bot.sendMessage(chatId, 'â³ Fetching data...');

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        let coins = response.data.filter(coin => coin.symbol.endsWith('USDT'));

        // Sort based on type
        if (type === 'gainers') {
            coins.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 gainers
        } else if (type === 'losers') {
            coins.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 losers
        } else if (type === 'volume') {
            coins.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            coins = coins.slice(0, 10); // Top 10 by volume
        }

        let title;
        if (type === 'gainers') title = 'ðŸ“ˆ *Top Gainers (24h)*';
        else if (type === 'losers') title = 'ðŸ“‰ *Top Losers (24h)*';
        else title = 'ðŸ’° *Highest Volume (24h)*';

        let message = `${title}\n\n`;

        coins.forEach((coin, index) => {
            const symbol = coin.symbol;
            const price = formatPrice(parseFloat(coin.lastPrice));
            const change = parseFloat(coin.priceChangePercent).toFixed(2);
            const volume = formatVolume(parseFloat(coin.quoteVolume));

            const changeEmoji = parseFloat(change) >= 0 ? 'ðŸŸ¢' : 'ðŸ”´';
            message += `${index + 1}. ${symbol}: ${price} (${changeEmoji} ${change}%) - Vol: ${volume}\n`;
        });

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“ˆ Gainers', callback_data: 'top_gainers' },
                        { text: 'ðŸ“‰ Losers', callback_data: 'top_losers' },
                        { text: 'ðŸ’° Volume', callback_data: 'top_volume' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error fetching top performers: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching data');
    }
}

// Add a command to check model performance
async function sendModelPerformance(chatId) {
    try {
        if (modelPerformance.size === 0) {
            await bot.sendMessage(chatId, 'âŒ No model performance data available yet.');
            return;
        }

        let message = '*ML Model Performance*\n\n';

        // Sort symbols by accuracy
        const sortedSymbols = Array.from(modelPerformance.keys())
            .sort((a, b) => {
                const aMetrics = modelPerformance.get(a);
                const bMetrics = modelPerformance.get(b);
                return (bMetrics.accuracy || 0) - (aMetrics.accuracy || 0);
            })
            .slice(0, 10); // Top 10 performing models

        for (const symbol of sortedSymbols) {
            const metrics = modelPerformance.get(symbol);
            if (!metrics || metrics.predictions < 10) continue; // Skip models with few predictions

            message += `*${symbol}*\n` +
                `- Overall Accuracy: ${((metrics.accuracy || 0) * 100).toFixed(2)}%\n` +
                `- Total Predictions: ${metrics.predictions || 0}\n` +
                `- Data Points: ${metrics.dataPoints || 0}\n` +
                `- Last Trained: ${metrics.lastTraining ? new Date(metrics.lastTraining).toLocaleString() : 'Unknown'}\n\n`;
        }

        // Add summary statistics
        const totalModels = modelPerformance.size;
        const totalPredictions = Array.from(modelPerformance.values())
            .reduce((sum, metrics) => sum + (metrics.predictions || 0), 0);
        const avgAccuracy = Array.from(modelPerformance.values())
            .filter(metrics => metrics.predictions >= 10)
            .reduce((sum, metrics) => sum + (metrics.accuracy || 0), 0) /
            Array.from(modelPerformance.values()).filter(metrics => metrics.predictions >= 10).length;

        message += `*Summary Statistics*\n` +
            `- Total Models: ${totalModels}\n` +
            `- Total Predictions: ${totalPredictions}\n` +
            `- Average Accuracy: ${(avgAccuracy * 100).toFixed(2)}%\n\n` +
            `Use /train to train all models or /collectdata to gather more training data.`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ§  Train Models', callback_data: 'train_models' },
                        { text: 'ðŸ“Š Export Data', callback_data: 'export_csv' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending model performance: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching model performance data');
    }
}

// Send initial startup message to Telegram
async function sendStartupMessage() {
    try {
        const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
            `*Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Check Interval: ${(CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
            `- Alert Cooldown: ${(ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n` +
            `- WebSocket Monitoring: Enabled\n` +
            `- ML Enhancement: ${ML_ENABLED ? 'Enabled' : 'Disabled'}\n\n` +
            `Bot is now monitoring for EMA crossovers in real-time${ML_ENABLED ? ' with ML predictions' : ''}...`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
        log('Startup message sent to Telegram', 'success');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Started',
            `Monitoring ${TIMEFRAME} timeframe with ${EMA_PERIOD} EMA in real-time`,
            'info'
        );

        // Send the menu after startup message
        await sendMainMenu(TELEGRAM_CHAT_ID);
    } catch (error) {
        log(`Error sending startup message: ${error.message}`, 'error');
    }
}

// WebSocket heartbeat function to keep connections alive
function startWebSocketHeartbeat() {
    // Check WebSocket connections every minute
    setInterval(() => {
        try {
            let reconnected = 0;

            for (const [symbol, ws] of activeWebSockets.entries()) {
                // If WebSocket is closed or closing, reconnect
                if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    // Only log to file, not to console
                    fs.appendFileSync(
                        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                        `[${new Date().toISOString()}] WebSocket for ${symbol} is closed or closing. Reconnecting...\n`
                    );
                    setupSymbolWebSocket(symbol);
                    reconnected++;
                }
            }

            if (reconnected > 0) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Reconnected ${reconnected} WebSocket connections during heartbeat check\n`
                );
            }
        } catch (error) {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error in WebSocket heartbeat: ${error.message}\n`
            );
        }
    }, 60000); // Check every minute
}

// Schedule periodic model training
function scheduleModelTraining() {
    // Train models every 12 hours
    setInterval(async () => {
        if (!ML_ENABLED) {
            log('Scheduled model training skipped - ML is disabled', 'info');
            return;
        }

        log('Starting scheduled model training...', 'info');

        try {
            // Get all symbols with sufficient data
            const symbolsToTrain = Array.from(trainingData.keys())
                .filter(symbol => {
                    const data = trainingData.get(symbol);
                    // Only use data points with future price change values
                    const validData = data.filter(d => d.future_price_change !== null);
                    return validData.length >= 100;
                });

            if (symbolsToTrain.length === 0) {
                log('No symbols have enough data for training yet.', 'warning');
                return;
            }

            log(`Training models for ${symbolsToTrain.length} symbols`, 'info');

            let trainedCount = 0;
            let failedCount = 0;

            // Train models sequentially to avoid memory issues
            for (const symbol of symbolsToTrain) {
                try {
                    const { trainModelForSymbol } = require('./ml_model');

                    // Filter data to only include points with future price change
                    const allData = trainingData.get(symbol);
                    const validData = allData.filter(d => d.future_price_change !== null);

                    if (validData.length < 100) {
                        log(`Not enough valid data points for ${symbol}: ${validData.length}`, 'warning');
                        failedCount++;
                        continue;
                    }

                    const result = await trainModelForSymbol(symbol);

                    if (result) {
                        trainedCount++;

                        // Update model performance tracking
                        if (!modelPerformance.has(symbol)) {
                            modelPerformance.set(symbol, {
                                predictions: 0,
                                correctPredictions: 0,
                                accuracy: 0,
                                lastTraining: new Date().toISOString(),
                                dataPoints: validData.length
                            });
                        } else {
                            const perf = modelPerformance.get(symbol);
                            perf.lastTraining = new Date().toISOString();
                            perf.dataPoints = validData.length;
                            modelPerformance.set(symbol, perf);
                        }
                    } else {
                        failedCount++;
                    }

                    // Add a small delay between training sessions
                    await new Promise(resolve => setTimeout(resolve, 5000));
                } catch (error) {
                    log(`Error training model for ${symbol}: ${error.message}`, 'error');
                    failedCount++;
                }
            }

            // Save updated model performance data
            saveTrainingData();

            log(`Scheduled training completed. Trained ${trainedCount}/${symbolsToTrain.length} models.`, 'success');

            // Send notification about training completion
            if (trainedCount > 0) {
                await bot.sendMessage(
                    TELEGRAM_CHAT_ID,
                    `ðŸ§  *ML Model Training Completed*\n\n` +
                    `Successfully trained ${trainedCount} models.\n` +
                    `These models will now be used to enhance crossover alerts with price predictions.`,
                    { parse_mode: 'Markdown' }
                );
            }
        } catch (error) {
            log(`Error in scheduled model training: ${error.message}`, 'error');
        }
    }, 12 * 60 * 60 * 1000); // 12 hours
}

// Set up message and callback query handlers
bot.on('message', handleMessage);
bot.on('callback_query', handleCallbackQuery);

// Handle process termination gracefully
process.on('SIGINT', async () => {
    try {
        log('Received SIGINT. Shutting down gracefully...', 'warning');
        // Close all WebSocket connections
        for (const [symbol, ws] of activeWebSockets.entries()) {
                try {
                    ws.close();
                    log(`Closed WebSocket for ${symbol}`, 'info');
                } catch (e) {
                    // Ignore errors when closing
                }
            }

        await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Shutting Down',
            'The bot is shutting down gracefully',
            'warning'
        );

        process.exit(0);
    } catch (error) {
        log(`Error during shutdown: ${error.message}`, 'error');
        process.exit(1);
    }
});

// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');

    // Show desktop notification for unhandled rejection
    showDesktopNotification(
        'Error in EMA Tracker',
        'An unhandled rejection occurred. Check logs for details.',
        'error'
    );
});

// Install required packages if not already installed
async function installRequiredPackages() {
    const { exec } = require('child_process');
    const requiredPackages = ['ws', 'csv-writer']; // Added csv-writer package

    for (const pkg of requiredPackages) {
        try {
            require.resolve(pkg);
            log(`Package ${pkg} is already installed`, 'info');
        } catch (e) {
            log(`Installing required package: ${pkg}...`, 'info');

            try {
                await new Promise((resolve, reject) => {
                    exec(`npm install ${pkg}`, (error, stdout, stderr) => {
                        if (error) {
                            log(`Error installing ${pkg}: ${error.message}`, 'error');
                            reject(error);
                            return;
                        }
                        log(`Successfully installed ${pkg}`, 'success');
                        resolve();
                    });
                });
            } catch (error) {
                log(`Failed to install ${pkg}: ${error.message}`, 'error');
                throw error;
            }
        }
    }
}

// Calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) {
        return null;
    }

    const trueRanges = [];

    // Calculate True Range for each candle
    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        // True Range is the greatest of:
        // 1. Current High - Current Low
        // 2. |Current High - Previous Close|
        // 3. |Current Low - Previous Close|
        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        const trueRange = Math.max(tr1, tr2, tr3);
        trueRanges.push(trueRange);
    }

    // Calculate ATR as the average of the last 'period' true ranges
    const atr = trueRanges.slice(-period).reduce((sum, tr) => sum + tr, 0) / period;

    return atr;
}

// Initialize the terminal and start monitoring
async function initialize() {
    try {
        // Install required packages
        await installRequiredPackages();

        // Initialize terminal and load settings
        initializeTerminal();
        loadSettings();

        console.log('\nStarting initial check...'.green);

        // Initialize ML components
        console.log('Initializing machine learning components...'.cyan);

        // Create models directory if it doesn't exist
        const modelsDir = path.join(__dirname, 'models');
        if (!fs.existsSync(modelsDir)) {
            fs.mkdirSync(modelsDir);
        }

        // Create ML data directory if it doesn't exist
        if (!fs.existsSync(ML_DATA_DIR)) {
            fs.mkdirSync(ML_DATA_DIR, { recursive: true });
        }

        // Check if TensorFlow.js is available
        ML_ENABLED = checkTensorFlowAvailability() && ML_ENABLED;

        // Load ML training data if ML is enabled
        if (ML_ENABLED) {
            loadTrainingData();
        }

        // Send startup message
        await sendStartupMessage();

        // Do initial check to populate data
        await checkEMACross();

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        // Start WebSocket heartbeat
        startWebSocketHeartbeat();

        // Schedule model training if ML is enabled
        if (ML_ENABLED) {
            scheduleModelTraining();
        }

        // Schedule periodic saving of training data
        setInterval(saveTrainingData, 30 * 60 * 1000); // Save every 30 minutes

        // Now set flag to enable volume threshold notifications for subsequent checks
        initialLoadComplete = true;
        log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');

        // Run the check at the specified interval as a backup
        // This is in addition to the real-time WebSocket monitoring
        monitoringInterval = setInterval(async () => {
            log('Running periodic check as backup to WebSockets...', 'info');
            await checkEMACross();
        }, CHECK_INTERVAL);

        log(`Initialization complete. Bot is now monitoring in real-time via WebSockets${ML_ENABLED ? ' with ML enhancement' : ''}.`, 'success');
    } catch (error) {
        log(`Failed to initialize: ${error.message}`, 'error');

        // Show desktop notification for startup failure
        showDesktopNotification(
            'EMA Tracker Failed to Start',
            `Error: ${error.message}`,
            'error'
        );

        // Try to send error message to Telegram
        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, `âŒ *Error Starting Bot*\n\n${error.message}`, {
                parse_mode: 'Markdown'
            });
        } catch (e) {
            log(`Could not send error message to Telegram: ${e.message}`, 'error');
        }
    }
}

// Start the bot
initialize();
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const axios = require('axios');
const colors = require('colors');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');
const WebSocket = require('ws');
const { createObjectCsvWriter } = require('csv-writer');
//const brainML = require('./ml_alternative');

let initialLoadComplete = false;
// ML configuration
let ML_ENABLED = true;

// Configuration (Consider externalizing these variables or using environment variables)
let EMA_PERIOD = parseInt(process.env.EMA_PERIOD, 10) || 200;
let TIMEFRAME = process.env.TIMEFRAME || '15m';
let VOLUME_THRESHOLD = parseInt(process.env.VOLUME_THRESHOLD, 10) || 100_000_000;
const CHECK_INTERVAL = parseInt(process.env.CHECK_INTERVAL, 10) || 5 * 60 * 1000; // 5 minutes
const ALERT_COOLDOWN = parseInt(process.env.ALERT_COOLDOWN, 10) || 15 * 60 * 1000; // 15 minutes cooldown for alerts

// Telegram configuration with your provided credentials
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Store last alert times and states for each symbol
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring

// WebSocket related variables
const activeWebSockets = new Map(); // Track active WebSocket connections
const klineCache = new Map(); // Cache for kline data
const emaCache = new Map(); // Cache for calculated EMAs
const trainingData = new Map(); // Store historical data for ML training
// Track model performance
const modelPerformance = new Map();

// ML directories
const ML_DATA_DIR = path.join(__dirname, 'ml_data');
const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
const MODEL_PATH = path.join(__dirname, 'ml_models');

// Create a log directory for persistent logging
const LOG_DIR = path.join(__dirname, 'logs');
if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR);
}

// Create ML directories
if (!fs.existsSync(ML_DATA_DIR)) {
    fs.mkdirSync(ML_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(CSV_DATA_DIR)) {
    fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(MODEL_PATH)) {
    fs.mkdirSync(MODEL_PATH, { recursive: true });
}

// Log function that writes to both console and file
function log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;

    // Console logging with colors
    switch (type) {
        case 'error':
            console.error(logMessage.red);
            break;
        case 'success':
            console.log(logMessage.green);
            break;
        case 'warning':
            console.log(logMessage.yellow);
            break;
        default:
            console.log(logMessage);
    }

    // File logging
    const logFile = path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logMessage + '\n');
}

// Check if Brain.js is available
function checkMLAvailability() {
    try {
        require('brain.js');
        log('Brain.js is available for ML predictions', 'success');
        return true;
    } catch (e) {
        try {
            // Try to install brain.js
            log('Brain.js not found, attempting to install...', 'warning');
            require('child_process').execSync('npm install brain.js csv-writer --save');
            log('Brain.js installed successfully', 'success');
            return true;
        } catch (installError) {
            log(`Failed to install Brain.js: ${installError.message}`, 'error');
            log('ML predictions will be disabled', 'warning');
            return false;
        }
    }
}

// Show desktop notification using node-notifier
function showDesktopNotification(title, message, type = 'info') {
    try {
        notifier.notify({
            title: title,
            message: message,
            sound: true,
            wait: true,
            icon: path.join(__dirname, type === 'error' ? 'error.png' :
                type === 'warning' ? 'warning.png' : 'info.png')
        });

        log(`Desktop notification shown: ${title} - ${message}`);
    } catch (error) {
        log(`Failed to show desktop notification: ${error.message}`, 'error');
    }
}

// Initialize terminal
function initializeTerminal() {
    console.clear();
    console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);
    console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
    console.log(`Configuration: ${EMA_PERIOD} EMA | ${TIMEFRAME} Timeframe | Volume > ${VOLUME_THRESHOLD.toLocaleString()}`.cyan);
    console.log(`Alert Cooldown: ${ALERT_COOLDOWN / 60000} minutes`.magenta);
    console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
    console.log(`WebSocket Real-Time Monitoring: Enabled`.green);
    console.log(`Machine Learning: ${ML_ENABLED ? 'Enabled'.green : 'Disabled'.red}`);
    console.log('='.repeat(80).dim);
    console.log('\nCROSSOVER EVENTS:'.cyan.bold);

    log(`EMA Tracker started with configuration: EMA=${EMA_PERIOD}, Timeframe=${TIMEFRAME}, Volume Threshold=${VOLUME_THRESHOLD}, ML=${ML_ENABLED}`);
}

// Helper function to format volume
function formatVolume(volume) {
    if (volume >= 1_000_000_000) {
        return (volume / 1_000_000_000).toFixed(2) + 'B';
    } else if (volume >= 1_000_000) {
        return (volume / 1_000_000).toFixed(2) + 'M';
    } else if (volume >= 1_000) {
        return (volume / 1_000).toFixed(2) + 'K';
    }
    return volume.toFixed(2);
}

// Format price with appropriate precision based on value
function formatPrice(price) {
    if (price < 0.001) return price.toFixed(8);
    if (price < 1) return price.toFixed(6);
    if (price < 100) return price.toFixed(4);
    return price.toFixed(2);
}

// Function to get 24hr stats for a symbol
async function get24HrStats(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            params: { symbol }
        });
        return {
            priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
            quoteVolume: parseFloat(response.data.quoteVolume)
        };
    } catch (error) {
        log(`Error fetching 24hr stats for ${symbol}: ${error.message}`, 'error');
        return { priceChangePercent: '0.00', quoteVolume: '0' };
    }
}

// Fetch Binance Futures pairs with 24hr quote volume above the threshold
async function getFuturesPairs() {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        const newPairs = [];

        const pairs = response.data
            .filter(pair => {
                const volume = parseFloat(pair.quoteVolume);
                const symbol = pair.symbol;

                if (volume > VOLUME_THRESHOLD) {
                    // Only track new pairs that cross threshold after initial load
                    if (initialLoadComplete && !trackedPairs.has(symbol)) {
                        newPairs.push({
                            symbol,
                            volume,
                            price: parseFloat(pair.lastPrice),
                            change: parseFloat(pair.priceChangePercent)
                        });
                    }
                    trackedPairs.add(symbol);
                    return true;
                }
                return false;
            })
            .map(pair => pair.symbol);

        // Alert for new pairs that crossed the volume threshold (only after initial load)
        if (newPairs.length > 0) {
            alertNewHighVolumePairs(newPairs);
        }

        return pairs;
    } catch (error) {
        log(`Error fetching futures pairs: ${error.message}`, 'error');
        return [];
    }
}

// Alert when new pairs cross the volume threshold
async function alertNewHighVolumePairs(newPairs) {
    for (const pair of newPairs) {
        const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
            `*Symbol:* ${pair.symbol}\n` +
            `*Volume:* ${formatVolume(pair.volume)}\n` +
            `*Price:* ${formatPrice(pair.price)}\n` +
            `*24h Change:* ${pair.change.toFixed(2)}%\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `This pair has been added to the monitoring list.`;

        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

            // Show desktop notification
            showDesktopNotification(
                'New High Volume Pair',
                `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
                'info'
            );

            log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');

            // Setup WebSocket for the new pair
            setupSymbolWebSocket(pair.symbol);
        } catch (error) {
            log(`Error sending new pair alert for ${pair.symbol}: ${error.message}`, 'error');
        }
    }
}

// Retrieve historical candlestick data for the given symbol
async function getKlines(symbol) {
    try {
        const limit = EMA_PERIOD + 100; // Request extra candles to be safe

        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: { symbol, interval: TIMEFRAME, limit: limit }
        });

        const klines = response.data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));

        // Update the kline cache
        klineCache.set(symbol, klines);

        // Calculate and cache EMA
        const closes = klines.map(k => k.close);
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        if (klines.length < EMA_PERIOD) {
            log(`Warning: Not enough candles for ${symbol}. Needed ${EMA_PERIOD}, got ${klines.length}`, 'warning');
        }

        return klines;
    } catch (error) {
        log(`Error fetching klines for ${symbol}: ${error.message}`, 'error');
        return [];
    }
}

// Calculate the EMA for an array of prices given a period
function calculateEMA(prices, period) {
    if (prices.length < period) {
        log(`Warning: Not enough prices for EMA calculation. Needed ${period}, got ${prices.length}`, 'warning');
        return [];
    }

    const k = 2 / (period + 1);
    let emaArray = [];

    // Start with the simple moving average as the first EMA
    let sma = prices.slice(0, period).reduce((sum, p) => sum + p, 0) / period;
    let ema = sma;

    // Add the first EMA (which is the SMA)
    emaArray.push(ema);

    // Calculate EMA for the remaining prices
    for (let i = period; i < prices.length; i++) {
        ema = (prices[i] - ema) * k + ema;
        emaArray.push(ema);
    }

    return emaArray;
}

// Update EMA with a new price (for real-time updates)
function updateEMA(symbol, newPrice) {
    // Get cached EMA values
    let emaValues = emaCache.get(symbol);

    // If no cached values, we need to fetch historical data first
    if (!emaValues || emaValues.length === 0) {
        log(`No cached EMA values for ${symbol}, fetching historical data...`, 'warning');
        return false;
    }

    const k = 2 / (EMA_PERIOD + 1);
    const lastEMA = emaValues[emaValues.length - 1];
    const newEMA = (newPrice - lastEMA) * k + lastEMA;

    // Add the new EMA to the cache
    emaValues.push(newEMA);

    // Keep the cache size reasonable by removing older values
    if (emaValues.length > EMA_PERIOD * 2) {
        emaValues = emaValues.slice(-EMA_PERIOD * 2);
    }

    emaCache.set(symbol, emaValues);
    return true;
}

// Send Telegram notification with enhanced formatting
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending Telegram message: ${error.message}`, 'error');

        // Retry with simpler message if parse_mode might be the issue
        try {
            const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
            await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
            log(`Sent simplified alert for ${symbol} after error`, 'warning');
        } catch (retryError) {
            log(`Failed to send even simplified message: ${retryError.message}`, 'error');
        }
    }
}

// Check if we should alert for this symbol based on direction change and cooldown
function shouldAlert(symbol, currentState) {
    const now = Date.now();
    const previousState = coinStates.get(symbol);
    const lastAlertTime = lastAlerts.get(symbol) || 0;

    if (previousState !== currentState) {
        coinStates.set(symbol, currentState);
        if (now - lastAlertTime >= ALERT_COOLDOWN) {
            lastAlerts.set(symbol, now);
            return true;
        } else {
            log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
        }
    }
    return false; // No alert if state hasn't changed or cooldown active
}

// WebSocket setup for a symbol
function setupSymbolWebSocket(symbol) {
    // Close existing connection if any
    if (activeWebSockets.has(symbol)) {
        try {
            activeWebSockets.get(symbol).close();
        } catch (e) {
            // Ignore errors when closing
        }
    }

    // Create WebSocket URL based on timeframe
    const wsSymbol = symbol.toLowerCase();
    const wsUrl = `wss://fstream.binance.com/ws/${wsSymbol}@kline_${TIMEFRAME}`;

    // Only log to file, not to console
    fs.appendFileSync(
        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
        `[${new Date().toISOString()}] Setting up WebSocket for ${symbol} on ${TIMEFRAME} timeframe\n`
    );

    try {
        const ws = new WebSocket(wsUrl);

        ws.on('open', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection established for ${symbol}\n`
            );
        });

        ws.on('message', (data) => {
            try {
                const message = JSON.parse(data);

                // Process kline data
                if (message.e === 'kline') {
                    const kline = message.k;

                    // Only process if the candle is closed or if we want to process real-time
                    if (kline.x === true) { // Candle closed
                        processClosedCandle(symbol, kline);
                    } else {
                        // Process real-time candle updates without logging unconfirmed events
                        processRealtimeCandle(symbol, kline, false); // Added parameter to suppress logging
                    }
                }
            } catch (error) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Error processing WebSocket message for ${symbol}: ${error.message}\n`
                );
            }
        });

        ws.on('error', (error) => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket error for ${symbol}: ${error.message}\n`
            );
            // Try to reconnect after a delay
            setTimeout(() => setupSymbolWebSocket(symbol), 5000);
        });

        ws.on('close', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection closed for ${symbol}\n`
            );
            // Try to reconnect after a delay if it wasn't intentionally closed
            if (trackedPairs.has(symbol)) {
                setTimeout(() => setupSymbolWebSocket(symbol), 5000);
            }
        });

        // Store the WebSocket connection
        activeWebSockets.set(symbol, ws);

        // Initialize with historical data
        getKlines(symbol).then(() => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Historical data loaded for ${symbol}\n`
            );
        }).catch(error => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error loading historical data for ${symbol}: ${error.message}\n`
            );
        });

        return ws;
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSocket for ${symbol}: ${error.message}\n`
        );
        return null;
    }
}

// Calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) {
        return 0;
    }

    const trueRanges = [];

    // Calculate True Range for each candle
    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        // True Range is the greatest of:
        // 1. Current High - Current Low
        // 2. |Current High - Previous Close|
        // 3. |Current Low - Previous Close|
        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        const trueRange = Math.max(tr1, tr2, tr3);
        trueRanges.push(trueRange);
    }

    // Calculate ATR (simple average of true ranges)
    if (trueRanges.length < period) {
        return trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    }

    // Use the last 'period' true ranges
    const recentTrueRanges = trueRanges.slice(-period);
    return recentTrueRanges.reduce((sum, tr) => sum + tr, 0) / period;
}

// Collect data for ML training
async function collectDataForML(symbol, kline) {
    try {
        if (!ML_ENABLED) return;

        // Get cached klines
        const klines = klineCache.get(symbol) || [];
        if (klines.length < 30) return; // Need enough data for indicators

        // Get closes for indicators
        const closes = klines.map(k => k.close);
        const volumes = klines.map(k => k.volume);

        // Calculate indicators
        const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
        const rsi = calculateRSI(closes);
        const macd = calculateMACD(closes);
        const bb = calculateBollingerBands(closes);
        const atr = calculateATR(klines);

        // Create data point
        const dataPoint = {
            timestamp: kline.t,
            symbol: symbol,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v),
            ema: emaCache.get(symbol)[emaCache.get(symbol).length - 1],
            ema_diff: (parseFloat(kline.c) - emaCache.get(symbol)[emaCache.get(symbol).length - 1]) /
                emaCache.get(symbol)[emaCache.get(symbol).length - 1] * 100,
            rsi: rsi[rsi.length - 1],
            macd: macd.macd[macd.macd.length - 1],
            macd_signal: macd.signal[macd.signal.length - 1],
            macd_hist: macd.histogram[macd.histogram.length - 1],
            bb_upper: bb.upper[bb.upper.length - 1],
            bb_middle: bb.middle[bb.middle.length - 1],
            bb_lower: bb.lower[bb.lower.length - 1],
            bb_width: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) /
                bb.middle[bb.middle.length - 1],
            atr: atr,
            volume_change: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
            future_price_change: null, // To be filled later
            label: null // To be filled later
        };

        // Initialize training data array for this symbol if it doesn't exist
        if (!trainingData.has(symbol)) {
            trainingData.set(symbol, []);
        }

        // Add to training data
        trainingData.get(symbol).push(dataPoint);

        // Keep training data size manageable (last 1000 candles)
        if (trainingData.get(symbol).length > 1000) {
            trainingData.set(symbol, trainingData.get(symbol).slice(-1000));
        }

        // Schedule update of future price change (after 24 hours)
        setTimeout(() => updateFuturePriceChange(symbol, kline.t), 8 * 60 * 60 * 1000);
    } catch (error) {
        log(`Error collecting ML data for ${symbol}: ${error.message}`, 'error');
    }
}

// Process a closed candle from WebSocket
async function processClosedCandle(symbol, kline) {
    try {
        // Get cached klines or initialize if not exists
        let klines = klineCache.get(symbol) || [];

        // Create new kline object
        const newKline = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
        };

        // Add new kline to cache
        klines.push(newKline);

        // Keep cache size reasonable
        if (klines.length > EMA_PERIOD * 2) {
            klines = klines.slice(-EMA_PERIOD * 2);
        }

        klineCache.set(symbol, klines);

        // Get closes for EMA calculation
        const closes = klines.map(k => k.close);

        // Calculate new EMA values
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        // Collect data for ML training
        await collectDataForML(symbol, kline);

        // Check for crossover
        if (emaValues.length >= 2) {
            const lastPrice = closes[closes.length - 1];
            const prevPrice = closes[closes.length - 2];
            const lastEMA = emaValues[emaValues.length - 1];
            const prevEMA = emaValues[emaValues.length - 2];

            checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA);
        }
    } catch (error) {
        log(`Error processing closed candle for ${symbol}: ${error.message}`, 'error');
    }
}

// Process real-time candle updates
function processRealtimeCandle(symbol, kline, logUnconfirmed = true) {
    try {
        // Get cached klines
        const klines = klineCache.get(symbol);
        if (!klines || klines.length === 0) {
            return; // No historical data yet
        }

        // Get current price
        const currentPrice = parseFloat(kline.c);

        // Get cached EMA values
        const emaValues = emaCache.get(symbol);
        if (!emaValues || emaValues.length < 2) {
            return; // Not enough EMA values yet
        }

        // Get the last closed price and EMA
        const lastClosedPrice = klines[klines.length - 1].close;
        const lastEMA = emaValues[emaValues.length - 1];

        // Determine current state (above or below)
        // Determine current state (above or below EMA)
        const prevState = lastClosedPrice > lastEMA ? 'above' : 'below';
        const currentState = currentPrice > lastEMA ? 'above' : 'below';

        // If state changed, we have a potential real-time crossover
        if (prevState !== currentState) {
            // Calculate difference percentage
            const difference = (currentPrice - lastEMA) / lastEMA * 100;

            // Only log if explicitly requested (for debugging)
            if (logUnconfirmed) {
                // Log the potential crossover but don't send alert yet
                console.log('\n');
                const crossType = currentState === 'above' ? 'up' : 'down';
                const crossLabel = crossType === 'up' ?
                    'â–²'.yellow + ' POTENTIAL UPWARD CROSSOVER '.black.bgYellow :
                    'â–¼'.yellow + ' POTENTIAL DOWNWARD CROSSOVER '.black.bgYellow;

                console.log(crossLabel + ' ' + symbol.bold);
                console.log(`  Current Price: ${formatPrice(currentPrice)[crossType === 'up' ? 'green' : 'red']}`);
                console.log(`  EMA(${EMA_PERIOD}): ${formatPrice(lastEMA).cyan}`);
                console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);
                console.log(`  Status: ${'REAL-TIME (Unconfirmed)'.yellow}`);
            }

            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Potential ${currentState === 'above' ? 'upward' : 'downward'} crossover detected for ${symbol} (unconfirmed)\n`
            );
        }
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error processing real-time candle for ${symbol}: ${error.message}\n`
        );
    }
}

// Check for crossover and send alerts if needed
async function checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA) {
    try {
        // Determine current state (above or below EMA)
        const currentState = lastPrice > lastEMA ? 'above' : 'below';
        const difference = (lastPrice - lastEMA) / lastEMA * 100;

        // Get ML prediction if available, but handle errors gracefully
        let prediction = null;
        if (ML_ENABLED) {
            try {
                // Get additional technical indicators
                const klines = klineCache.get(symbol) || [];
                if (klines.length >= 30) {
                    const closes = klines.map(k => k.close);
                    const volumes = klines.map(k => k.volume || 0);

                    // Calculate indicators
                    const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
                    const rsi = calculateRSI(closes);
                    const macd = calculateMACD(closes);
                    const bb = calculateBollingerBands(closes);
                    const atr = calculateATR(klines);

                    // Prepare features for prediction
                    const features = {
                        priceDiff: difference,
                        rsi: rsi[rsi.length - 1],
                        macdHist: macd.histogram[macd.histogram.length - 1],
                        bbWidth: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.middle[bb.middle.length - 1],
                        volumeChange: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
                        atr: atr,
                        volume24h: volumes[volumes.length - 1]
                    };

                    // Get prediction using Brain.js
                    prediction = await brainML.predictPriceChange(symbol, features);

                    if (prediction !== null) {
                        console.log(`  ML Prediction: ${prediction.toFixed(2)}% expected change`.cyan);
                    }
                }
            } catch (predictionError) {
                log(`Error getting prediction for ${symbol}: ${predictionError.message}`, 'warning');
                // Continue without prediction
            }
        }

        // Upward crossover: price crossing from below to above EMA
        if (prevPrice < prevEMA && lastPrice > lastEMA) {
            console.log('\n');
            console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'up', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'up', lastPrice, lastEMA, difference);
                }
            }
        }
        // Downward crossover: price crossing from above to below EMA
        else if (prevPrice > prevEMA && lastPrice < lastEMA) {
            console.log('\n');
            console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'down', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'down', lastPrice, lastEMA, difference);
                }
            }
        } else {
            // Update state even if no crossover
            coinStates.set(symbol, currentState);
        }
    } catch (error) {
        log(`Error checking for crossover for ${symbol}: ${error.message}`, 'error');
    }
}

// Setup WebSockets for all tracked pairs
async function setupAllWebSockets() {
    try {
        const pairs = await getFuturesPairs();

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Setting up WebSockets for ${pairs.length} pairs\n`
        );

        // Close any existing WebSockets for pairs that are no longer tracked
        for (const [symbol, ws] of activeWebSockets.entries()) {
            if (!pairs.includes(symbol)) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Closing WebSocket for ${symbol} (no longer tracked)\n`
                );
                try {
                    ws.close();
                } catch (e) {
                    // Ignore errors when closing
                }
                activeWebSockets.delete(symbol);
            }
        }

        // Setup WebSockets for all tracked pairs
        for (const symbol of pairs) {
            if (!activeWebSockets.has(symbol) || activeWebSockets.get(symbol).readyState !== WebSocket.OPEN) {
                setupSymbolWebSocket(symbol);

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] WebSocket setup completed for ${pairs.length} pairs\n`
        );
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSockets: ${error.message}\n`
        );
    }
}

// Check for EMA crossovers (traditional method, still used for initial load and periodic checks)
async function checkEMACross() {
    try {
        const pairs = await getFuturesPairs();
        const timestamp = new Date().toLocaleString();

        console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
        process.stdout.write('Processing: '.cyan);

        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair =>
            getKlines(pair)
                .then(klines => ({ pair, klines, error: null }))
                .catch(error => ({ pair, klines: [], error }))
        );

        const results = await Promise.all(klinesPromises);

        for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');

            if (error || klines.length < EMA_PERIOD) {
                if (klines.length < EMA_PERIOD) {
                    log(`Skipping ${pair}: Not enough candles (${klines.length}/${EMA_PERIOD})`, 'warning');
                }
                continue;
            }

            const closes = klines.map(k => k.close);
            const ema = calculateEMA(closes, EMA_PERIOD);

            // Make sure we have enough EMA values
            if (ema.length < 2) {
                log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
                continue;
            }

            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];

            // Check for crossover
            checkForCrossover(pair, prevPrice, lastPrice, prevEMA, lastEMA);
        }

        console.log('\n');
        console.log(`Check completed at ${timestamp}. WebSockets are now monitoring in real-time.`.gray);
        console.log('='.repeat(80).dim);
    } catch (error) {
        log(`Error in checkEMACross: ${error.message}`, 'error');
        console.error('Stack trace:', error.stack);
    }
}

// Update future price change for training data
async function updateFuturePriceChange(symbol, timestamp) {
    try {
        if (!trainingData.has(symbol)) return;

        const data = trainingData.get(symbol);
        const dataPoint = data.find(d => d.timestamp === timestamp);

        if (!dataPoint) return;

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);
        const originalPrice = dataPoint.close;

        // Calculate price change percentage
        const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);

        // Update the data point
        Point.future_price_change = priceChange;
        Point.label = priceChange >= 0 ? 1 : 0;

        log(`Updated future price change for ${symbol}: ${priceChange.toFixed(2)}%`, 'info');

        // Save training data to disk periodically
        saveTrainingData();

        // Export updated data to CSV
        if (data.filter(d => d.future_price_change !== null).length % 50 === 0) {
            // Export to CSV every 50 completed data points
            await brainML.exportToCSV(symbol, data);
        }
    } catch (error) {
        log(`Error updating future price change: ${error.message}`, 'error');
    }
}

// Function to get current price
async function getCurrentPrice(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/price', {
            params: { symbol }
        });
        return parseFloat(response.data.price);
    } catch (error) {
        log(`Error getting current price for ${symbol}: ${error.message}`, 'error');
        throw error;
    }
}

// Save training data to disk
function saveTrainingData() {
    try {
        const dataDir = path.join(__dirname, 'data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir);
        }

        // Save each symbol's data to a separate file
        for (const [symbol, data] of trainingData.entries()) {
            fs.writeFileSync(
                path.join(dataDir, `${symbol}_training.json`),
                JSON.stringify(data)
            );

            // Export to CSV if we have enough data points with outcomes
            const completedData = data.filter(d => d.future_price_change !== null);
            if (completedData.length >= 50) {
                brainML.exportToCSV(symbol, data).catch(err => {
                    log(`Error exporting CSV for ${symbol}: ${err.message}`, 'error');
                });
            }
        }

        // Save model performance data
        fs.writeFileSync(
            path.join(dataDir, 'model_performance.json'),
            JSON.stringify(Array.from(modelPerformance.entries()))
        );

        log(`Saved training data for ${trainingData.size} symbols`, 'info');
    } catch (error) {
        log(`Error saving training data: ${error.message}`, 'error');
    }
}

// Add this to the initialize function
async function updateIncompleteDataPoints() {
    log('Checking for incomplete data points from previous sessions...', 'info');
    let updatedCount = 0;
    
    for (const [symbol, data] of trainingData.entries()) {
      const incompletePoints = data.filter(d => d.future_price_change === null);
      if (incompletePoints.length > 0) {
        log(`Found ${incompletePoints.length} incomplete data points for ${symbol}`, 'info');
        
        for (const point of incompletePoints) {
          try {
            const currentPrice = await getCurrentPrice(symbol);
            const originalPrice = point.close;
            const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);
            point.future_price_change = priceChange;
            point.label = priceChange >= 0 ? 1 : 0;
            updatedCount++;
          } catch (error) {
            log(`Error updating data point for ${symbol}: ${error.message}`, 'error');
          }
        }
      }
    }
    
    if (updatedCount > 0) {
      log(`Updated ${updatedCount} incomplete data points from previous sessions`, 'success');
      saveTrainingData();
    }
  }  

// Load training data from disk
function loadTrainingData() {
    try {
        const dataDir = path.join(__dirname, 'data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir);
            return;
        }

        // Load each symbol's data
        const files = fs.readdirSync(dataDir).filter(f => f.endsWith('_training.json'));

        for (const file of files) {
            try {
                const symbol = file.replace('_training.json', '');
                const data = JSON.parse(fs.readFileSync(path.join(dataDir, file), 'utf8'));
                trainingData.set(symbol, data);
                log(`Loaded ${data.length} training points for ${symbol}`, 'info');
            } catch (e) {
                log(`Error loading data for ${file}: ${e.message}`, 'warning');
            }
        }

        // Load model performance data
        const perfFile = path.join(dataDir, 'model_performance.json');
        if (fs.existsSync(perfFile)) {
            const perfData = JSON.parse(fs.readFileSync(perfFile, 'utf8'));
            for (const [symbol, data] of perfData) {
                modelPerformance.set(symbol, data);
            }
            log(`Loaded performance data for ${modelPerformance.size} models`, 'info');
        }
    } catch (error) {
        log(`Error loading training data: ${error.message}`, 'error');
    }
}

// Function to train all models
async function trainAllModels(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§  Starting Brain.js model training. This may take some time...');

        // Get all symbols with sufficient data
        const symbolsToTrain = Array.from(trainingData.keys())
            .filter(symbol => {
                const data = trainingData.get(symbol);
                const validData = data.filter(d => d.future_price_change !== null);
                return validData.length >= 100;
            });

        if (symbolsToTrain.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No symbols have enough data for training yet.');
            return;
        }

        await bot.sendMessage(chatId, `Training models for ${symbolsToTrain.length} symbols...`);

        let trainedCount = 0;
        let failedCount = 0;

        // Train models sequentially
        for (const symbol of symbolsToTrain) {
            try {
                // Export data to CSV first
                const data = trainingData.get(symbol);
                await brainML.exportToCSV(symbol, data);

                // Train model
                const result = await brainML.trainModelForSymbol(symbol);

                if (result) {
                    trainedCount++;

                    // Update model performance tracking
                    if (!modelPerformance.has(symbol)) {
                        modelPerformance.set(symbol, {
                            predictions: 0,
                            correctPredictions: 0,
                            directionAccuracy: 0,
                            mae: result.performance.mae || 0,
                            lastTraining: new Date().toISOString(),
                            dataPoints: data.filter(d => d.future_price_change !== null).length
                        });
                    } else {
                        const perf = modelPerformance.get(symbol);
                        perf.lastTraining = new Date().toISOString();
                        perf.dataPoints = data.filter(d => d.future_price_change !== null).length;
                        perf.mae = result.performance.mae || 0;
                        perf.directionAccuracy = result.performance.directionAccuracy || 0;
                        modelPerformance.set(symbol, perf);
                    }

                    // Send progress updates every 5 models
                    if (trainedCount % 5 === 0) {
                        await bot.sendMessage(
                            chatId,
                            `Progress: ${trainedCount}/${symbolsToTrain.length} models trained`
                        );
                    }
                } else {
                    failedCount++;
                }

                // Add a small delay between training sessions
                await new Promise(resolve => setTimeout(resolve, 5000));
            } catch (error) {
                log(`Error training model for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        await bot.sendMessage(
            chatId,
            `ðŸ§  *Brain.js ML Training Complete*\n\n` +
            `âœ… Successfully trained: ${trainedCount} models\n` +
            `âŒ Failed: ${failedCount} models\n\n` +
            `Use /mlstatus to check model performance.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in trainAllModels: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error training models: ${error.message}`);
    }
}

// Enhanced Telegram alert with ML prediction
async function sendTelegramAlertWithML(symbol, crossType, price, ema, difference, prediction) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Format ML prediction with confidence emoji
        let confidenceEmoji = 'âš ï¸'; // Neutral/uncertain
        if (Math.abs(prediction) > 3) {
            confidenceEmoji = prediction > 0 ? 'ðŸ”¥' : 'â„ï¸'; // Strong signal
        } else if (Math.abs(prediction) > 1) {
            confidenceEmoji = prediction > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰'; // Moderate signal
        }

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n` +
            `*Brain.js Prediction:* ${confidenceEmoji} ${prediction.toFixed(2)}% (24h)\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, ML Prediction: ${prediction.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`ML-enhanced Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending ML-enhanced Telegram message: ${error.message}`, 'error');

        // Fall back to regular alert
        sendTelegramAlert(symbol, crossType, price, ema, difference);
    }
}

// Function to manually collect data for all tracked pairs
async function startManualDataCollection(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ“Š Starting manual data collection for all tracked pairs...');

        const pairs = await getFuturesPairs();
        if (pairs.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No pairs are currently being tracked.');
            return;
        }

        await bot.sendMessage(chatId, `Collecting data for ${pairs.length} pairs...`);

        let successCount = 0;
        let failedCount = 0;

        for (const symbol of pairs) {
            try {
                // Get historical klines
                const klines = await getKlines(symbol);
                if (klines.length < 30) {
                    log(`Skipping ${symbol}: Not enough candles`, 'warning');
                    failedCount++;
                    continue;
                }

                // Process each candle
                for (let i = 0; i < klines.length; i++) {
                    // Skip very old candles
                    if (i < klines.length - 100) continue;

                    const candle = klines[i];

                    // Create kline object in the format expected by processClosedCandle
                    const klineObj = {
                        t: candle.time,
                        o: candle.open.toString(),
                        h: candle.high.toString(),
                        l: candle.low.toString(),
                        c: candle.close.toString(),
                        v: candle.volume.toString()
                    };

                    // Process this candle
                    await processClosedCandle(symbol, klineObj);
                }

                successCount++;

                // Send progress updates
                if ((successCount + failedCount) % 10 === 0) {
                    await bot.sendMessage(
                        chatId,
                        `Progress: ${successCount + failedCount}/${pairs.length} pairs processed`
                    );
                }

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                log(`Error collecting data for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        // Save all collected data
        saveTrainingData();

        // Send completion message
        await bot.sendMessage(
            chatId,
            `ðŸ“Š *Data Collection Complete*\n\n` +
            `âœ… Successfully collected data for ${successCount} pairs\n` +
            `âŒ Failed: ${failedCount} pairs\n\n` +
            `Future price changes will be updated in 24 hours.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in manual data collection: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error during data collection: ${error.message}`);
    }
}

// Export data to CSV
async function exportToCSV(symbol, data) {
    try {
        // Create directory for this symbol if it doesn't exist
        const symbolDir = path.join(CSV_DATA_DIR, symbol);
        if (!fs.existsSync(symbolDir)) {
            fs.mkdirSync(symbolDir, { recursive: true });
        }

        const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

        // Filter out data points without future price change
        const validData = data.filter(d => d.future_price_change !== null);

        if (validData.length === 0) {
            log(`No valid data points with outcomes for ${symbol}`, 'warning');
            return;
        }

        // Create CSV writer
        const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
                { id: 'timestamp', title: 'Timestamp' },
                { id: 'open', title: 'Open' },
                { id: 'high', title: 'High' },
                { id: 'low', title: 'Low' },
                { id: 'close', title: 'Close' },
                { id: 'volume', title: 'Volume' },
                { id: 'ema', title: 'EMA' },
                { id: 'ema_diff', title: 'EMA_Diff_Pct' },
                { id: 'rsi', title: 'RSI' },
                { id: 'macd', title: 'MACD' },
                { id: 'macd_signal', title: 'MACD_Signal' },
                { id: 'macd_hist', title: 'MACD_Hist' },
                { id: 'bb_width', title: 'BB_Width' },
                { id: 'atr', title: 'ATR' },
                { id: 'volume_change', title: 'Volume_Change' },
                { id: 'future_price_change', title: 'Future_Price_Change' }
            ]
        });

        // Write data to CSV
        await csvWriter.writeRecords(validData);

        log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
        return true;
    } catch (error) {
        log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error');
        return false;
    }
}

// Send model performance data
async function sendModelPerformance(chatId) {
    try {
        if (modelPerformance.size === 0) {
            await bot.sendMessage(chatId, 'âŒ No model performance data available yet.');
            return;
        }

        let message = '*Brain.js Model Performance*\n\n';

        // Sort symbols by direction accuracy
        const sortedSymbols = Array.from(modelPerformance.keys())
            .sort((a, b) => {
                const aMetrics = modelPerformance.get(a);
                const bMetrics = modelPerformance.get(b);
                return (bMetrics.directionAccuracy || 0) - (aMetrics.directionAccuracy || 0);
            })
            .slice(0, 10); // Top 10 performing models

        for (const symbol of sortedSymbols) {
            const metrics = modelPerformance.get(symbol);
            if (!metrics.dataPoints || metrics.dataPoints < 50) continue; // Skip models with few data points

            message += `*${symbol}*\n` +
                `- Direction Accuracy: ${((metrics.directionAccuracy || 0) * 100).toFixed(2)}%\n` +
                `- Mean Absolute Error: ${(metrics.mae || 0).toFixed(4)}\n` +
                `- Data Points: ${metrics.dataPoints}\n` +
                `- Last Trained: ${new Date(metrics.lastTraining).toLocaleString()}\n\n`;
        }

        // Add information about CSV data
        const csvSymbols = fs.existsSync(CSV_DATA_DIR) ?
            fs.readdirSync(CSV_DATA_DIR).filter(item => fs.statSync(path.join(CSV_DATA_DIR, item)).isDirectory()) : [];

        if (csvSymbols.length > 0) {
            message += `\n*CSV Training Data Available*\n`;
            message += `${csvSymbols.length} symbols have CSV data for visualization.\n`;
            message += `CSV files are stored in: ${CSV_DATA_DIR}\n\n`;
            message += `You can use these CSV files with external tools for data analysis.`;
        }

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Train All Models', callback_data: 'train_models' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending model performance: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching model performance data');
    }
}

// Command handler
function handleMessage(msg) {
    const chatId = msg.chat.id;

    if (msg.text === '/start' || msg.text === '/menu') {
        sendMainMenu(chatId);
    } else if (msg.text === '/status') {
        sendStatusUpdate(chatId);
    } else if (msg.text === '/settings') {
        sendSettingsMenu(chatId);
    } else if (msg.text === '/help') {
        sendHelpMessage(chatId);
    } else if (msg.text === '/top') {
        sendTopPerformers(chatId);
    } else if (msg.text === '/refresh') {
        refreshWebSockets(chatId);
    } else if (msg.text === '/mlstatus') {
        sendModelPerformance(chatId);
    } else if (msg.text === '/train') {
        trainAllModels(chatId);
    } else if (msg.text === '/collectdata') {
        startManualDataCollection(chatId);
    } else if (msg.text === '/listdata') {
        listAvailableCSVData(chatId);
    } else if (msg.text && msg.text.startsWith('/viewdata ')) {
        const symbol = msg.text.split(' ')[1].toUpperCase();
        viewSymbolCSVData(chatId, symbol);
    }
}

// List available CSV data
async function listAvailableCSVData(chatId) {
    try {
        if (!fs.existsSync(CSV_DATA_DIR)) {
            await bot.sendMessage(chatId, 'âŒ No CSV data directory found. Run data collection first.');
            return;
        }

        const symbols = fs.readdirSync(CSV_DATA_DIR)
            .filter(item => fs.statSync(path.join(CSV_DATA_DIR, item)).isDirectory());

        if (symbols.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No CSV data available yet. Run data collection first.');
            return;
        }

        // Get data points count for each symbol
        const symbolData = [];
        for (const symbol of symbols) {
            const csvPath = path.join(CSV_DATA_DIR, symbol, `${symbol}_training_data.csv`);
            if (fs.existsSync(csvPath)) {
                const stats = fs.statSync(csvPath);
                const fileSize = (stats.size / 1024).toFixed(2) + ' KB';

                // Count lines (data points) - simple approach
                const content = fs.readFileSync(csvPath, 'utf8');
                const lines = content.split('\n').length - 1; // -1 for header

                symbolData.push({
                    symbol,
                    dataPoints: lines,
                    fileSize
                });
            }
        }

        // Sort by data points (descending)
        symbolData.sort((a, b) => b.dataPoints - a.dataPoints);

        let message = '*Available CSV Training Data*\n\n';

        for (const data of symbolData) {
            message += `*${data.symbol}*: ${data.dataPoints} data points (${data.fileSize})\n`;
        }

        message += '\nUse /viewdata SYMBOL to get details about a specific symbol\'s data.';

        // Create inline keyboard with symbols
        const keyboard = [];
        const buttonsPerRow = 3;

        for (let i = 0; i < symbolData.length; i += buttonsPerRow) {
            const row = [];
            for (let j = 0; j < buttonsPerRow && i + j < symbolData.length; j++) {
                row.push({
                    text: symbolData[i + j].symbol,
                    callback_data: `viewdata_${symbolData[i + j].symbol}`
                });
            }
            keyboard.push(row);
        }

        keyboard.push([{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]);

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        log(`Error listing CSV data: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error listing CSV data: ${error.message}`);
    }
}

// View CSV data for a specific symbol
async function viewSymbolCSVData(chatId, symbol) {
    try {
        const csvPath = path.join(CSV_DATA_DIR, symbol, `${symbol}_training_data.csv`);

        if (!fs.existsSync(csvPath)) {
            await bot.sendMessage(chatId, `âŒ No CSV data found for ${symbol}`);
            return;
        }

        // Get file stats
        const stats = fs.statSync(csvPath);
        const fileSize = (stats.size / 1024).toFixed(2) + ' KB';
        const modifiedDate = new Date(stats.mtime).toLocaleString();

        // Count lines (data points)
        const content = fs.readFileSync(csvPath, 'utf8');
        const lines = content.split('\n');
        const dataPoints = lines.length - 1; // -1 for header

        // Get a preview of the data (first 5 rows)
        const preview = lines.slice(0, 6).join('\n');

        // Calculate some basic stats from the data
        const rows = content.split('\n').slice(1).filter(row => row.trim() !== '');

        let avgPriceChange = 0;
        let positiveChanges = 0;
        let negativeChanges = 0;

        for (const row of rows) {
            const columns = row.split(',');
            if (columns.length > 15) { // Make sure we have enough columns
                const priceChange = parseFloat(columns[15]); // Future_Price_Change column
                if (!isNaN(priceChange)) {
                    avgPriceChange += priceChange;
                    if (priceChange > 0) positiveChanges++;
                    else if (priceChange < 0) negativeChanges++;
                }
            }
        }

        avgPriceChange = avgPriceChange / rows.length;

        // Create message
        let message = `*CSV Data for ${symbol}*\n\n`;
        message += `ðŸ“Š *Statistics:*\n`;
        message += `- Data Points: ${dataPoints}\n`;
        message += `- File Size: ${fileSize}\n`;
        message += `- Last Modified: ${modifiedDate}\n`;
        message += `- Avg Price Change: ${avgPriceChange.toFixed(2)}%\n`;
        message += `- Positive Changes: ${positiveChanges} (${((positiveChanges / rows.length) * 100).toFixed(2)}%)\n`;
        message += `- Negative Changes: ${negativeChanges} (${((negativeChanges / rows.length) * 100).toFixed(2)}%)\n\n`;

        // Check if model exists for this symbol
        const modelPath = path.join(MODEL_PATH, symbol, 'model.json');
        if (fs.existsSync(modelPath)) {
            message += `âœ… *Brain.js model is available for this symbol*\n\n`;
        } else {
            message += `âš ï¸ *No Brain.js model trained yet for this symbol*\n\n`;
        }

        message += `The CSV file contains the following columns:\n`;
        message += `Timestamp, Open, High, Low, Close, Volume, EMA, EMA_Diff_Pct, RSI, MACD, MACD_Signal, MACD_Hist, BB_Width, ATR, Volume_Change, Future_Price_Change\n\n`;

        message += `You can use this data with external tools for visualization and analysis.`;

        // Send message with inline keyboard
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“Š List All Data', callback_data: 'list_data' },
                        { text: 'ðŸ§  Train Model', callback_data: 'train_models' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });

        // Send CSV file
        await bot.sendDocument(chatId, csvPath, {
            caption: `CSV training data for ${symbol} with ${dataPoints} data points`
        });
    } catch (error) {
        log(`Error viewing CSV data for ${symbol}: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error viewing CSV data: ${error.message}`);
    }
}

// Refresh WebSockets command
async function refreshWebSockets(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ”„ Refreshing WebSocket connections...');

        // Close all existing WebSockets
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
            } catch (e) {
                // Ignore errors when closing
            }
            activeWebSockets.delete(symbol);
        }

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        await bot.sendMessage(chatId, 'âœ… WebSocket connections refreshed successfully!');
    } catch (error) {
        log(`Error refreshing WebSockets: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error refreshing WebSockets: ${error.message}`);
    }
}

// Callback query handler for inline buttons
async function handleCallbackQuery(callbackQuery) {
    const action = callbackQuery.data;
    const chatId = callbackQuery.message.chat.id;

    try {
        if (action === 'status') {
            await sendStatusUpdate(chatId);
        } else if (action === 'settings') {
            await sendSettingsMenu(chatId);
        } else if (action === 'top_gainers') {
            await sendTopPerformers(chatId, 'gainers');
        } else if (action === 'top_losers') {
            await sendTopPerformers(chatId, 'losers');
        } else if (action === 'top_volume') {
            await sendTopPerformers(chatId, 'volume');
        } else if (action === 'menu') {
            await sendMainMenu(chatId);
        } else if (action === 'help') {
            await sendHelpMessage(chatId);
        } else if (action === 'refresh_ws') {
            await refreshWebSockets(chatId);
        } else if (action.startsWith('timeframe_')) {
            const newTimeframe = action.replace('timeframe_', '');
            // Update the timeframe
            TIMEFRAME = newTimeframe;
            log(`Timeframe updated to ${newTimeframe}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new timeframe
            await bot.sendMessage(chatId, `âœ… Timeframe updated to ${newTimeframe}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('ema_')) {
            const newEma = parseInt(action.replace('ema_', ''), 10);
            // Update the EMA period
            EMA_PERIOD = newEma;
            log(`EMA period updated to ${newEma}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new EMA period
            await bot.sendMessage(chatId, `âœ… EMA period updated to ${newEma}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('volume_')) {
            const newVolume = parseInt(action.replace('volume_', ''), 10);
            // Update the volume threshold
            VOLUME_THRESHOLD = newVolume;
            log(`Volume threshold updated to ${newVolume}`, 'success');
            saveSettings();

            // Refresh tracked pairs based on new volume threshold
            await bot.sendMessage(chatId, `âœ… Volume threshold updated to ${formatVolume(newVolume)}. Refreshing tracked pairs...`);
            await setupAllWebSockets();

            await sendSettingsMenu(chatId);
        } else if (action === 'ml_status') {
            await sendModelPerformance(chatId);
        } else if (action === 'train_models') {
            await trainAllModels(chatId);
        } else if (action === 'list_data') {
            await listAvailableCSVData(chatId);
        } else if (action === 'collect_data') {
            await startManualDataCollection(chatId);
        } else if (action.startsWith('viewdata_')) {
            const symbol = action.replace('viewdata_', '');
            await viewSymbolCSVData(chatId, symbol);
        }

        // Answer callback query to remove loading state
        await bot.answerCallbackQuery(callbackQuery.id);
    } catch (error) {
        log(`Error handling callback query: ${error.message}`, 'error');
        await bot.answerCallbackQuery(callbackQuery.id, { text: 'An error occurred' });
    }
}

// Add this function to save settings to a file
function saveSettings() {
    try {
        const settings = {
            EMA_PERIOD,
            TIMEFRAME,
            VOLUME_THRESHOLD,
            CHECK_INTERVAL,
            ALERT_COOLDOWN,
            ML_ENABLED
        };

        fs.writeFileSync(
            path.join(__dirname, 'settings.json'),
            JSON.stringify(settings, null, 2)
        );
        log('Settings saved to file', 'success');
    } catch (error) {
        log(`Error saving settings: ${error.message}`, 'error');
    }
}

// Add this function to load settings from file
function loadSettings() {
    try {
        const settingsPath = path.join(__dirname, 'settings.json');
        if (fs.existsSync(settingsPath)) {
            const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

            // Update variables with saved settings
            EMA_PERIOD = settings.EMA_PERIOD || EMA_PERIOD;
            TIMEFRAME = settings.TIMEFRAME || TIMEFRAME;
            VOLUME_THRESHOLD = settings.VOLUME_THRESHOLD || VOLUME_THRESHOLD;
            ML_ENABLED = settings.ML_ENABLED !== undefined ? settings.ML_ENABLED : ML_ENABLED;

            log('Settings loaded from file', 'success');
        }
    } catch (error) {
        log(`Error loading settings: ${error.message}`, 'error');
    }
}

// Send main menu with Brain.js options
async function sendMainMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [{ text: 'ðŸ“Š Status', callback_data: 'status' }],
            [{ text: 'âš™ï¸ Settings', callback_data: 'settings' }],
            [
                { text: 'ðŸ“ˆ Top Gainers', callback_data: 'top_gainers' },
                { text: 'ðŸ“‰ Top Losers', callback_data: 'top_losers' }
            ],
            [{ text: 'ðŸ’° Highest Volume', callback_data: 'top_volume' }],
            [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
            [
                { text: 'ðŸ§  ML Status', callback_data: 'ml_status' },
                { text: 'ðŸ”¬ Train Models', callback_data: 'train_models' }
            ],
            [
                { text: 'ðŸ“Š List Data', callback_data: 'list_data' },
                { text: 'ðŸ“¥ Collect Data', callback_data: 'collect_data' }
            ],
            [{ text: 'â“ Help', callback_data: 'help' }]
        ]
    };

    await bot.sendMessage(chatId, '*EMA Tracker Bot Menu*\nSelect an option:', {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send status update
async function sendStatusUpdate(chatId) {
    try {
        const pairs = await getFuturesPairs();
        const activeWsCount = Array.from(activeWebSockets.values())
            .filter(ws => ws.readyState === WebSocket.OPEN).length;

        // Get Brain.js model stats
        const modelCount = fs.existsSync(MODEL_PATH) ?
            fs.readdirSync(MODEL_PATH).filter(item => fs.existsSync(path.join(MODEL_PATH, item, 'model.json'))).length : 0;

        // Get data collection stats
        const dataPointCount = Array.from(trainingData.entries())
            .reduce((sum, [_, data]) => sum + data.length, 0);

        const message = `*EMA Tracker Status*\n\n` +
            `*Active Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Monitoring: ${pairs.length} pairs\n` +
            `- Active WebSockets: ${activeWsCount}/${pairs.length}\n` +
            `- Last Check: ${new Date().toLocaleString()}\n\n` +
            `*Brain.js ML Status:*\n` +
            `- ML Enabled: ${ML_ENABLED ? 'âœ…' : 'âŒ'}\n` +
            `- Trained Models: ${modelCount}\n` +
            `- Data Points Collected: ${dataPointCount}\n\n` +
            `Bot is actively monitoring for EMA crossovers in real-time.`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending status update: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching status');
    }
}

// Send settings menu
async function sendSettingsMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [
                { text: '1m', callback_data: 'timeframe_1m' },
                { text: '5m', callback_data: 'timeframe_5m' },
                { text: '15m', callback_data: 'timeframe_15m' },
                { text: '1h', callback_data: 'timeframe_1h' },
                { text: '4h', callback_data: 'timeframe_4h' }
            ],
            [
                { text: 'EMA 50', callback_data: 'ema_50' },
                { text: 'EMA 100', callback_data: 'ema_100' },
                { text: 'EMA 200', callback_data: 'ema_200' }
            ],
            [
                { text: 'Vol 50M', callback_data: 'volume_50000000' },
                { text: 'Vol 100M', callback_data: 'volume_100000000' },
                { text: 'Vol 200M', callback_data: 'volume_200000000' }
            ],
            [
                { text: ML_ENABLED ? 'ðŸ§  Disable ML' : 'ðŸ§  Enable ML', callback_data: 'toggle_ml' }
            ],
            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
        ]
    };

    await bot.sendMessage(chatId, `*Settings*\n\nCurrent Configuration:\n- EMA: ${EMA_PERIOD}\n- Timeframe: ${TIMEFRAME}\n- Volume Threshold: ${formatVolume(VOLUME_THRESHOLD)}\n- ML Enabled: ${ML_ENABLED ? 'âœ…' : 'âŒ'}\n\nSelect a new setting:`, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send help message
async function sendHelpMessage(chatId) {
    const helpText = `*EMA Tracker Bot Help*\n\n` +
        `This bot monitors Binance Futures markets for EMA crossovers and sends alerts when they occur.\n\n` +
        `*Available Commands:*\n` +
        `/menu - Show the main menu\n` +
        `/status - Check bot status\n` +
        `/settings - Configure bot settings\n` +
        `/top - View top performing coins\n` +
        `/refresh - Refresh WebSocket connections\n` +
        `/mlstatus - Check ML model performance\n` +
        `/train - Train ML models\n` +
        `/collectdata - Manually collect training data\n` +
        `/listdata - List available CSV data\n` +
        `/viewdata SYMBOL - View data for a specific symbol\n` +
        `/help - Show this help message\n\n` +
        `*How It Works:*\n` +
        `The bot uses WebSockets to track price movements in real-time and detect when price crosses above or below the ${EMA_PERIOD} EMA on the ${TIMEFRAME} timeframe for high-volume coins.\n\n` +
        `*Brain.js ML Integration:*\n` +
        `The bot collects data and trains neural network models to predict price movements after EMA crossovers. These predictions are included in the alerts to help you make more informed trading decisions.`;

    await bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
        }
    });
}

// Send top performers (gainers, losers, or by volume)
async function sendTopPerformers(chatId, type = 'gainers') {
    try {
        await bot.sendMessage(chatId, 'â³ Fetching data...');

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        let coins = response.data.filter(coin => coin.symbol.endsWith('USDT'));

        // Sort based on type
        if (type === 'gainers') {
            coins.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 gainers
        } else if (type === 'losers') {
            coins.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 losers
        } else if (type === 'volume') {
            coins.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            coins = coins.slice(0, 10); // Top 10 by volume
        }

        let title;
        if (type === 'gainers') title = 'ðŸ“ˆ *Top Gainers (24h)*';
        else if (type === 'losers') title = 'ðŸ“‰ *Top Losers (24h)*';
        else title = 'ðŸ’° *Highest Volume (24h)*';

        let message = `${title}\n\n`;

        coins.forEach((coin, index) => {
            const symbol = coin.symbol;
            const price = formatPrice(parseFloat(coin.lastPrice));
            const change = parseFloat(coin.priceChangePercent).toFixed(2);
            const volume = formatVolume(parseFloat(coin.quoteVolume));

            const changeEmoji = parseFloat(change) >= 0 ? 'ðŸŸ¢' : 'ðŸ”´';
            message += `${index + 1}. ${symbol}: ${price} (${changeEmoji} ${change}%) - Vol: ${volume}\n`;
        });

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“ˆ Gainers', callback_data: 'top_gainers' },
                        { text: 'ðŸ“‰ Losers', callback_data: 'top_losers' },
                        { text: 'ðŸ’° Volume', callback_data: 'top_volume' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error fetching top performers: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching data');
    }
}

// Send initial startup message to Telegram
async function sendStartupMessage() {
    try {
        const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
            `*Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Check Interval: ${(CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
            `- Alert Cooldown: ${(ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n` +
            `- WebSocket Monitoring: Enabled\n` +
            `- Brain.js ML: ${ML_ENABLED ? 'Enabled' : 'Disabled'}\n\n` +
            `Bot is now monitoring for EMA crossovers in real-time with ML predictions...`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
        log('Startup message sent to Telegram', 'success');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Started',
            `Monitoring ${TIMEFRAME} timeframe with ${EMA_PERIOD} EMA in real-time`,
            'info'
        );

        // Send the menu after startup message
        await sendMainMenu(TELEGRAM_CHAT_ID);
    } catch (error) {
        log(`Error sending startup message: ${error.message}`, 'error');
    }
}

// WebSocket heartbeat function to keep connections alive
function startWebSocketHeartbeat() {
    // Check WebSocket connections every minute
    setInterval(() => {
        try {
            let reconnected = 0;

            for (const [symbol, ws] of activeWebSockets.entries()) {
                // If WebSocket is closed or closing, reconnect
                if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    // Only log to file, not to console
                    fs.appendFileSync(
                        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                        `[${new Date().toISOString()}] WebSocket for ${symbol} is closed or closing. Reconnecting...\n`
                    );
                    setupSymbolWebSocket(symbol);
                    reconnected++;
                }
            }

            if (reconnected > 0) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Reconnected ${reconnected} WebSocket connections during heartbeat check\n`
                );
            }
        } catch (error) {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error in WebSocket heartbeat: ${error.message}\n`
            );
        }
    }, 60000); // Check every minute
}

// Set up message and callback query handlers
bot.on('message', handleMessage);
bot.on('callback_query', handleCallbackQuery);

// Handle process termination gracefully
process.on('SIGINT', async () => {
    try {
        log('Received SIGINT. Shutting down gracefully...', 'warning');

        // Close all WebSocket connections
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
                log(`Closed WebSocket for ${symbol}`, 'info');
            } catch (e) {
                // Ignore errors when closing
            }
        }

        await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Shutting Down',
            'The bot is shutting down gracefully',
            'warning'
        );

        process.exit(0);
    } catch (error) {
        log(`Error during shutdown: ${error.message}`, 'error');
        process.exit(1);
    }
});

// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');

    // Show desktop notification for unhandled rejection
    showDesktopNotification(
        'Error in EMA Tracker',
        'An unhandled rejection occurred. Check logs for details.',
        'error'
    );
});

// Initialize Brain.js ML module
const brainML = {
    trainModelForSymbol: async function (symbol) {
        try {
            // Check if we have enough data
            if (!trainingData.has(symbol)) {
                log(`No training data for ${symbol}`, 'warning');
                return null;
            }

            const data = trainingData.get(symbol);
            const validData = data.filter(d => d.future_price_change !== null);

            if (validData.length < 100) {
                log(`Not enough valid data for ${symbol}: ${validData.length} points`, 'warning');
                return null;
            }

            log(`Training Brain.js model for ${symbol} with ${validData.length} data points`, 'info');

            // Import the ml_alternative.js module
            const ml_alternative = require('./ml_alternative');

            // Train the model using Brain.js
            const result = await ml_alternative.trainModelForSymbol(symbol);

            if (result) {
                log(`Successfully trained Brain.js model for ${symbol}`, 'success');
                return result;
            } else {
                log(`Failed to train Brain.js model for ${symbol}`, 'error');
                return null;
            }
        } catch (error) {
            log(`Error training Brain.js model for ${symbol}: ${error.message}`, 'error');
            return null;
        }
    },

    predictPriceChange: async function (symbol, features) {
        try {
            // Import the ml_alternative.js module
            const ml_alternative = require('./ml_alternative');

            // Make prediction using Brain.js
            const prediction = await ml_alternative.predictPriceChange(symbol, features);

            return prediction;
        } catch (error) {
            log(`Error making Brain.js prediction for ${symbol}: ${error.message}`, 'error');
            return null;
        }
    },

    exportToCSV: async function (symbol, data) {
        try {
            // Create CSV data directory if it doesn't exist
            const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
            if (!fs.existsSync(CSV_DATA_DIR)) {
                fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
            }

            // Create directory for this symbol if it doesn't exist
            const symbolDir = path.join(CSV_DATA_DIR, symbol);
            if (!fs.existsSync(symbolDir)) {
                fs.mkdirSync(symbolDir, { recursive: true });
            }

            const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

            // Filter out data points without future price change
            const validData = data.filter(d => d.future_price_change !== null);

            if (validData.length === 0) {
                log(`No valid data points with outcomes for ${symbol}`, 'warning');
                return false;
            }

            // Create CSV content
            let csvContent = 'timestamp,open,high,low,close,volume,ema,ema_diff,rsi,macd,macd_signal,macd_hist,bb_width,volume_change,future_price_change\n';

            for (const point of validData) {
                csvContent += `${point.timestamp},${point.open},${point.high},${point.low},${point.close},${point.volume},${point.ema},${point.ema_diff},${point.rsi},${point.macd || 0},${point.macd_signal || 0},${point.macd_hist || 0},${point.bb_width},${point.volume_change || 0},${point.future_price_change}\n`;
            }

            // Write to file
            fs.writeFileSync(csvPath, csvContent);

            log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
            return true;
        } catch (error) {
            log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error');
            return false;
        }
    }
};

// Calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) {
        return 0;
    }

    const trueRanges = [];

    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        // True Range is the greatest of:
        // 1. Current High - Current Low
        // 2. |Current High - Previous Close|
        // 3. |Current Low - Previous Close|
        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        const trueRange = Math.max(tr1, tr2, tr3);
        trueRanges.push(trueRange);
    }

    // Calculate simple moving average of true ranges
    if (trueRanges.length < period) {
        return trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    }

    const atr = trueRanges.slice(-period).reduce((sum, tr) => sum + tr, 0) / period;
    return atr;
}

// Install required packages if not already installed
async function installRequiredPackages() {
    const { exec } = require('child_process');
    const requiredPackages = ['ws', 'brain.js']; // WebSocket and Brain.js packages

    for (const pkg of requiredPackages) {
        try {
            require.resolve(pkg);
            log(`Package ${pkg} is already installed`, 'info');
        } catch (e) {
            log(`Installing required package: ${pkg}...`, 'info');

            try {
                await new Promise((resolve, reject) => {
                    exec(`npm install ${pkg}`, (error, stdout, stderr) => {
                        if (error) {
                            log(`Error installing ${pkg}: ${error.message}`, 'error');
                            reject(error);
                            return;
                        }
                        log(`Successfully installed ${pkg}`, 'success');
                        resolve();
                    });
                });
            } catch (error) {
                log(`Failed to install ${pkg}: ${error.message}`, 'error');
                throw error;
            }
        }
    }
}

// Initialize the terminal and start monitoring
async function initialize() {
    try {
        // Install required packages
        await installRequiredPackages();

        // Initialize terminal and load settings
        initializeTerminal();
        loadSettings();

        console.log('\nStarting initial check...'.green);

        // Initialize ML components
        console.log('Initializing Brain.js machine learning components...'.cyan);

        // Create models directory if it doesn't exist
        const modelsDir = path.join(__dirname, 'ml_models');
        if (!fs.existsSync(modelsDir)) {
            fs.mkdirSync(modelsDir, { recursive: true });
        }

        // Create CSV data directory if it doesn't exist
        const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
        if (!fs.existsSync(CSV_DATA_DIR)) {
            fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
        }

        // Send startup message
        await sendStartupMessage();

        // Do initial check to populate data
        await checkEMACross();

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        // Start WebSocket heartbeat
        startWebSocketHeartbeat();

        // Load ML training data
        loadTrainingData();

        await updateIncompleteDataPoints();

        // Schedule periodic saving of training data
        setInterval(saveTrainingData, 30 * 60 * 1000); // Save every 30 minutes

        // Now set flag to enable volume threshold notifications for subsequent checks
        initialLoadComplete = true;
        log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');

        // Run the check at the specified interval as a backup
        // This is in addition to the real-time WebSocket monitoring
        monitoringInterval = setInterval(async () => {
            log('Running periodic check as backup to WebSockets...', 'info');
            await checkEMACross();
        }, CHECK_INTERVAL);

        log('Initialization complete. Bot is now monitoring in real-time via WebSockets with Brain.js ML enhancement.', 'success');
    } catch (error) {
        log(`Failed to initialize: ${error.message}`, 'error');

        // Show desktop notification for startup failure
        showDesktopNotification(
            'EMA Tracker Failed to Start',
            `Error: ${error.message}`,
            'error'
        );

        // Try to send error message to Telegram
        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, `âŒ *Error Starting Bot*\n\n${error.message}`, {
                parse_mode: 'Markdown'
            });
        } catch (e) {
            log(`Could not send error message to Telegram: ${e.message}`, 'error');
        }
    }
}

// Start the bot
initialize();
// Function to send a message to Telegram

-------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


//Initialize Brain.js ML module
// const mlModel = {
//     /**
//      * Train a model for a specific symbol
//      * @param {string} symbol - The trading pair symbol
//      * @returns {Promise<Object|null>} Training result or null on failure
//      */
//     trainModelForSymbol: async function (symbol) {
//         try {
//             if (!validateSymbol(symbol)) {
//                 log(`Invalid symbol format: ${symbol}`, 'error');
//                 return null;
//             }

//             // Check if we have enough data
//             if (!trainingData.has(symbol)) {
//                 log(`No training data for ${symbol}`, 'warning');
//                 return null;
//             }

//             const data = trainingData.get(symbol);
//             const validData = data.filter(d => d.future_price_change !== null);

//             if (validData.length < 100) {
//                 log(`Not enough valid data for ${symbol}: ${validData.length} points`, 'warning');
//                 return null;
//             }

//             log(`Training Brain.js model for ${symbol} with ${validData.length} data points`, 'info');

//             // Check memory usage before training
//             if (!checkMemoryUsage()) {
//                 log(`Skipping model training for ${symbol} due to high memory usage`, 'warning');
//                 return null;
//             }

//             // Import the ml_alternative.js module
//             const ml_alternative = require('./ml_alternative');

//             // Train the model using Brain.js
//             const result = await ml_alternative.trainModelForSymbol(symbol);

//             if (result) {
//                 log(`Successfully trained Brain.js model for ${symbol}`, 'success');
//                 return result;
//             } else {
//                 log(`Failed to train Brain.js model for ${symbol}`, 'error');
//                 return null;
//             }
//         } catch (error) {
//             log(`Error training Brain.js model for ${symbol}: ${error.message}`, 'error', error);
//             return null;
//         }
//     },

//     /**
//      * Make a price change prediction
//      * @param {string} symbol - The trading pair symbol
//      * @param {Object} features - Technical indicator features
//      * @returns {Promise<Object|null>} Prediction result or null on failure
//      */
//     predictPriceChange: async function (symbol, features) {
//         try {
//             if (!validateSymbol(symbol)) {
//                 return null;
//             }

//             // Check if model exists for this symbol
//             const modelPath = path.join(DIRECTORIES.MODEL_PATH, symbol, 'model.json');
//             if (!fs.existsSync(modelPath)) {
//                 // Don't log a warning - silently return null for untrained models
//                 return null;
//             }

//             // Import the ml_alternative.js module
//             const ml_alternative = require('./ml_alternative');

//             // Make prediction using Brain.js
//             const prediction = await ml_alternative.predictPriceChange(symbol, features);

//             // Check if prediction is valid
//             if (prediction === null || prediction === undefined || isNaN(prediction)) {
//                 return null;
//             }

//             // Calculate confidence score based on model performance
//             let confidence = 0.5; // Default medium confidence

//             // If we have performance data for this model, use it to adjust confidence
//             if (modelPerformance.has(symbol)) {
//                 const perf = modelPerformance.get(symbol);
//                 if (perf.directionAccuracy) {
//                     // Scale confidence based on direction accuracy (0.5-1.0)
//                     confidence = 0.5 + (perf.directionAccuracy * 0.5);
//                 }
//             }

//             return {
//                 prediction: prediction,
//                 confidence: confidence
//             };
//         } catch (error) {
//             log(`Error making Brain.js prediction for ${symbol}: ${error.message}`, 'error', error);
//             return null;
//         }
//     },

//     /**
//      * Export data to CSV
//      * @param {string} symbol - The trading pair symbol
//      * @param {Array} data - Data to export
//      * @returns {Promise<boolean>} Success status
//      */
//     exportToCSV: async function (symbol, data) {
//         try {
//             if (!validateSymbol(symbol)) {
//                 return false;
//             }

//             // Create CSV data directory if it doesn't exist
//             if (!fs.existsSync(DIRECTORIES.CSV_DATA)) {
//                 fs.mkdirSync(DIRECTORIES.CSV_DATA, { recursive: true });
//             }

//             // Create directory for this symbol if it doesn't exist
//             const symbolDir = path.join(DIRECTORIES.CSV_DATA, symbol);
//             if (!fs.existsSync(symbolDir)) {
//                 fs.mkdirSync(symbolDir, { recursive: true });
//             }

//             const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

//             // Filter out data points without future price change
//             const validData = data.filter(d => d.future_price_change !== null);

//             if (validData.length === 0) {
//                 log(`No valid data points with outcomes for ${symbol}`, 'warning');
//                 return false;
//             }

//             // Create CSV content
//             let csvContent = 'timestamp,open,high,low,close,volume,ema,ema_diff,rsi,macd,macd_signal,macd_hist,bb_width,volume_change,future_price_change\n';

//             for (const point of validData) {
//                 csvContent += `${point.timestamp},${point.open},${point.high},${point.low},${point.close},${point.volume},${point.ema},${point.ema_diff},${point.rsi},${point.macd || 0},${point.macd_signal || 0},${point.macd_hist || 0},${point.bb_width},${point.volume_change || 0},${point.future_price_change}\n`;
//             }

//             // Write to file
//             fs.writeFileSync(csvPath, csvContent);

//             log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
//             return true;
//         } catch (error) {
//             log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error', error);
//             return false;
//         }
//     }
// };



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        



/**
 * EMA Tracker with Machine Learning
 * A real-time cryptocurrency price tracker with EMA crossover detection and ML predictions
 */

// Core dependencies
const axios = require('axios');
const colors = require('colors');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');
const WebSocket = require('ws');
const { createObjectCsvWriter } = require('csv-writer');
const brain = require('brain.js');
const os = require('os');

// Custom modules
const technicalIndicators = require('./technical_indicators');
//const { mlModel } = require('./ml_alternative');
// node.js
// const { startWatcher } = require('./node1.js');
// startWatcher();


// Configuration and state managementT
const CONFIG = {
    // Default configuration (will be overridden by settings.json if available)
    EMA_PERIOD: parseInt(process.env.EMA_PERIOD, 10) || 200,
    TIMEFRAME: process.env.TIMEFRAME || '5m',
    VOLUME_THRESHOLD: parseInt(process.env.VOLUME_THRESHOLD, 10) || 100_000_000,
    CHECK_INTERVAL: parseInt(process.env.CHECK_INTERVAL, 10) || 5 * 60 * 1000, // 5 minutes
    ALERT_COOLDOWN: parseInt(process.env.ALERT_COOLDOWN, 10) || 15 * 60 * 1000, // 15 minutes
    ML_ENABLED: true,
    MAX_WEBSOCKET_RECONNECT_ATTEMPTS: 5,
    WEBSOCKET_RECONNECT_DELAY: 5000, // 5 seconds
    MAX_MEMORY_USAGE_MB: 800, // Maximum memory usage in MB
    MAX_CACHE_SIZE: 1000, // Maximum number of items in caches
};

// Telegram configuration
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// State tracking
let initialLoadComplete = false;
let dataCollectionInProgress = false;
let monitoringInterval = null;

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Caches and state management
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring
const activeWebSockets = new Map(); // Track active WebSocket connections
const webSocketReconnectAttempts = new Map(); // Track reconnection attempts
const klineCache = new Map(); // Cache for kline data
const emaCache = new Map(); // Cache for calculated EMAs
const trainingData = new Map(); // Store historical data for ML training
const modelPerformance = new Map(); // Track model performance

// Directories
const DIRECTORIES = {
    ML_DATA: path.join(__dirname, 'ml_data'),
    CSV_DATA: path.join(__dirname, 'csv_data'),
    MODEL_PATH: path.join(__dirname, 'ml_models'),
    LOG_DIR: path.join(__dirname, 'logs'),
    DATA_DIR: path.join(__dirname, 'data'),
};

// Create required directories
Object.values(DIRECTORIES).forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

/**
 * Enhanced logging with severity levels and structured format
 * @param {string} message - The message to log
 * @param {string} type - Log type (info, success, warning, error)
 * @param {Object} details - Additional details for the log
 */
function log(message, type = 'info', details = null) {
    const timestamp = new Date().toISOString();
    let logMessage = `[${timestamp}] [${type.toUpperCase()}] ${message}`;

    // Add details if available
    if (details) {
        if (details instanceof Error) {
            logMessage += `\nStack: ${details.stack}`;
        } else if (typeof details === 'object') {
            try {
                logMessage += `\nDetails: ${JSON.stringify(details)}`;
            } catch (e) {
                logMessage += `\nDetails: [Object]`;
            }
        } else {
            logMessage += `\nDetails: ${details}`;
        }
    }

    // Console logging with colors
    switch (type) {
        case 'error':
            console.error(logMessage.red);
            break;
        case 'success':
            console.log(logMessage.green);
            break;
        case 'warning':
            console.log(logMessage.yellow);
            break;
        default:
            console.log(logMessage);
    }

    // File logging with rotation
    try {
        const today = new Date().toISOString().split('T')[0];
        const logFile = path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${today}.log`);

        // Check log file size for rotation
        let stats;
        try {
            stats = fs.statSync(logFile);
        } catch (e) {
            // File doesn't exist yet
        }

        // If log file is larger than 10MB, rotate it
        if (stats && stats.size > 10 * 1024 * 1024) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            fs.renameSync(logFile, path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${today}-${timestamp}.log`));
        }

        fs.appendFileSync(logFile, logMessage + '\n');
    } catch (error) {
        console.error(`Failed to write to log file: ${error.message}`.red);
    }
}

/**
 * Validate symbol to prevent security issues
 * @param {string} symbol - The symbol to validate
 * @returns {boolean} True if symbol is valid, false otherwise
 */
function validateSymbol(symbol) {
    // Only allow alphanumeric characters and limited special chars
    if (!symbol || typeof symbol !== 'string' || !/^[A-Z0-9]+$/.test(symbol)) {
        log(`Invalid symbol format: ${symbol}`, 'error');
        return false;
    }
    return true;
}

/**
 * Show desktop notification using node-notifier
 * @param {string} title - Notification title
 * @param {string} message - Notification message
 * @param {string} type - Notification type (info, warning, error)
 */
function showDesktopNotification(title, message, type = 'info') {
    try {
        notifier.notify({
            title: title,
            message: message,
            sound: true,
            wait: true,
            icon: path.join(__dirname, type === 'error' ? 'error.png' :
                type === 'warning' ? 'warning.png' : 'info.png')
        });

        log(`Desktop notification shown: ${title} - ${message}`);
    } catch (error) {
        log(`Failed to show desktop notification: ${error.message}`, 'error', error);
    }
}

/**
 * Initialize terminal with application header
 */
function initializeTerminal() {
    console.clear();
    console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);
    console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
    console.log(`Configuration: ${CONFIG.EMA_PERIOD} EMA | ${CONFIG.TIMEFRAME} Timeframe | Volume > ${CONFIG.VOLUME_THRESHOLD.toLocaleString()}`.cyan);
    console.log(`Alert Cooldown: ${CONFIG.ALERT_COOLDOWN / 60000} minutes`.magenta);
    console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
    console.log(`WebSocket Real-Time Monitoring: Enabled`.green);
    console.log(`Machine Learning: ${CONFIG.ML_ENABLED ? 'Enabled'.green : 'Disabled'.red}`);
    console.log('='.repeat(80).dim);
    console.log('\nCROSSOVER EVENTS:'.cyan.bold);

    log(`EMA Tracker started with configuration: EMA=${CONFIG.EMA_PERIOD}, Timeframe=${CONFIG.TIMEFRAME}, Volume Threshold=${CONFIG.VOLUME_THRESHOLD}, ML=${CONFIG.ML_ENABLED}`);
}

/**
 * Helper function to format volume
 * @param {number} volume - Volume to format
 * @returns {string} Formatted volume
 */
function formatVolume(volume) {
    if (volume >= 1_000_000_000) {
        return (volume / 1_000_000_000).toFixed(2) + 'B';
    } else if (volume >= 1_000_000) {
        return (volume / 1_000_000).toFixed(2) + 'M';
    } else if (volume >= 1_000) {
        return (volume / 1_000).toFixed(2) + 'K';
    }
    return volume.toFixed(2);
}

/**
 * Format price with appropriate precision based on value
 * @param {number} price - Price to format
 * @returns {string} Formatted price
 */
function formatPrice(price) {
    if (price < 0.001) return price.toFixed(8);
    if (price < 1) return price.toFixed(6);
    if (price < 100) return price.toFixed(4);
    return price.toFixed(2);
}

/**
 * Get 24hr stats for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<Object>} 24hr stats
 */
async function get24HrStats(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            return { priceChangePercent: '0.00', quoteVolume: '0' };
        }

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            params: { symbol },
            timeout: 10000 // 10 second timeout
        });

        return {
            priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
            quoteVolume: parseFloat(response.data.quoteVolume)
        };
    } catch (error) {
        log(`Error fetching 24hr stats for ${symbol}: ${error.message}`, 'error', error);
        return { priceChangePercent: '0.00', quoteVolume: '0' };
    }
}

/**
 * Fetch Binance Futures pairs with 24hr quote volume above the threshold
 * @returns {Promise<string[]>} Array of symbol names
 */
async function getFuturesPairs() {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            timeout: 15000 // 15 second timeout
        });

        const newPairs = [];

        const pairs = response.data
            .filter(pair => {
                const volume = parseFloat(pair.quoteVolume);
                const symbol = pair.symbol;

                if (volume > CONFIG.VOLUME_THRESHOLD) {
                    // Only track new pairs that cross threshold after initial load
                    if (initialLoadComplete && !trackedPairs.has(symbol)) {
                        newPairs.push({
                            symbol,
                            volume,
                            price: parseFloat(pair.lastPrice),
                            change: parseFloat(pair.priceChangePercent)
                        });
                    }
                    trackedPairs.add(symbol);
                    return true;
                }
                return false;
            })
            .map(pair => pair.symbol);

        // Alert for new pairs that crossed the volume threshold (only after initial load)
        if (newPairs.length > 0) {
            alertNewHighVolumePairs(newPairs);
        }

        return pairs;
    } catch (error) {
        log(`Error fetching futures pairs: ${error.message}`, 'error', error);
        return [];
    }
}

/**
 * Alert when new pairs cross the volume threshold
 * @param {Array<Object>} newPairs - Array of new high volume pairs
 */
async function alertNewHighVolumePairs(newPairs) {
    for (const pair of newPairs) {
        if (!validateSymbol(pair.symbol)) {
            continue;
        }

        const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
            `*Symbol:* ${pair.symbol}\n` +
            `*Volume:* ${formatVolume(pair.volume)}\n` +
            `*Price:* ${formatPrice(pair.price)}\n` +
            `*24h Change:* ${pair.change.toFixed(2)}%\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `This pair has been added to the monitoring list.` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

            // Show desktop notification
            showDesktopNotification(
                'New High Volume Pair',
                `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
                'info'
            );

            log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');

            // Setup WebSocket for the new pair
            setupSymbolWebSocket(pair.symbol);
        } catch (error) {
            log(`Error sending new pair alert for ${pair.symbol}: ${error.message}`, 'error', error);
        }
    }
}

/**
 * Retrieve historical candlestick data for the given symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<Array>} Array of candlestick data
 */
async function getKlines(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            return [];
        }

        const limit = CONFIG.EMA_PERIOD + 100; // Request extra candles to be safe

        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: { symbol, interval: CONFIG.TIMEFRAME, limit: limit },
            timeout: 15000 // 15 second timeout
        });

        const klines = response.data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));

        // Update the kline cache with size limit
        if (klineCache.size > CONFIG.MAX_CACHE_SIZE) {
            // Remove oldest entry
            const oldestKey = klineCache.keys().next().value;
            klineCache.delete(oldestKey);
        }
        klineCache.set(symbol, klines);

        // Calculate and cache EMA
        const closes = klines.map(k => k.close);
        const emaValues = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);

        // Update EMA cache with size limit
        if (emaCache.size > CONFIG.MAX_CACHE_SIZE) {
            // Remove oldest entry
            const oldestKey = emaCache.keys().next().value;
            emaCache.delete(oldestKey);
        }
        emaCache.set(symbol, emaValues);

        if (klines.length < CONFIG.EMA_PERIOD) {
            log(`Warning: Not enough candles for ${symbol}. Needed ${CONFIG.EMA_PERIOD}, got ${klines.length}`, 'warning');
        }

        return klines;
    } catch (error) {
        log(`Error fetching klines for ${symbol}: ${error.message}`, 'error', error);
        return [];
    }
}

/**
 * Update EMA with a new price (for real-time updates)
 * @param {string} symbol - The trading pair symbol
 * @param {number} newPrice - The new price to update EMA with
 * @returns {boolean} Success status
 */
function updateEMA(symbol, newPrice) {
    try {
        // Get cached EMA values
        let emaValues = emaCache.get(symbol);

        // If no cached values, we need to fetch historical data first
        if (!emaValues || emaValues.length === 0) {
            log(`No cached EMA values for ${symbol}, fetching historical data...`, 'warning');
            return false;
        }

        const k = 2 / (CONFIG.EMA_PERIOD + 1);
        const lastEMA = emaValues[emaValues.length - 1];
        const newEMA = (newPrice - lastEMA) * k + lastEMA;

        // Add the new EMA to the cache
        emaValues.push(newEMA);

        // Keep the cache size reasonable by removing older values
        if (emaValues.length > CONFIG.EMA_PERIOD * 2) {
            emaValues = emaValues.slice(-CONFIG.EMA_PERIOD * 2);
        }

        emaCache.set(symbol, emaValues);
        return true;
    } catch (error) {
        log(`Error updating EMA for ${symbol}: ${error.message}`, 'error', error);
        return false;
    }
}

/**
 * Send Telegram notification with enhanced formatting
 * @param {string} symbol - The trading pair symbol
 * @param {string} crossType - Type of crossover ('up' or 'down')
 * @param {number} price - Current price
 * @param {number} ema - Current EMA value
 * @param {number} difference - Percentage difference between price and EMA
 */
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${CONFIG.EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${CONFIG.TIMEFRAME}\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending Telegram message: ${error.message}`, 'error', error);

        // Retry with simpler message if parse_mode might be the issue
        try {
            const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
            await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
            log(`Sent simplified alert for ${symbol} after error`, 'warning');
        } catch (retryError) {
            log(`Failed to send even simplified message: ${retryError.message}`, 'error', retryError);
        }
    }
}

/**
 * Check if we should alert for this symbol based on direction change and cooldown
 * @param {string} symbol - The trading pair symbol
 * @param {string} currentState - Current state ('above' or 'below')
 * @returns {boolean} Whether to send an alert
 */
function shouldAlert(symbol, currentState) {
    // Don't send alerts during data collection
    if (dataCollectionInProgress) {
        return false;
    }

    const now = Date.now();
    const previousState = coinStates.get(symbol);
    const lastAlertTime = lastAlerts.get(symbol) || 0;

    if (previousState !== currentState) {
        coinStates.set(symbol, currentState);
        if (now - lastAlertTime >= CONFIG.ALERT_COOLDOWN) {
            lastAlerts.set(symbol, now);
            return true;
        } else {
            log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
        }
    }
    return false; // No alert if state hasn't changed or cooldown active
}


/**
 * WebSocket setup for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {WebSocket|null} The WebSocket connection
 */
// Add a connection state tracking map
const wsConnectionStates = new Map(); // Possible states: 'connecting', 'open', 'closing', 'closed'

function setupSymbolWebSocket(symbol) {
    // Close existing connection if any, but only if it's not in 'connecting' state
    if (activeWebSockets.has(symbol)) {
        const existingWs = activeWebSockets.get(symbol);
        const connectionState = wsConnectionStates.get(symbol) || 'unknown';

        // Only try to close if it's not already connecting (to avoid the error)
        if (connectionState !== 'connecting') {
            try {
                existingWs.close();
            } catch (e) {
                // Ignore errors when closing
            }
        }
    }

    // // Create WebSocket URL based on timeframe
    // function setupSymbolWebSocket(symbol) {
    //     if (!validateSymbol(symbol)) return null;

    //     // Close existing connection if any
    //     if (activeWebSockets.has(symbol)) {
    //         const existingWs = activeWebSockets.get(symbol);
    //         const connectionState = wsConnectionStates.get(symbol) || 'unknown';

    //         // Only try to close if not already connecting
    //         if (connectionState !== 'connecting') {
    //             try {
    //                 existingWs.close();
    //             } catch (e) {
    //                 // Ignore errors when closing
    //             }
    //         }
    //     }

    // Set connection state to connecting
    wsConnectionStates.set(symbol, 'connecting');

    const ws = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${CONFIG.TIMEFRAME}`);

    // Add connection timeout
    const connectionTimeout = setTimeout(() => {
        if (wsConnectionStates.get(symbol) === 'connecting') {
            log(`WebSocket connection timeout for ${symbol}`, 'warning');
            ws.terminate();
            handleWebSocketReconnect(symbol);
        }
    }, 10000);

    ws.on('open', () => {
        clearTimeout(connectionTimeout);
        wsConnectionStates.set(symbol, 'open');
        webSocketReconnectAttempts.set(symbol, 0);
    });

    // ws.on('message', (data) => {
    //     // Handle incoming WebSocket messages
    //     handleWebSocketMessage(symbol, data);
    // });

    ws.on('message', (data) => {
        try {
            const message = JSON.parse(data);
            if (message.k) {  // kline data
                const kline = message.k;

                // Process real-time data
                if (kline.x) {  // If candle closed
                    processClosedCandle(symbol, kline);
                } else {  // Real-time update
                    processRealtimeCandle(symbol, kline, true);
                }
            }
        } catch (error) {
            log(`Error processing WebSocket message for ${symbol}: ${error.message}`, 'error', error);
        }
    });




    ws.on('close', () => {
        wsConnectionStates.set(symbol, 'closed');
        //handleWebSocketReconnect(symbol);
    });

    ws.on('error', (error) => {
        log(`WebSocket error for ${symbol}: ${error.message}`, 'error', error);
        ws.terminate();
        handleWebSocketReconnect(symbol);
    });

    activeWebSockets.set(symbol, ws);
    return ws;
}


async function handleWebSocketMessage(symbol, data) {
    try {
        const message = JSON.parse(data);
        
        if (message.e === 'kline') {
            const kline = message.k;
            const currentPrice = parseFloat(kline.c);
            const lastEMA = emaCache.get(symbol)?.slice(-1)[0];
            
            if (lastEMA) {
                const prevState = coinStates.get(symbol);
                const currentState = currentPrice > lastEMA ? 'above' : 'below';
                
                // Check for potential crossover
                if (prevState !== currentState) {
                    const difference = ((currentPrice - lastEMA) / lastEMA) * 100;
                    
                    // Update EMA with new price
                    if (updateEMA(symbol, currentPrice)) {
                        // If it's a confirmed crossover, send alert
                        if (shouldAlert(symbol, currentState)) {
                            await sendTelegramAlert(symbol, 
                                currentState === 'above' ? 'up' : 'down',
                                currentPrice, 
                                lastEMA,
                                difference);
                        }
                    }
                }
            }
        }
    } catch (error) {
        log(`Error handling WebSocket message: ${error.message}`, 'error', error);
    }
}
/**
 * Handle WebSocket reconnection with exponential backoff
 * @param {string} symbol - The trading pair symbol
 */
function handleWebSocketReconnect(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        const attempts = webSocketReconnectAttempts.get(symbol) || 0;

        if (attempts >= CONFIG.MAX_WEBSOCKET_RECONNECT_ATTEMPTS) {
            log(`Maximum reconnect attempts reached for ${symbol}, giving up`, 'warning');
            return;
        }

        // Exponential backoff: 5s, 10s, 20s, 40s, 80s
        const delay = CONFIG.WEBSOCKET_RECONNECT_DELAY * Math.pow(2, attempts);

        log(`Scheduling WebSocket reconnect for ${symbol} in ${delay}ms (attempt ${attempts + 1}/${CONFIG.MAX_WEBSOCKET_RECONNECT_ATTEMPTS})`, 'info');

        // Increment reconnect attempts
        webSocketReconnectAttempts.set(symbol, attempts + 1);

        setTimeout(() => {
            if (trackedPairs.has(symbol)) {
                log(`Attempting to reconnect WebSocket for ${symbol}`, 'info');
                setupSymbolWebSocket(symbol);
            }
        }, delay);
    } catch (error) {
        log(`Error in WebSocket reconnect handler: ${error.message}`, 'error', error);
    }
}

/**
 * Collect data for ML training
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 */
async function collectDataForML(symbol, kline) {
    try {
        if (!CONFIG.ML_ENABLED || !validateSymbol(symbol)) {
            return;
        }

        // Get cached klines
        const klines = klineCache.get(symbol) || [];
        if (klines.length < 30) return; // Need enough data for indicators

        // Get closes for indicators
        const closes = klines.map(k => k.close);
        const volumes = klines.map(k => k.volume);

        // Calculate indicators
        const rsi = technicalIndicators.calculateRSI(closes);
        const macd = technicalIndicators.calculateMACD(closes);
        const bb = technicalIndicators.calculateBollingerBands(closes);
        const atr = technicalIndicators.calculateATR(klines);

        // Create data point
        const dataPoint = {
            timestamp: kline.t,
            symbol: symbol,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v),
            ema: emaCache.get(symbol)[emaCache.get(symbol).length - 1],
            ema_diff: (parseFloat(kline.c) - emaCache.get(symbol)[emaCache.get(symbol).length - 1]) /
                emaCache.get(symbol)[emaCache.get(symbol).length - 1] * 100,
            rsi: rsi[rsi.length - 1],
            macd: macd.macd[macd.macd.length - 1],
            macd_signal: macd.signal[macd.signal.length - 1],
            macd_hist: macd.histogram[macd.histogram.length - 1],
            bb_upper: bb.upper[bb.upper.length - 1],
            bb_middle: bb.middle[bb.middle.length - 1],
            bb_lower: bb.lower[bb.lower.length - 1],
            bb_width: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) /
                bb.middle[bb.middle.length - 1],
            atr: atr,
            volume_change: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
            future_price_change: null, // To be filled later
            label: null // To be filled later
        };

        // Initialize training data array for this symbol if it doesn't exist
        if (!trainingData.has(symbol)) {
            trainingData.set(symbol, []);
        }

        // Add to training data
        trainingData.get(symbol).push(dataPoint);

        //exportToCSV();

        // Keep training data size manageable (last 1000 candles)
        if (trainingData.get(symbol).length > 1000) {
            trainingData.set(symbol, trainingData.get(symbol).slice(-1000));
        }

        // Schedule update of future price change (after 24 hours)
        setTimeout(() => updateFuturePriceChange(symbol, kline.t), 24 * 60 * 60 * 1000);
    } catch (error) {
        log(`Error collecting ML data for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Process closed candle data
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 * @param {boolean} dataCollectionMode - Whether in data collection mode
 */
async function processClosedCandle(symbol, kline, dataCollectionMode = false) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        // Get cached klines or initialize if not exists
        let klines = klineCache.get(symbol) || [];

        // Create new kline object
        const newKline = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
        };

        // Add new kline to cache
        klines.push(newKline);

        // Keep cache size reasonable
        if (klines.length > CONFIG.EMA_PERIOD * 2) {
            klines = klines.slice(-CONFIG.EMA_PERIOD * 2);
        }

        klineCache.set(symbol, klines);

        // Get closes for EMA calculation
        const closes = klines.map(k => k.close);

        // Calculate new EMA values
        const emaValues = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        // Collect data for ML training
        await collectDataForML(symbol, kline);

        // Check for crossover only if not in data collection mode
        if (!dataCollectionMode && emaValues.length >= 2) {
            const lastPrice = closes[closes.length - 1];
            const prevPrice = closes[closes.length - 2];
            const lastEMA = emaValues[emaValues.length - 1];
            const prevEMA = emaValues[emaValues.length - 2];

            checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA);
        }
    } catch (error) {
        log(`Error processing closed candle for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Process real-time candle updates
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 * @param {boolean} logUnconfirmed - Whether to log unconfirmed crossovers
 */
async function processRealtimeCandle(symbol, kline, logUnconfirmed = true) {
    try {
        // Validate symbol
        if (!validateSymbol(symbol)) {
            return;
        }

        // Get cached klines and validate
        const klines = klineCache.get(symbol);
        if (!klines || klines.length === 0) {
            return; // No historical data yet
        }

        // Get current price and validate
        const currentPrice = parseFloat(kline.c);
        if (isNaN(currentPrice)) {
            throw new Error('Invalid price data');
        }

        // Get cached EMA values and validate
        const emaValues = emaCache.get(symbol);
        if (!emaValues || emaValues.length < 2) {
            return; // Not enough EMA values yet
        }

        // Get the last closed price and EMA
        const lastClosedPrice = klines[klines.length - 1].close;
        const lastEMA = emaValues[emaValues.length - 1];

        // Get ML prediction if enabled
        let prediction = null;
        let confidenceScore = null;
        
        if (CONFIG.ML_ENABLED && mlModel) {
            try {
                const features = await prepareFeaturesForPrediction(symbol, klines, currentPrice);
                const predictionResult = await mlModel.predictPriceChange(symbol, features);
                if (predictionResult) {
                    prediction = predictionResult.prediction;
                    confidenceScore = predictionResult.confidenceScore;
                }
            } catch (predictionError) {
                log(`ML prediction error for ${symbol}: ${predictionError.message}`, 'warning');
            }
        }

        // Determine states
        const prevState = lastClosedPrice > lastEMA ? 'above' : 'below';
        const currentState = currentPrice > lastEMA ? 'above' : 'below';

        // Calculate difference percentage
        const difference = ((currentPrice - lastEMA) / lastEMA) * 100;

        // If state changed, we have a potential real-time crossover
        if (prevState !== currentState) {
            // Only log if explicitly requested
            if (logUnconfirmed) {
                const crossType = currentState === 'above' ? 'up' : 'down';
                const crossLabel = crossType === 'up' ?
                    'â–² POTENTIAL UPWARD CROSSOVER' :
                    'â–¼ POTENTIAL DOWNWARD CROSSOVER';

                // Log to file only
                const logMessage = [
                    `[${new Date().toISOString()}] ${crossLabel} detected for ${symbol}`,
                    `Current Price: ${formatPrice(currentPrice)}`,
                    `EMA(${CONFIG.EMA_PERIOD}): ${formatPrice(lastEMA)}`,
                    `Difference: ${difference.toFixed(2)}%`,
                    `Status: REAL-TIME (Unconfirmed)`,
                    prediction !== null ? `ML Prediction: ${prediction.toFixed(2)}% (Confidence: ${(confidenceScore * 100).toFixed(1)}%)` : ''
                ].join('\n');

                fs.appendFileSync(
                    path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    logMessage + '\n\n'
                );
            }

            // Update EMA with new price
            if (updateEMA(symbol, currentPrice)) {
                // If crossover confirmed and should alert
                if (shouldAlert(symbol, currentState)) {
                    if (prediction !== null) {
                        await sendTelegramAlertWithML(
                            symbol,
                            currentState === 'above' ? 'up' : 'down',
                            currentPrice,
                            lastEMA,
                            difference,
                            prediction,
                            confidenceScore
                        );
                    } else {
                        await sendTelegramAlert(
                            symbol,
                            currentState === 'above' ? 'up' : 'down',
                            currentPrice,
                            lastEMA,
                            difference
                        );
                    }
                }
            }

            // Collect data for ML training if enabled
            if (CONFIG.ML_ENABLED) {
                await collectDataForML(symbol, kline);
            }
        }

        // Update coin state even if no crossover
        coinStates.set(symbol, currentState);

    } catch (error) {
        // Log error to file
        fs.appendFileSync(
            path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error processing real-time candle for ${symbol}: ${error.message}\n`
        );
    }
}


/**
 * Check for EMA crossover and send alerts
 * @param {string} symbol - The trading pair symbol
 * @param {number} prevPrice - Previous price
 * @param {number} lastPrice - Current price
 * @param {number} prevEMA - Previous EMA
 * @param {number} lastEMA - Current EMA
 */
async function checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        // Determine current state (above or below EMA)
        const currentState = lastPrice > lastEMA ? 'above' : 'below';
        const difference = (lastPrice - lastEMA) / lastEMA * 100;

        // Get ML prediction if available, but handle errors gracefully
        let prediction = null;
        let confidenceScore = null;

        if (CONFIG.ML_ENABLED) {
            try {
                // Check if model exists for this symbol before attempting prediction
                const modelPath = path.join(DIRECTORIES.MODEL_PATH, symbol, 'model.json');
                if (fs.existsSync(modelPath)) {
                    // Get additional technical indicators
                    const klines = klineCache.get(symbol) || [];
                    if (klines.length >= 30) {
                        const closes = klines.map(k => k.close);
                        const volumes = klines.map(k => k.volume || 0);

                        // Calculate indicators
                        const rsi = technicalIndicators.calculateRSI(closes);
                        const macd = technicalIndicators.calculateMACD(closes);
                        const bb = technicalIndicators.calculateBollingerBands(closes);
                        const atr = technicalIndicators.calculateATR(klines);

                        // Prepare features for prediction
                        const features = {
                            priceDiff: difference,
                            rsi: rsi[rsi.length - 1],
                            macdHist: macd.histogram[macd.histogram.length - 1],
                            bbWidth: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.middle[bb.middle.length - 1],
                            volumeChange: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
                            atr: atr,
                            volume24h: volumes[volumes.length - 1]
                        };

                        // Get prediction using Brain.js
                        const predictionResult = await mlModel.predictPriceChange(symbol, features);

                        if (predictionResult && typeof predictionResult.prediction === 'number') {
                            prediction = predictionResult.prediction;
                            confidenceScore = predictionResult.confidenceScore / 100 || 0.5;

                            // Improved ML prediction log with symbol and key indicators
                            const predictionColor = prediction >= 0 ? 'green' : 'red';
                            const predictionSign = prediction >= 0 ? '+' : '';
                            console.log(`  ${symbol} ML Prediction: ${predictionSign}${prediction.toFixed(2)}% expected change (Confidence: ${(confidenceScore * 100).toFixed(1)}%)`.cyan);
                            console.log(`  Key Indicators: RSI=${rsi[rsi.length - 1].toFixed(2)}, MACD=${macd.histogram[macd.histogram.length - 1].toFixed(4)}`.gray);
                        }
                    }
                }
            } catch (predictionError) {
                log(`Error getting prediction for ${symbol}: ${predictionError.message}`, 'warning', predictionError);
                // Continue without prediction
            }
        }

        // Upward crossover: price crossing from below to above EMA
        if (prevPrice < prevEMA && lastPrice > lastEMA) {
            console.log('\n');
            console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'up', lastPrice, lastEMA, difference, prediction, confidenceScore);
                } else {
                    await sendTelegramAlert(symbol, 'up', lastPrice, lastEMA, difference);
                }
            }
        }
        // Downward crossover: price crossing from above to below EMA
        else if (prevPrice > prevEMA && lastPrice < lastEMA) {
            console.log('\n');
            console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'down', lastPrice, lastEMA, difference, prediction, confidenceScore);
                } else {
                    await sendTelegramAlert(symbol, 'down', lastPrice, lastEMA, difference);
                }
            }
        } else {
            // Update state even if no crossover
            coinStates.set(symbol, currentState);
        }
    } catch (error) {
        log(`Error checking for crossover for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Setup WebSockets for all tracked pairs
 */
async function setupAllWebSockets() {
    try {
        const pairs = await getFuturesPairs();

        log(`Setting up WebSockets for ${pairs.length} pairs`, 'info');

        // Close any existing WebSockets for pairs that are no longer tracked
        for (const [symbol, ws] of activeWebSockets.entries()) {
            if (!pairs.includes(symbol)) {
                log(`Closing WebSocket for ${symbol} (no longer tracked)`, 'info');
                try {
                    ws.close();
                } catch (e) {
                    // Ignore errors when closing
                }
                activeWebSockets.delete(symbol);
            }
        }

        // Setup WebSockets for all tracked pairs
        for (const symbol of pairs) {
            if (!activeWebSockets.has(symbol) || activeWebSockets.get(symbol).readyState !== WebSocket.OPEN) {
                setupSymbolWebSocket(symbol);

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        log(`WebSocket setup completed for ${pairs.length} pairs`, 'success');
    } catch (error) {
        log(`Error setting up WebSockets: ${error.message}`, 'error', error);
    }
}

/**
 * Check for EMA crossovers (traditional method, still used for initial load and periodic checks)
 */
async function checkEMACross() {
    try {
        // Check memory usage before heavy operation
        if (!checkMemoryUsage()) {
            log('Skipping EMA check due to high memory usage', 'warning');
            return;
        }

        const pairs = await getFuturesPairs();
        const timestamp = new Date().toLocaleString();

        console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
        process.stdout.write('Processing: '.cyan);

        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair =>
            getKlines(pair)
                .then(klines => ({ pair, klines, error: null }))
                .catch(error => ({ pair, klines: [], error }))
        );

        const results = await Promise.all(klinesPromises);

        for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');

            if (error || klines.length < CONFIG.EMA_PERIOD) {
                if (klines.length < CONFIG.EMA_PERIOD) {
                    log(`Skipping ${pair}: Not enough candles (${klines.length}/${CONFIG.EMA_PERIOD})`, 'warning');
                }
                continue;
            }

            const closes = klines.map(k => k.close);
            const ema = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);

            // Make sure we have enough EMA values
            if (ema.length < 2) {
                log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
                continue;
            }

            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];

            // Check for crossover
            checkForCrossover(pair, prevPrice, lastPrice, prevEMA, lastEMA);
        }

        console.log('\n');
        console.log(`Check completed at ${timestamp}. WebSockets are now monitoring in real-time.`.gray);
        console.log('='.repeat(80).dim);
    } catch (error) {
        log(`Error in checkEMACross: ${error.message}`, 'error', error);
        console.error('Stack trace:', error.stack);
    }
}

/**
 * Update future price change for training data
 * @param {string} symbol - The trading pair symbol
 * @param {number} timestamp - Timestamp of the data point
 */
async function updateFuturePriceChange(symbol, timestamp) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        if (!trainingData.has(symbol)) return;

        const data = trainingData.get(symbol);
        const dataPoint = data.find(d => d.timestamp === timestamp);

        if (!dataPoint) return;

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);
        const originalPrice = dataPoint.close;

        // Calculate price change percentage
        const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);

        // Update the data point
        dataPoint.future_price_change = priceChange;
        dataPoint.label = priceChange >= 0 ? 1 : 0;

        log(`Updated future price change for ${symbol}: ${priceChange.toFixed(2)}%`, 'info');

        // Save training data to disk periodically
        saveTrainingData();

        // Export updated data to CSV
        if (data.filter(d => d.future_price_change !== null).length % 50 === 0) {
            // Export to CSV every 50 completed data points
            await mlModel.exportToCSV(symbol, data);
        }
    } catch (error) {
        log(`Error updating future price change: ${error.message}`, 'error', error);
    }
}

/**
 * Get current price for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<number>} Current price
 */
async function getCurrentPrice(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            throw new Error('Invalid symbol');
        }

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/price', {
            params: { symbol },
            timeout: 10000 // 10 second timeout
        });
        return parseFloat(response.data.price);
    } catch (error) {
        log(`Error getting current price for ${symbol}: ${error.message}`, 'error', error);
        throw error;
    }
}

/**
 * Save training data to disk
 */
function saveTrainingData() {
    try {
        // Check memory usage before heavy operation
        if (!checkMemoryUsage()) {
            log('Skipping training data save due to high memory usage', 'warning');
            return;
        }

        if (!fs.existsSync(DIRECTORIES.DATA_DIR)) {
            fs.mkdirSync(DIRECTORIES.DATA_DIR, { recursive: true });
        }

        // Save each symbol's data to a separate file
        for (const [symbol, data] of trainingData.entries()) {
            if (!validateSymbol(symbol)) {
                continue;
            }

            fs.writeFileSync(
                path.join(DIRECTORIES.DATA_DIR, `${symbol}_training.json`),
                JSON.stringify(data)
            );

            // Export to CSV if we have enough data points with outcomes
            const completedData = data.filter(d => d.future_price_change !== null);
            if (completedData.length >= 50) {
                mlModel.exportToCSV(symbol, data).catch(err => {
                    log(`Error exporting CSV for ${symbol}: ${err.message}`, 'error', err);
                });
            }
        }

        // Save model performance data
        fs.writeFileSync(
            path.join(DIRECTORIES.DATA_DIR, 'model_performance.json'),
            JSON.stringify(Array.from(modelPerformance.entries()))
        );

        log(`Saved training data for ${trainingData.size} symbols`, 'info');
    } catch (error) {
        log(`Error saving training data: ${error.message}`, 'error', error);
    }
}

/**
 * Load training data from disk
 */
function loadTrainingData() {
    try {
        if (!fs.existsSync(DIRECTORIES.DATA_DIR)) {
            fs.mkdirSync(DIRECTORIES.DATA_DIR, { recursive: true });
            return;
        }

        // Load each symbol's data
        const files = fs.readdirSync(DIRECTORIES.DATA_DIR).filter(f => f.endsWith('_training.json'));

        for (const file of files) {
            try {
                const symbol = file.replace('_training.json', '');

                if (!validateSymbol(symbol)) {
                    log(`Skipping invalid symbol file: ${file}`, 'warning');
                    continue;
                }

                const data = JSON.parse(fs.readFileSync(path.join(DIRECTORIES.DATA_DIR, file), 'utf8'));
                trainingData.set(symbol, data);
                log(`Loaded ${data.length} training points for ${symbol}`, 'info');
            } catch (e) {
                log(`Error loading data for ${file}: ${e.message}`, 'warning', e);
            }
        }

        // Load model performance data
        const perfFile = path.join(DIRECTORIES.DATA_DIR, 'model_performance.json');
        if (fs.existsSync(perfFile)) {
            const perfData = JSON.parse(fs.readFileSync(perfFile, 'utf8'));
            for (const [symbol, data] of perfData) {
                if (validateSymbol(symbol)) {
                    modelPerformance.set(symbol, data);
                }
            }
            log(`Loaded performance data for ${modelPerformance.size} models`, 'info');
        }
    } catch (error) {
        log(`Error loading training data: ${error.message}`, 'error', error);
    }
}

/**
 * Train all models
 * @param {string} chatId - Telegram chat ID for progress updates
 */
async function trainAllModels(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§  Starting Brain.js model training. This may take some time...');

        // Get all symbols with sufficient data
        const symbolsToTrain = Array.from(trainingData.keys())
            .filter(symbol => {
                if (!validateSymbol(symbol)) return false;

                const data = trainingData.get(symbol);
                const validData = data.filter(d => d.future_price_change !== null);
                return validData.length >= 100;
            });

        if (symbolsToTrain.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No symbols have enough data for training yet.');
            return;
        }

        await bot.sendMessage(chatId, `Training models for ${symbolsToTrain.length} symbols...`);

        let trainedCount = 0;
        let failedCount = 0;

        // Train models sequentially
        for (const symbol of symbolsToTrain) {
            try {
                // Check memory usage before training each model
                if (!checkMemoryUsage()) {
                    await bot.sendMessage(chatId, 'âš ï¸ Training stopped due to high memory usage. Please try again later.');
                    break;
                }

                // Export data to CSV first
                const data = trainingData.get(symbol);
                await mlModel.exportToCSV(symbol, data);

                // Train model
                const result = await mlModel.trainModelForSymbol(symbol);

                if (result) {
                    trainedCount++;

                    // Update model performance tracking
                    if (!modelPerformance.has(symbol)) {
                        modelPerformance.set(symbol, {
                            predictions: 0,
                            correctPredictions: 0,
                            directionAccuracy: result.performance?.directionAccuracy || 0,
                            mae: result.performance?.mae || 0,
                            lastTraining: new Date().toISOString(),
                            dataPoints: data.filter(d => d.future_price_change !== null).length
                        });
                    } else {
                        const perf = modelPerformance.get(symbol);
                        perf.lastTraining = new Date().toISOString();
                        perf.dataPoints = data.filter(d => d.future_price_change !== null).length;
                        perf.mae = result.performance?.mae || perf.mae;
                        perf.directionAccuracy = result.performance?.directionAccuracy || perf.directionAccuracy;
                        modelPerformance.set(symbol, perf);
                    }

                    // Send progress updates every 5 models
                    if (trainedCount % 5 === 0) {
                        await bot.sendMessage(
                            chatId,
                            `Progress: ${trainedCount}/${symbolsToTrain.length} models trained`
                        );
                    }
                } else {
                    failedCount++;
                }

                // Add a small delay between training sessions
                await new Promise(resolve => setTimeout(resolve, 5000));
            } catch (error) {
                log(`Error training model for ${symbol}: ${error.message}`, 'error', error);
                failedCount++;
            }
        }

        await bot.sendMessage(
            chatId,
            `ðŸ§  *Brain.js ML Training Complete*\n\n` +
            `âœ… Successfully trained: ${trainedCount} models\n` +
            `âŒ Failed: ${failedCount} models\n\n` +
            `Use /mlstatus to check model performance.`,
            { parse_mode: 'Markdown' }
        );

        // Save updated performance data
        saveTrainingData();
    } catch (error) {
        log(`Error in trainAllModels: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error training models: ${error.message}`);
    }
}

/**
 * Enhanced Telegram alert with ML prediction
 * @param {string} symbol - The trading pair symbol
 * @param {string} crossType - Type of crossover ('up' or 'down')
 * @param {number} price - Current price
 * @param {number} ema - Current EMA value
 * @param {number} difference - Percentage difference between price and EMA
 * @param {number} prediction - ML prediction value
 * @param {number} confidenceScore - Confidence score (0-1)
 */
async function sendTelegramAlertWithML(symbol, crossType, price, ema, difference, prediction, confidenceScore = 0.5) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Format ML prediction with confidence emoji
        let confidenceEmoji = 'âš ï¸'; // Neutral/uncertain
        if (confidenceScore > 0.8) {
            confidenceEmoji = prediction > 0 ? 'ðŸ”¥' : 'â„ï¸'; // Strong signal with high confidence
        } else if (confidenceScore > 0.6) {
            confidenceEmoji = prediction > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰'; // Moderate signal
        }

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${CONFIG.EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${CONFIG.TIMEFRAME}\n` +
            `*Brain.js Prediction:* ${confidenceEmoji} ${prediction.toFixed(2)}% (24h)\n` +
            `*Confidence:* ${(confidenceScore * 100).toFixed(1)}%\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, ML Prediction: ${prediction.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`ML-enhanced Telegram alert sent for ${symbol} (${crossType})`, 'success');

        // Update model performance tracking
        if (modelPerformance.has(symbol)) {
            const perf = modelPerformance.get(symbol);
            perf.predictions = (perf.predictions || 0) + 1;
            modelPerformance.set(symbol, perf);

            // Schedule a check after 24 hours to see if prediction was correct
            setTimeout(() => {
                checkPredictionAccuracy(symbol, prediction, price);
            }, 24 * 60 * 60 * 1000);
        }
    } catch (error) {
        log(`Error sending ML-enhanced Telegram message: ${error.message}`, 'error', error);

        // Fall back to regular alert
        sendTelegramAlert(symbol, crossType, price, ema, difference);
    }
}

/**
 * Check if a prediction was accurate after 24 hours
 * @param {string} symbol - The trading pair symbol
 * @param {number} prediction - The predicted price change percentage
 * @param {number} originalPrice - The price at time of prediction
 */
async function checkPredictionAccuracy(symbol, prediction, originalPrice) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);

        // Calculate actual price change
        const actualChange = ((currentPrice - originalPrice) / originalPrice) * 100;

        // Check if direction was correct
        const predictionDirection = prediction > 0;
        const actualDirection = actualChange > 0;
        const isCorrect = predictionDirection === actualDirection;

        log(`Prediction check for ${symbol}: Predicted ${prediction.toFixed(2)}%, Actual ${actualChange.toFixed(2)}%, Correct: ${isCorrect}`,
            isCorrect ? 'success' : 'warning');

        // Update model performance
        if (modelPerformance.has(symbol)) {
            const perf = modelPerformance.get(symbol);
            if (isCorrect) {
                perf.correctPredictions = (perf.correctPredictions || 0) + 1;
            }

            // Update direction accuracy
            if (perf.predictions > 0) {
                perf.directionAccuracy = perf.correctPredictions / perf.predictions;
            }

            modelPerformance.set(symbol, perf);

            // Save updated performance data
            fs.writeFileSync(
                path.join(DIRECTORIES.DATA_DIR, 'model_performance.json'),
                JSON.stringify(Array.from(modelPerformance.entries()))
            );
        }
    } catch (error) {
        log(`Error checking prediction accuracy for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Start manual data collection for all tracked pairs
 * @param {string} chatId - Telegram chat ID for progress updates
 */
async function startManualDataCollection(chatId) {
    try {
        // Check if data collection is already in progress
        if (dataCollectionInProgress) {
            await bot.sendMessage(chatId, 'âš ï¸ Data collection is already in progress. Please wait for it to complete.');
            return;
        }

        dataCollectionInProgress = true;
        await bot.sendMessage(chatId, 'ðŸ“Š Starting manual data collection for all tracked pairs...');

        const pairs = await getFuturesPairs();
        if (pairs.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No pairs are currently being tracked.');
            dataCollectionInProgress = false;
            return;
        }

        await bot.sendMessage(chatId, `Collecting data for ${pairs.length} pairs...`);

        let successCount = 0;
        let failedCount = 0;

        for (const symbol of pairs) {
            try {
                if (!validateSymbol(symbol)) {
                    failedCount++;
                    continue;
                }

                // Check memory usage before processing each symbol
                if (!checkMemoryUsage()) {
                    await bot.sendMessage(chatId, 'âš ï¸ Data collection stopped due to high memory usage. Please try again later.');
                    break;
                }

                // Get historical klines
                const klines = await getKlines(symbol);
                if (klines.length < 30) {
                    log(`Skipping ${symbol}: Not enough candles`, 'warning');
                    failedCount++;
                    continue;
                }

                // Process each candle
                for (let i = 0; i < klines.length; i++) {
                    // Skip very old candles
                    if (i < klines.length - 100) continue;

                    const candle = klines[i];

                    // Create kline object in the format expected by processClosedCandle
                    const klineObj = {
                        t: candle.time,
                        o: candle.open.toString(),
                        h: candle.high.toString(),
                        l: candle.low.toString(),
                        c: candle.close.toString(),
                        v: candle.volume.toString()
                    };

                    // Process this candle
                    await processClosedCandle(symbol, klineObj, true); // Pass true to indicate data collection mode
                }

                successCount++;

                // Send progress updates
                if ((successCount + failedCount) % 10 === 0) {
                    await bot.sendMessage(
                        chatId,
                        `Progress: ${successCount + failedCount}/${pairs.length} pairs processed`
                    );
                }

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                log(`Error collecting data for ${symbol}: ${error.message}`, 'error', error);
                failedCount++;
            }
        }

        // Save all collected data
        saveTrainingData();


        // Send completion message
        await bot.sendMessage(
            chatId,
            `ðŸ“Š *Data Collection Complete*\n\n` +
            `âœ… Successfully collected data for ${successCount} pairs\n` +
            `âŒ Failed: ${failedCount} pairs\n\n` +
            `Future price changes will be updated in 24 hours.`,
            { parse_mode: 'Markdown' }
        );

        // Reset the flag
        dataCollectionInProgress = false;
    } catch (error) {
        log(`Error in manual data collection: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error during data collection: ${error.message}`);
        dataCollectionInProgress = false;
    }
}

// /**

//  * Export data to CSV
//  * @param {string} symbol - The trading pair symbol
//  * @param {Array} data - Data to export
//  * @returns {Promise<boolean>} Success status
//  */
// async function exportToCSV(symbol, data) {
//     try {
//         if (!validateSymbol(symbol)) {
//             return false;
//         }

//         // Create directory for this symbol if it doesn't exist
//         const symbolDir = path.join(DIRECTORIES.CSV_DATA, symbol);
//         if (!fs.existsSync(symbolDir)) {
//             fs.mkdirSync(symbolDir, { recursive: true });
//         }

//         const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

//         // Filter out data points without future price change
//         const validData = data.filter(d => d.future_price_change !== null);

//         if (validData.length === 0) {
//             log(`No valid data points with outcomes for ${symbol}`, 'warning');
//             return false;
//         }

//         // Create CSV writer
//         const csvWriter = createObjectCsvWriter({
//             path: csvPath,
//             header: [
//                 { id: 'timestamp', title: 'Timestamp' },
//                 { id: 'open', title: 'Open' },
//                 { id: 'high', title: 'High' },
//                 { id: 'low', title: 'Low' },
//                 { id: 'close', title: 'Close' },
//                 { id: 'volume', title: 'Volume' },
//                 { id: 'ema', title: 'EMA' },
//                 { id: 'ema_diff', title: 'EMA_Diff_Pct' },
//                 { id: 'rsi', title: 'RSI' },
//                 { id: 'macd', title: 'MACD' },
//                 { id: 'macd_signal', title: 'MACD_Signal' },
//                 { id: 'macd_hist', title: 'MACD_Hist' },
//                 { id: 'bb_width', title: 'BB_Width' },
//                 { id: 'atr', title: 'ATR' },
//                 { id: 'volume_change', title: 'Volume_Change' },
//                 { id: 'future_price_change', title: 'Future_Price_Change' }
//             ]
//         });

//         // Write data to CSV
//         await csvWriter.writeRecords(validData);

//         log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
//         return true;
//     } catch (error) {
//         log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error', error);
//         return false;
//     }
// }

/**
 * Send model performance data
 * @param {string} chatId - Telegram chat ID
 */
async function sendModelPerformance(chatId) {
    try {
        if (modelPerformance.size === 0) {
            await bot.sendMessage(chatId, 'âŒ No model performance data available yet.');
            return;
        }

        let message = '*Brain.js Model Performance*\n\n';

        // Sort symbols by direction accuracy
        const sortedSymbols = Array.from(modelPerformance.keys())
            .filter(symbol => validateSymbol(symbol))
            .sort((a, b) => {
                const aMetrics = modelPerformance.get(a);
                const bMetrics = modelPerformance.get(b);
                return (bMetrics.directionAccuracy || 0) - (aMetrics.directionAccuracy || 0);
            })
            .slice(0, 10); // Top 10 performing models

        for (const symbol of sortedSymbols) {
            const metrics = modelPerformance.get(symbol);
            if (!metrics.dataPoints || metrics.dataPoints < 50) continue; // Skip models with few data points

            message += `*${symbol}*\n` +
                `- Direction Accuracy: ${((metrics.directionAccuracy || 0) * 100).toFixed(2)}%\n` +
                `- Mean Absolute Error: ${(metrics.mae || 0).toFixed(4)}\n` +
                `- Data Points: ${metrics.dataPoints}\n` +
                `- Last Trained: ${new Date(metrics.lastTraining).toLocaleString()}\n\n`;
        }

        // Add information about CSV data
        const csvSymbols = fs.existsSync(DIRECTORIES.CSV_DATA) ?
            fs.readdirSync(DIRECTORIES.CSV_DATA).filter(item => fs.statSync(path.join(DIRECTORIES.CSV_DATA, item)).isDirectory()) : [];

        if (csvSymbols.length > 0) {
            message += `\n*CSV Training Data Available*\n`;
            message += `${csvSymbols.length} symbols have CSV data for visualization.\n`;
            message += `CSV files are stored in: ${DIRECTORIES.CSV_DATA}\n\n`;
            message += `You can use these CSV files with external tools for data analysis.`;
        }

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Train All Models', callback_data: 'train_models' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending model performance: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, 'âŒ Error fetching model performance data');
    }
}

/**
 * Command handler for Telegram messages
 * @param {Object} msg - Telegram message object
 */
function handleMessage(msg) {
    try {
        const chatId = msg.chat.id;
        const text = msg.text || '';

        // Rate limiting for commands
        const now = Date.now();
        const lastCommandTime = lastCommandTimes.get(chatId) || 0;

        if (now - lastCommandTime < 1000) { // 1 second rate limit
            return; // Ignore command if rate limited
        }

        lastCommandTimes.set(chatId, now);

        if (text === '/start' || text === '/menu') {
            sendMainMenu(chatId);
        } else if (text === '/status') {
            sendStatusUpdate(chatId);
        } else if (text === '/settings') {
            sendSettingsMenu(chatId);
        } else if (text === '/help') {
            sendHelpMessage(chatId);
        } else if (text === '/top') {
            sendTopPerformers(chatId);
        } else if (text === '/refresh') {
            refreshWebSockets(chatId);
        } else if (text === '/mlstatus') {
            sendModelPerformance(chatId);
        } else if (text === '/train') {
            trainAllModels(chatId);
        } else if (text === '/collectdata') {
            startManualDataCollection(chatId);
        } else if (text === '/listdata') {
            listAvailableCSVData(chatId);
        } else if (text && text.startsWith('/viewdata ')) {
            const symbol = text.split(' ')[1].toUpperCase();
            if (validateSymbol(symbol)) {
                viewSymbolCSVData(chatId, symbol);
            } else {
                bot.sendMessage(chatId, 'âŒ Invalid symbol format');
            }
        }
    } catch (error) {
        log(`Error handling message: ${error.message}`, 'error', error);
    }
}

// Track last command times for rate limiting
const lastCommandTimes = new Map();

/**
 * List available CSV data
 * @param {string} chatId - Telegram chat ID
 */
async function listAvailableCSVData(chatId) {
    try {
        if (!fs.existsSync(DIRECTORIES.CSV_DATA)) {
            await bot.sendMessage(chatId, 'âŒ No CSV data directory found. Run data collection first.');
            return;
        }

        const symbols = fs.readdirSync(DIRECTORIES.CSV_DATA)
            .filter(item => fs.statSync(path.join(DIRECTORIES.CSV_DATA, item)).isDirectory() && validateSymbol(item));

        if (symbols.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No CSV data available yet. Run data collection first.');
            return;
        }

        // Get data points count for each symbol
        const symbolData = [];
        for (const symbol of symbols) {
            const csvPath = path.join(DIRECTORIES.CSV_DATA, symbol, `${symbol}_training_data.csv`);
            if (fs.existsSync(csvPath)) {
                const stats = fs.statSync(csvPath);
                const fileSize = (stats.size / 1024).toFixed(2) + ' KB';

                // Count lines (data points) - simple approach
                const content = fs.readFileSync(csvPath, 'utf8');
                const lines = content.split('\n').length - 1; // -1 for header

                symbolData.push({
                    symbol,
                    dataPoints: lines,
                    fileSize
                });
            }
        }

        // Sort by data points (descending)
        symbolData.sort((a, b) => b.dataPoints - a.dataPoints);

        let message = '*Available CSV Training Data*\n\n';

        for (const data of symbolData) {
            message += `*${data.symbol}*: ${data.dataPoints} data points (${data.fileSize})\n`;
        }

        message += '\nUse /viewdata SYMBOL to get details about a specific symbol\'s data.';

        // Create inline keyboard with symbols
        const keyboard = [];
        const buttonsPerRow = 3;

        for (let i = 0; i < symbolData.length; i += buttonsPerRow) {
            const row = [];
            for (let j = 0; j < buttonsPerRow && i + j < symbolData.length; j++) {
                row.push({
                    text: symbolData[i + j].symbol,
                    callback_data: `viewdata_${symbolData[i + j].symbol}`
                });
            }
            keyboard.push(row);
        }

        keyboard.push([{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]);

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        log(`Error listing CSV data: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error listing CSV data: ${error.message}`);
    }
}


/**
 * View CSV data for a specific symbol
 * @param {string} chatId - Telegram chat ID
 * @param {string} symbol - The trading pair symbol
 */
async function viewSymbolCSVData(chatId, symbol) {
    try {
        if (!validateSymbol(symbol)) {
            await bot.sendMessage(chatId, `âŒ Invalid symbol format: ${symbol}`);
            return;
        }

        const csvPath = path.join(DIRECTORIES.CSV_DATA, symbol, `${symbol}_training_data.csv`);

        if (!fs.existsSync(csvPath)) {
            await bot.sendMessage(chatId, `âŒ No CSV data found for ${symbol}`);
            return;
        }

        // Get file stats
        const stats = fs.statSync(csvPath);
        const fileSize = (stats.size / 1024).toFixed(2) + ' KB';
        const modifiedDate = new Date(stats.mtime).toLocaleString();

        // Count lines (data points)
        const content = fs.readFileSync(csvPath, 'utf8');
        const lines = content.split('\n');
        const dataPoints = lines.length - 1; // -1 for header

        // Get a preview of the data (first 5 rows)
        const preview = lines.slice(0, 6).join('\n');

        // Calculate some basic stats from the data
        const rows = content.split('\n').slice(1).filter(row => row.trim() !== '');

        let avgPriceChange = 0;
        let positiveChanges = 0;
        let negativeChanges = 0;

        for (const row of rows) {
            const columns = row.split(',');
            if (columns.length > 15) { // Make sure we have enough columns
                const priceChange = parseFloat(columns[15]); // Future_Price_Change column
                if (!isNaN(priceChange)) {
                    avgPriceChange += priceChange;
                    if (priceChange > 0) positiveChanges++;
                    else if (priceChange < 0) negativeChanges++;
                }
            }
        }

        avgPriceChange = avgPriceChange / rows.length;

        // Create message
        let message = `*CSV Data for ${symbol}*\n\n`;
        message += `ðŸ“Š *Statistics:*\n`;
        message += `- Data Points: ${dataPoints}\n`;
        message += `- File Size: ${fileSize}\n`;
        message += `- Last Modified: ${modifiedDate}\n`;
        message += `- Avg Price Change: ${avgPriceChange.toFixed(2)}%\n`;
        message += `- Positive Changes: ${positiveChanges} (${((positiveChanges / rows.length) * 100).toFixed(2)}%)\n`;
        message += `- Negative Changes: ${negativeChanges} (${((negativeChanges / rows.length) * 100).toFixed(2)}%)\n\n`;

        // Check if model exists for this symbol
        const modelPath = path.join(DIRECTORIES.MODEL_PATH, symbol, 'model.json');
        if (fs.existsSync(modelPath)) {
            message += `âœ… *Brain.js model is available for this symbol*\n\n`;
        } else {
            message += `âš ï¸ *No Brain.js model trained yet for this symbol*\n\n`;
        }

        message += `The CSV file contains the following columns:\n`;
        message += `Timestamp, Open, High, Low, Close, Volume, EMA, EMA_Diff_Pct, RSI, MACD, MACD_Signal, MACD_Hist, BB_Width, ATR, Volume_Change, Future_Price_Change\n\n`;

        message += `You can use this data with external tools for visualization and analysis.`;

        // Send message with inline keyboard
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“Š List All Data', callback_data: 'list_data' },
                        { text: 'ðŸ§  Train Model', callback_data: `train_single_${symbol}` }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });

        // Send CSV file
        await bot.sendDocument(chatId, csvPath, {
            caption: `CSV training data for ${symbol} with ${dataPoints} data points`
        });
    } catch (error) {
        log(`Error viewing CSV data for ${symbol}: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error viewing CSV data: ${error.message}`);
    }
}

/**
 * Train a single model
 * @param {string} chatId - Telegram chat ID
 * @param {string} symbol - The trading pair symbol
 */
async function trainSingleModel(chatId, symbol) {
    try {
        if (!validateSymbol(symbol)) {
            await bot.sendMessage(chatId, `âŒ Invalid symbol format: ${symbol}`);
            return;
        }

        await bot.sendMessage(chatId, `ðŸ§  Starting Brain.js model training for ${symbol}...`);

        // Check if we have data for this symbol
        if (!trainingData.has(symbol)) {
            await bot.sendMessage(chatId, `âŒ No training data found for ${symbol}. Please collect data first.`);
            return;
        }

        const data = trainingData.get(symbol);
        const validData = data.filter(d => d.future_price_change !== null);

        if (validData.length < 100) {
            await bot.sendMessage(chatId, `âŒ Not enough valid data for ${symbol}: ${validData.length}/100 points needed.`);
            return;
        }

        // Export data to CSV first
        await mlModel.exportToCSV(symbol, data);

        // Train model
        const result = await mlModel.trainModelForSymbol(symbol);

        if (result) {
            // Update model performance tracking
            if (!modelPerformance.has(symbol)) {
                modelPerformance.set(symbol, {
                    predictions: 0,
                    correctPredictions: 0,
                    directionAccuracy: result.performance?.directionAccuracy || 0,
                    mae: result.performance?.mae || 0,
                    lastTraining: new Date().toISOString(),
                    dataPoints: validData.length
                });
            } else {
                const perf = modelPerformance.get(symbol);
                perf.lastTraining = new Date().toISOString();
                perf.dataPoints = validData.length;
                perf.mae = result.performance?.mae || perf.mae;
                perf.directionAccuracy = result.performance?.directionAccuracy || perf.directionAccuracy;
                modelPerformance.set(symbol, perf);
            }

            // Save updated performance data
            saveTrainingData();

            await bot.sendMessage(chatId,
                `âœ… Successfully trained model for ${symbol}\n\n` +
                `- Direction Accuracy: ${(result.performance?.directionAccuracy * 100).toFixed(2)}%\n` +
                `- Mean Absolute Error: ${result.performance?.mae.toFixed(4)}\n` +
                `- Training Data Points: ${validData.length}\n\n` +
                `The model is now ready for predictions.`,
                {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                        ]
                    }
                }
            );
        } else {
            await bot.sendMessage(chatId, `âŒ Failed to train model for ${symbol}. Please try again later.`);
        }
    } catch (error) {
        log(`Error training model for ${symbol}: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error training model: ${error.message}`);
    }
}

/**
 * Refresh WebSockets command
 * @param {string} chatId - Telegram chat ID
 */
async function refreshWebSockets(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ”„ Refreshing WebSocket connections...');

        // Close all existing WebSockets
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
            } catch (e) {
                // Ignore errors when closing
            }
            activeWebSockets.delete(symbol);
        }

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        await bot.sendMessage(chatId, 'âœ… WebSocket connections refreshed successfully!');
    } catch (error) {
        log(`Error refreshing WebSockets: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error refreshing WebSockets: ${error.message}`);
    }
}

/**
 * Callback query handler for inline buttons
 * @param {Object} callbackQuery - Telegram callback query object
 */
async function handleCallbackQuery(callbackQuery) {
    const queryId = callbackQuery.id;
    const chatId = callbackQuery.message.chat.id;
    const action = callbackQuery.data;
    try {
        //const action = callbackQuery.data;
        //const chatId = callbackQuery.message.chat.id;

        // Rate limiting for callback queries
        const now = Date.now();
        const lastCallbackTime = lastCallbackTimes.get(chatId) || 0;

        if (now - lastCallbackTime < 1000) { // 1 second rate limit
            await bot.answerCallbackQuery(callbackQuery.id);
            return; // Ignore callback if rate limited
        }

        lastCallbackTimes.set(chatId, now);

        if (action === 'status') {
            await sendStatusUpdate(chatId);
        } else if (action === 'settings') {
            await sendSettingsMenu(chatId);
        } else if (action === 'top_gainers') {
            await sendTopPerformers(chatId, 'gainers');
        } else if (action === 'top_losers') {
            await sendTopPerformers(chatId, 'losers');
        } else if (action === 'top_volume') {
            await sendTopPerformers(chatId, 'volume');
        } else if (action === 'menu') {
            await sendMainMenu(chatId);
        } else if (action === 'help') {
            await sendHelpMessage(chatId);
        } else if (action === 'refresh_ws') {
            await refreshWebSockets(chatId);
        } else if (action.startsWith('timeframe_')) {
            const newTimeframe = action.replace('timeframe_', '');
            // Update the timeframe
            CONFIG.TIMEFRAME = newTimeframe;
            log(`Timeframe updated to ${newTimeframe}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new timeframe
            await bot.sendMessage(chatId, `âœ… Timeframe updated to ${newTimeframe}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('ema_')) {
            const newEma = parseInt(action.replace('ema_', ''), 10);
            // Update the EMA period
            CONFIG.EMA_PERIOD = newEma;
            log(`EMA period updated to ${newEma}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new EMA period
            await bot.sendMessage(chatId, `âœ… EMA period updated to ${newEma}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('volume_')) {
            const newVolume = parseInt(action.replace('volume_', ''), 10);
            // Update the volume threshold
            CONFIG.VOLUME_THRESHOLD = newVolume;
            log(`Volume threshold updated to ${newVolume}`, 'success');
            saveSettings();

            // Refresh tracked pairs based on new volume threshold
            await bot.sendMessage(chatId, `âœ… Volume threshold updated to ${formatVolume(newVolume)}. Refreshing tracked pairs...`);
            await setupAllWebSockets();

            await sendSettingsMenu(chatId);
        } else if (action === 'ml_status') {
            await sendModelPerformance(chatId);
        } else if (action === 'train_models') {
            await trainAllModels(chatId);
        } else if (action === 'list_data') {
            await listAvailableCSVData(chatId);
        } else if (action === 'collect_data') {
            await startManualDataCollection(chatId);
        } else if (action.startsWith('viewdata_')) {
            const symbol = action.replace('viewdata_', '');
            if (validateSymbol(symbol)) {
                await viewSymbolCSVData(chatId, symbol);
            } else {
                await bot.sendMessage(chatId, 'âŒ Invalid symbol format');
            }
        } else if (action.startsWith('train_single_')) {
            const symbol = action.replace('train_single_', '');
            if (validateSymbol(symbol)) {
                await trainSingleModel(chatId, symbol);
            } else {
                await bot.sendMessage(chatId, 'âŒ Invalid symbol format');
            }
        } else if (action === 'toggle_ml') {
            // Toggle ML enabled state
            CONFIG.ML_ENABLED = !CONFIG.ML_ENABLED;
            log(`Machine Learning ${CONFIG.ML_ENABLED ? 'enabled' : 'disabled'}`, 'success');
            saveSettings();

            await bot.sendMessage(chatId, `âœ… Machine Learning ${CONFIG.ML_ENABLED ? 'enabled' : 'disabled'}`);
            await sendSettingsMenu(chatId);
        } else if (action === 'memory_status') {
            await sendMemoryStatus(chatId);
        } else if (action === 'clear_memory') {
            await clearMemoryCache(chatId);
        }

        // Answer callback query to remove loading state
        //await bot.answerCallbackQuery(callbackQuery.id);
        await bot.answerCallbackQuery(queryId, { text: 'Action received!' });
    } catch (error) {
        if (error.response && error.response.statusCode === 400) {
            log(`Error handling callback query: ${error.message}`, 'error', error);
        } else {
            throw error; // Re-throw if it's not the specific 400 error
        }
    }
}

// Track last callback times for rate limiting
const lastCallbackTimes = new Map();

/**
 * Send memory usage status
 * @param {string} chatId - Telegram chat ID
 */
async function sendMemoryStatus(chatId) {
    try {
        const memoryUsage = process.memoryUsage();
        const formatMemory = (bytes) => (bytes / 1024 / 1024).toFixed(2) + ' MB';

        const message = `*Memory Usage Status*\n\n` +
            `- RSS: ${formatMemory(memoryUsage.rss)}\n` +
            `- Heap Total: ${formatMemory(memoryUsage.heapTotal)}\n` +
            `- Heap Used: ${formatMemory(memoryUsage.heapUsed)}\n` +
            `- External: ${formatMemory(memoryUsage.external)}\n\n` +
            `*Cache Sizes:*\n` +
            `- Kline Cache: ${klineCache.size} symbols\n` +
            `- EMA Cache: ${emaCache.size} symbols\n` +
            `- Training Data: ${trainingData.size} symbols\n` +
            `- Active WebSockets: ${activeWebSockets.size} connections\n\n` +
            `Memory usage is ${memoryUsage.heapUsed > 500 * 1024 * 1024 ? 'âš ï¸ HIGH' : 'âœ… NORMAL'}`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ§¹ Clear Memory Cache', callback_data: 'clear_memory' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending memory status: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error getting memory status: ${error.message}`);
    }
}

/**
 * Clear memory caches
 * @param {string} chatId - Telegram chat ID
 */
async function clearMemoryCache(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§¹ Clearing memory caches...');

        // Save training data before clearing
        saveTrainingData();

        // Clear caches
        klineCache.clear();
        emaCache.clear();

        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }

        const memoryUsage = process.memoryUsage();
        const formatMemory = (bytes) => (bytes / 1024 / 1024).toFixed(2) + ' MB';

        await bot.sendMessage(chatId,
            `âœ… Memory caches cleared!\n\n` +
            `Current heap usage: ${formatMemory(memoryUsage.heapUsed)}\n\n` +
            `Note: Training data was saved before clearing.`,
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                        [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                    ]
                }
            }
        );
    } catch (error) {
        log(`Error clearing memory cache: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error clearing memory: ${error.message}`);
    }
}

/**
 * Check memory usage and log warning if high
 * @returns {boolean} True if memory usage is acceptable, false if too high
 */
function checkMemoryUsage() {
    const memoryUsage = process.memoryUsage();
    const metrics = {
        heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024),
        heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024),
        rss: Math.round(memoryUsage.rss / 1024 / 1024),
        external: Math.round(memoryUsage.external / 1024 / 1024)
    };

    // Memory usage thresholds
    const maxMemory = CONFIG.MAX_MEMORY_USAGE_MB;
    const warningThreshold = maxMemory * 0.8;
    const criticalThreshold = maxMemory * 0.95;

    // Log warnings
    if (metrics.heapUsed > criticalThreshold) {
        log(`CRITICAL: Memory usage extremely high (${metrics.heapUsed}MB / ${maxMemory}MB). Attempting emergency cleanup.`, 'error');

        // Emergency cleanup
        if (global.klineCache) global.klineCache.clear();
        if (global.emaCache) global.emaCache.clear();

        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }

        return { isHealthy: false, metrics };
    } else if (metrics.heapUsed > warningThreshold) {
        log(`WARNING: High memory usage detected (${metrics.heapUsed}MB / ${metrics.heapTotal}MB)`, 'warning');
    }

    return { isHealthy: metrics.heapUsed < maxMemory, metrics };
}

/**
 * Save settings to a file
 */
function saveSettings() {
    try {
        const settings = {
            EMA_PERIOD: CONFIG.EMA_PERIOD,
            TIMEFRAME: CONFIG.TIMEFRAME,
            VOLUME_THRESHOLD: CONFIG.VOLUME_THRESHOLD,
            CHECK_INTERVAL: CONFIG.CHECK_INTERVAL,
            ALERT_COOLDOWN: CONFIG.ALERT_COOLDOWN,
            ML_ENABLED: CONFIG.ML_ENABLED
        };

        fs.writeFileSync(
            path.join(__dirname, 'settings.json'),
            JSON.stringify(settings, null, 2)
        );
        log('Settings saved to file', 'success');
    } catch (error) {
        log(`Error saving settings: ${error.message}`, 'error', error);
    }
}

/**
 * Load settings from file
 */
function loadSettings() {
    try {
        const settingsPath = path.join(__dirname, 'settings.json');
        if (fs.existsSync(settingsPath)) {
            const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

            // Update variables with saved settings
            CONFIG.EMA_PERIOD = settings.EMA_PERIOD || CONFIG.EMA_PERIOD;
            CONFIG.TIMEFRAME = settings.TIMEFRAME || CONFIG.TIMEFRAME;
            CONFIG.VOLUME_THRESHOLD = settings.VOLUME_THRESHOLD || CONFIG.VOLUME_THRESHOLD;
            CONFIG.ML_ENABLED = settings.ML_ENABLED !== undefined ? settings.ML_ENABLED : CONFIG.ML_ENABLED;

            log('Settings loaded from file', 'success');
        }
    } catch (error) {
        log(`Error loading settings: ${error.message}`, 'error', error);
    }
}

/**
 * Send main menu with Brain.js options
 * @param {string} chatId - Telegram chat ID
 */
async function sendMainMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [{ text: 'ðŸ“Š Status', callback_data: 'status' }],
            [{ text: 'âš™ï¸ Settings', callback_data: 'settings' }],
            [
                { text: 'ðŸ“ˆ Top Gainers', callback_data: 'top_gainers' },
                { text: 'ðŸ“‰ Top Losers', callback_data: 'top_losers' }
            ],
            [{ text: 'ðŸ’° Highest Volume', callback_data: 'top_volume' }],
            [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
            [
                { text: 'ðŸ§  ML Status', callback_data: 'ml_status' },
                { text: 'ðŸ”¬ Train Models', callback_data: 'train_models' }
            ],
            [
                { text: 'ðŸ“Š List Data', callback_data: 'list_data' },
                { text: 'ðŸ“¥ Collect Data', callback_data: 'collect_data' }
            ],
            [
                { text: 'ðŸ§® Memory Status', callback_data: 'memory_status' },
                { text: 'â“ Help', callback_data: 'help' }
            ]
        ]
    };

    await bot.sendMessage(chatId, '*EMA Tracker Bot Menu*\nSelect an option:', {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

/**
 * Send status update
 * @param {string} chatId - Telegram chat ID
 */
async function sendStatusUpdate(chatId) {
    try {
        const pairs = await getFuturesPairs();
        const activeWsCount = Array.from(activeWebSockets.values())
            .filter(ws => ws.readyState === WebSocket.OPEN).length;

        // Get Brain.js model stats
        const modelCount = fs.existsSync(DIRECTORIES.MODEL_PATH) ?
            fs.readdirSync(DIRECTORIES.MODEL_PATH).filter(item => fs.existsSync(path.join(DIRECTORIES.MODEL_PATH, item, 'model.json'))).length : 0;

        // Get data collection stats
        const dataPointCount = Array.from(trainingData.entries())
            .reduce((sum, [_, data]) => sum + data.length, 0);

        // Get memory usage
        const memoryUsage = process.memoryUsage();
        const heapUsedMB = (memoryUsage.heapUsed / 1024 / 1024).toFixed(2);

        const message = `*EMA Tracker Status*\n\n` +
            `*Active Configuration:*\n` +
            `- EMA Period: ${CONFIG.EMA_PERIOD}\n` +
            `- Timeframe: ${CONFIG.TIMEFRAME}\n` +
            `- Volume Threshold: ${formatVolume(CONFIG.VOLUME_THRESHOLD)}\n` +
            `- Monitoring: ${pairs.length} pairs\n` +
            `- Active WebSockets: ${activeWsCount}/${pairs.length}\n` +
            `- Last Check: ${new Date().toLocaleString()}\n\n` +
            `*Brain.js ML Status:*\n` +
            `- ML Enabled: ${CONFIG.ML_ENABLED ? 'âœ…' : 'âŒ'}\n` +
            `- Trained Models: ${modelCount}\n` +
            `- Data Points Collected: ${dataPointCount}\n\n` +
            `*System Status:*\n` +
            `- Memory Usage: ${heapUsedMB} MB\n` +
            `- Uptime: ${formatUptime(process.uptime())}\n\n` +
            `Bot is actively monitoring for EMA crossovers in real-time.`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending status update: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, 'âŒ Error fetching status');
    }
}

/**
 * Format uptime in a human-readable format
 * @param {number} seconds - Uptime in seconds
 * @returns {string} Formatted uptime
 */
function formatUptime(seconds) {
    const days = Math.floor(seconds / (3600 * 24));
    const hours = Math.floor((seconds % (3600 * 24)) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    let result = '';
    if (days > 0) result += `${days}d `;
    if (hours > 0) result += `${hours}h `;
    result += `${minutes}m`;

    return result;
}

/**
 * Send settings menu
 * @param {string} chatId - Telegram chat ID
 */
async function sendSettingsMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [
                { text: '1m', callback_data: 'timeframe_1m' },
                { text: '5m', callback_data: 'timeframe_5m' },
                { text: '15m', callback_data: 'timeframe_15m' },
                { text: '1h', callback_data: 'timeframe_1h' },
                { text: '4h', callback_data: 'timeframe_4h' }
            ],
            [
                { text: 'EMA 50', callback_data: 'ema_50' },
                { text: 'EMA 100', callback_data: 'ema_100' },
                { text: 'EMA 200', callback_data: 'ema_200' }
            ],
            [
                { text: 'Vol 50M', callback_data: 'volume_50000000' },
                { text: 'Vol 100M', callback_data: 'volume_100000000' },
                { text: 'Vol 200M', callback_data: 'volume_200000000' }
            ],
            [
                { text: CONFIG.ML_ENABLED ? 'ðŸ§  Disable ML' : 'ðŸ§  Enable ML', callback_data: 'toggle_ml' }
            ],
            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
        ]
    };

    await bot.sendMessage(chatId, `*Settings*\n\nCurrent Configuration:\n- EMA: ${CONFIG.EMA_PERIOD}\n- Timeframe: ${CONFIG.TIMEFRAME}\n- Volume Threshold: ${formatVolume(CONFIG.VOLUME_THRESHOLD)}\n- ML Enabled: ${CONFIG.ML_ENABLED ? 'âœ…' : 'âŒ'}\n\nSelect a new setting:`, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

/**
 * Send help message
 * @param {string} chatId - Telegram chat ID
 */
async function sendHelpMessage(chatId) {
    const helpText = `*EMA Tracker Bot Help*\n\n` +
        `This bot monitors Binance Futures markets for EMA crossovers and sends alerts when they occur.\n\n` +
        `*Available Commands:*\n` +
        `/menu - Show the main menu\n` +
        `/status - Check bot status\n` +
        `/settings - Configure bot settings\n` +
        `/top - View top performing coins\n` +
        `/refresh - Refresh WebSocket connections\n` +
        `/mlstatus - Check ML model performance\n` +
        `/train - Train ML models\n` +
        `/collectdata - Manually collect training data\n` +
        `/listdata - List available CSV data\n` +
        `/viewdata SYMBOL - View data for a specific symbol\n` +
        `/help - Show this help message\n\n` +
        `*How It Works:*\n` +
        `The bot uses WebSockets to track price movements in real-time and detect when price crosses above or below the ${CONFIG.EMA_PERIOD} EMA on the ${CONFIG.TIMEFRAME} timeframe for high-volume coins.\n\n` +
        `*Brain.js ML Integration:*\n` +
        `The bot collects data and trains neural network models to predict price movements after EMA crossovers. These predictions are included in the alerts to help you make more informed trading decisions.`;

    await bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
        }
    });
}

/**
 * Send top performers (gainers, losers, or by volume)
 * @param {string} chatId - Telegram chat ID
 * @param {string} type - Type of performers ('gainers', 'losers', or 'volume')
 */
async function sendTopPerformers(chatId, type = 'gainers') {
    try {
        await bot.sendMessage(chatId, 'â³ Fetching data...');

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            timeout: 10000 // 10 second timeout
        });
        let coins = response.data.filter(coin => coin.symbol.endsWith('USDT') && validateSymbol(coin.symbol));

        // Sort based on type
        if (type === 'gainers') {
            coins.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 gainers
        } else if (type === 'losers') {
            coins.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 losers
        } else if (type === 'volume') {
            coins.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            coins = coins.slice(0, 10); // Top 10 by volume
        }

        let title;
        if (type === 'gainers') title = 'ðŸ“ˆ *Top Gainers (24h)*';
        else if (type === 'losers') title = 'ðŸ“‰ *Top Losers (24h)*';
        else title = 'ðŸ’° *Highest Volume (24h)*';

        let message = `${title}\n\n`;

        coins.forEach((coin, index) => {
            const symbol = coin.symbol;
            const price = formatPrice(parseFloat(coin.lastPrice));
            const change = parseFloat(coin.priceChangePercent).toFixed(2);
            const volume = formatVolume(parseFloat(coin.quoteVolume));

            const changeEmoji = parseFloat(change) >= 0 ? 'ðŸŸ¢' : 'ðŸ”´';
            message += `${index + 1}. ${symbol}: ${price} (${changeEmoji} ${change}%) - Vol: ${volume}\n`;
        });

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“ˆ Gainers', callback_data: 'top_gainers' },
                        { text: 'ðŸ“‰ Losers', callback_data: 'top_losers' },
                        { text: 'ðŸ’° Volume', callback_data: 'top_volume' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error fetching top performers: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, 'âŒ Error fetching data');
    }
}

/**
 * Send initial startup message to Telegram
 */
async function sendStartupMessage() {
    try {
        const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
            `*Configuration:*\n` +
            `- EMA Period: ${CONFIG.EMA_PERIOD}\n` +
            `- Timeframe: ${CONFIG.TIMEFRAME}\n` +
            `- Volume Threshold: ${formatVolume(CONFIG.VOLUME_THRESHOLD)}\n` +
            `- Check Interval: ${(CONFIG.CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
            `- Alert Cooldown: ${(CONFIG.ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n` +
            `- WebSocket Monitoring: Enabled\n` +
            `- Brain.js ML: ${CONFIG.ML_ENABLED ? 'Enabled' : 'Disabled'}\n\n` +
            `Bot is now monitoring for EMA crossovers in real-time with ML predictions...`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
        log('Startup message sent to Telegram', 'success');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Started',
            `Monitoring ${CONFIG.TIMEFRAME} timeframe with ${CONFIG.EMA_PERIOD} EMA in real-time`,
            'info'
        );

        // Send the menu after startup message
        await sendMainMenu(TELEGRAM_CHAT_ID);
    } catch (error) {
        log(`Error sending startup message: ${error.message}`, 'error', error);
    }
}

/**
 * WebSocket heartbeat function to keep connections alive
 */
function startWebSocketHeartbeat() {
    // Check WebSocket connections every minute
    setInterval(() => {
        try {
            let reconnected = 0;

            for (const [symbol, ws] of activeWebSockets.entries()) {
                // If WebSocket is closed or closing, reconnect
                if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    // Only log to file, not to console
                    fs.appendFileSync(
                        path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                        `[${new Date().toISOString()}] WebSocket for ${symbol} is closed or closing. Reconnecting...\n`
                    );
                    setupSymbolWebSocket(symbol);
                    reconnected++;
                }
            }

            if (reconnected > 0) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Reconnected ${reconnected} WebSocket connections during heartbeat check\n`
                );
            }

            // Check memory usage periodically
            checkMemoryUsage();
        } catch (error) {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error in WebSocket heartbeat: ${error.message}\n`
            );
        }
    }, 60000); // Check every minute
}

// Set up message and callback query handlers
bot.on('message', handleMessage);
bot.on('callback_query', handleCallbackQuery);

// Handle process termination gracefully
process.on('SIGINT', async () => {
    try {
        log('Received SIGINT. Shutting down gracefully...', 'warning');

        // Close all WebSocket connections
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                symbol.close();
                ws.close();
                await bot.stopPolling();
                log('Bot stopped gracefully', 'info');
                process.exit();
            } catch (e) {
                log(`Error during process termination: ${error.message}`, 'error', error);
                //process.exit(1);
            }
        }

        // Save training data before exit
        saveTrainingData();

        await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Shutting Down',
            'The bot is shutting down gracefully',
            'warning'
        );

        process.exit(0);
    } catch (error) {
        log(`Error during shutdown: ${error.message}`, 'error', error);
        process.exit(1);
    }
});

// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');

    // Show desktop notification for unhandled rejection
    showDesktopNotification(
        'Error in EMA Tracker',
        'An unhandled rejection occurred. Check logs for details.',
        'error'
    );
});

/**
 * Install required packages if not already installed
 * @returns {Promise<void>}
 */
async function installRequiredPackages() {
    const { exec } = require('child_process');
    const requiredPackages = ['ws', 'brain.js', 'csv-writer']; // WebSocket, Brain.js, and CSV writer packages

    for (const pkg of requiredPackages) {
        try {
            require.resolve(pkg);
            log(`Package ${pkg} is already installed`, 'info');
        } catch (e) {
            log(`Installing required package: ${pkg}...`, 'info');

            try {
                await new Promise((resolve, reject) => {
                    exec(`npm install ${pkg}`, (error, stdout, stderr) => {
                        if (error) {
                            log(`Error installing ${pkg}: ${error.message}`, 'error', error);
                            reject(error);
                            return;
                        }
                        log(`Successfully installed ${pkg}`, 'success');
                        resolve();
                    });
                });
            } catch (error) {
                log(`Failed to install ${pkg}: ${error.message}`, 'error', error);
                throw error;
            }
        }
    }
}

/**
 * Initialize the terminal and start monitoring
 */
async function initialize() {
    try {
        // Install required packages
        await installRequiredPackages();

        // Initialize terminal and load settings
        initializeTerminal();
        loadSettings();

        console.log('\nStarting initial check...'.green);

        // Initialize ML components
        console.log('Initializing Brain.js machine learning components...'.cyan);

        // Create directories if they don't exist
        Object.values(DIRECTORIES).forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });

        // Send startup message
        await sendStartupMessage();

        await processRealtimeCandle();

        // Do initial check to populate data
        await checkEMACross();

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        //handleWebSocketReconnect();

        // Start WebSocket heartbeat
        startWebSocketHeartbeat();

        // Load ML training data
        loadTrainingData();

        // Schedule periodic saving of training data
        setInterval(saveTrainingData, 30 * 60 * 1000); // Save every 30 minutes

        // Schedule periodic memory check
        setInterval(checkMemoryUsage, 5 * 60 * 1000); // Check every 5 minutes

        // Now set flag to enable volume threshold notifications for subsequent checks
        initialLoadComplete = true;
        log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');

        // Run the check at the specified interval as a backup
        // This is in addition to the real-time WebSocket monitoring
        monitoringInterval = setInterval(async () => {
            log('Running periodic check as backup to WebSockets...', 'info');
            await checkEMACross();
        }, CONFIG.CHECK_INTERVAL);

        log('Initialization complete. Bot is now monitoring in real-time via WebSockets with Brain.js ML enhancement.', 'success');
    } catch (error) {
        log(`Failed to initialize: ${error.message}`, 'error', error);

        // Show desktop notification for startup failure
        showDesktopNotification(
            'EMA Tracker Failed to Start',
            `Error: ${error.message}`,
            'error'
        );

        // Try to send error message to Telegram
        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, `âŒ *Error Starting Bot*\n\n${error.message}`, {
                parse_mode: 'Markdown'
            });
        } catch (e) {
            log(`Could not send error message to Telegram: ${e.message}`, 'error', e);
        }
    }
}

// Start the bot
initialize();




----------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




const axios = require('axios');
const colors = require('colors');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');
const WebSocket = require('ws');
const { createObjectCsvWriter } = require('csv-writer');
const brainML = require('./ml_alternative');

let initialLoadComplete = false;
// ML configuration
let ML_ENABLED = true;

// Configuration (Consider externalizing these variables or using environment variables)
let EMA_PERIOD = parseInt(process.env.EMA_PERIOD, 10) || 200;
let TIMEFRAME = process.env.TIMEFRAME || '15m';
let VOLUME_THRESHOLD = parseInt(process.env.VOLUME_THRESHOLD, 10) || 100_000_000;
const CHECK_INTERVAL = parseInt(process.env.CHECK_INTERVAL, 10) || 5 * 60 * 1000; // 5 minutes
const ALERT_COOLDOWN = parseInt(process.env.ALERT_COOLDOWN, 10) || 15 * 60 * 1000; // 15 minutes cooldown for alerts

// Telegram configuration with your provided credentials
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Store last alert times and states for each symbol
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring

// WebSocket related variables
const activeWebSockets = new Map(); // Track active WebSocket connections
const klineCache = new Map(); // Cache for kline data
const emaCache = new Map(); // Cache for calculated EMAs
const trainingData = new Map(); // Store historical data for ML training
// Track model performance
const modelPerformance = new Map();

// ML directories
const ML_DATA_DIR = path.join(__dirname, 'ml_data');
const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
const MODEL_PATH = path.join(__dirname, 'ml_models');

// Create a log directory for persistent logging
const LOG_DIR = path.join(__dirname, 'logs');
if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR);
}

// Create ML directories
if (!fs.existsSync(ML_DATA_DIR)) {
    fs.mkdirSync(ML_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(CSV_DATA_DIR)) {
    fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(MODEL_PATH)) {
    fs.mkdirSync(MODEL_PATH, { recursive: true });
}

// Log function that writes to both console and file
function log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;

    // Console logging with colors
    switch (type) {
        case 'error':
            console.error(logMessage.red);
            break;
        case 'success':
            console.log(logMessage.green);
            break;
        case 'warning':
            console.log(logMessage.yellow);
            break;
        default:
            console.log(logMessage);
    }

    // File logging
    const logFile = path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logMessage + '\n');
}

// Check if Brain.js is available
function checkMLAvailability() {
    try {
        require('brain.js');
        log('Brain.js is available for ML predictions', 'success');
        return true;
    } catch (e) {
        try {
            // Try to install brain.js
            log('Brain.js not found, attempting to install...', 'warning');
            require('child_process').execSync('npm install brain.js csv-writer --save');
            log('Brain.js installed successfully', 'success');
            return true;
        } catch (installError) {
            log(`Failed to install Brain.js: ${installError.message}`, 'error');
            log('ML predictions will be disabled', 'warning');
            return false;
        }
    }
}

// Show desktop notification using node-notifier
function showDesktopNotification(title, message, type = 'info') {
    try {
        notifier.notify({
            title: title,
            message: message,
            sound: true,
            wait: true,
            icon: path.join(__dirname, type === 'error' ? 'error.png' :
                type === 'warning' ? 'warning.png' : 'info.png')
        });

        log(`Desktop notification shown: ${title} - ${message}`);
    } catch (error) {
        log(`Failed to show desktop notification: ${error.message}`, 'error');
    }
}

// Initialize terminal
function initializeTerminal() {
    console.clear();
    console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);
    console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
    console.log(`Configuration: ${EMA_PERIOD} EMA | ${TIMEFRAME} Timeframe | Volume > ${VOLUME_THRESHOLD.toLocaleString()}`.cyan);
    console.log(`Alert Cooldown: ${ALERT_COOLDOWN / 60000} minutes`.magenta);
    console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
    console.log(`WebSocket Real-Time Monitoring: Enabled`.green);
    console.log(`Machine Learning: ${ML_ENABLED ? 'Enabled'.green : 'Disabled'.red}`);
    console.log('='.repeat(80).dim);
    console.log('\nCROSSOVER EVENTS:'.cyan.bold);

    log(`EMA Tracker started with configuration: EMA=${EMA_PERIOD}, Timeframe=${TIMEFRAME}, Volume Threshold=${VOLUME_THRESHOLD}, ML=${ML_ENABLED}`);
}

// Helper function to format volume
function formatVolume(volume) {
    if (volume >= 1_000_000_000) {
        return (volume / 1_000_000_000).toFixed(2) + 'B';
    } else if (volume >= 1_000_000) {
        return (volume / 1_000_000).toFixed(2) + 'M';
    } else if (volume >= 1_000) {
        return (volume / 1_000).toFixed(2) + 'K';
    }
    return volume.toFixed(2);
}

// Format price with appropriate precision based on value
function formatPrice(price) {
    if (price < 0.001) return price.toFixed(8);
    if (price < 1) return price.toFixed(6);
    if (price < 100) return price.toFixed(4);
    return price.toFixed(2);
}

// Function to get 24hr stats for a symbol
async function get24HrStats(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            params: { symbol }
        });
        return {
            priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
            quoteVolume: parseFloat(response.data.quoteVolume)
        };
    } catch (error) {
        log(`Error fetching 24hr stats for ${symbol}: ${error.message}`, 'error');
        return { priceChangePercent: '0.00', quoteVolume: '0' };
    }
}

// Fetch Binance Futures pairs with 24hr quote volume above the threshold
async function getFuturesPairs() {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        const newPairs = [];

        const pairs = response.data
            .filter(pair => {
                const volume = parseFloat(pair.quoteVolume);
                const symbol = pair.symbol;

                if (volume > VOLUME_THRESHOLD) {
                    // Only track new pairs that cross threshold after initial load
                    if (initialLoadComplete && !trackedPairs.has(symbol)) {
                        newPairs.push({
                            symbol,
                            volume,
                            price: parseFloat(pair.lastPrice),
                            change: parseFloat(pair.priceChangePercent)
                        });
                    }
                    trackedPairs.add(symbol);
                    return true;
                }
                return false;
            })
            .map(pair => pair.symbol);

        // Alert for new pairs that crossed the volume threshold (only after initial load)
        if (newPairs.length > 0) {
            alertNewHighVolumePairs(newPairs);
        }

        return pairs;
    } catch (error) {
        log(`Error fetching futures pairs: ${error.message}`, 'error');
        return [];
    }
}

// Alert when new pairs cross the volume threshold
async function alertNewHighVolumePairs(newPairs) {
    for (const pair of newPairs) {
        const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
            `*Symbol:* ${pair.symbol}\n` +
            `*Volume:* ${formatVolume(pair.volume)}\n` +
            `*Price:* ${formatPrice(pair.price)}\n` +
            `*24h Change:* ${pair.change.toFixed(2)}%\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `This pair has been added to the monitoring list.`;

        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

            // Show desktop notification
            showDesktopNotification(
                'New High Volume Pair',
                `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
                'info'
            );

            log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');

            // Setup WebSocket for the new pair
            setupSymbolWebSocket(pair.symbol);
        } catch (error) {
            log(`Error sending new pair alert for ${pair.symbol}: ${error.message}`, 'error');
        }
    }
}

// Retrieve historical candlestick data for the given symbol
async function getKlines(symbol) {
    try {
        const limit = EMA_PERIOD + 100; // Request extra candles to be safe

        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: { symbol, interval: TIMEFRAME, limit: limit }
        });

        const klines = response.data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));

        // Update the kline cache
        klineCache.set(symbol, klines);

        // Calculate and cache EMA
        const closes = klines.map(k => k.close);
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        if (klines.length < EMA_PERIOD) {
            log(`Warning: Not enough candles for ${symbol}. Needed ${EMA_PERIOD}, got ${klines.length}`, 'warning');
        }

        return klines;
    } catch (error) {
        log(`Error fetching klines for ${symbol}: ${error.message}`, 'error');
        return [];
    }
}

// Calculate the EMA for an array of prices given a period
function calculateEMA(prices, period) {
    if (prices.length < period) {
        log(`Warning: Not enough prices for EMA calculation. Needed ${period}, got ${prices.length}`, 'warning');
        return [];
    }

    const k = 2 / (period + 1);
    let emaArray = [];

    // Start with the simple moving average as the first EMA
    let sma = prices.slice(0, period).reduce((sum, p) => sum + p, 0) / period;
    let ema = sma;

    // Add the first EMA (which is the SMA)
    emaArray.push(ema);

    // Calculate EMA for the remaining prices
    for (let i = period; i < prices.length; i++) {
        ema = (prices[i] - ema) * k + ema;
        emaArray.push(ema);
    }

    return emaArray;
}

// Update EMA with a new price (for real-time updates)
function updateEMA(symbol, newPrice) {
    // Get cached EMA values
    let emaValues = emaCache.get(symbol);

    // If no cached values, we need to fetch historical data first
    if (!emaValues || emaValues.length === 0) {
        log(`No cached EMA values for ${symbol}, fetching historical data...`, 'warning');
        return false;
    }

    const k = 2 / (EMA_PERIOD + 1);
    const lastEMA = emaValues[emaValues.length - 1];
    const newEMA = (newPrice - lastEMA) * k + lastEMA;

    // Add the new EMA to the cache
    emaValues.push(newEMA);

    // Keep the cache size reasonable by removing older values
    if (emaValues.length > EMA_PERIOD * 2) {
        emaValues = emaValues.slice(-EMA_PERIOD * 2);
    }

    emaCache.set(symbol, emaValues);
    return true;
}

// Send Telegram notification with enhanced formatting
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending Telegram message: ${error.message}`, 'error');

        // Retry with simpler message if parse_mode might be the issue
        try {
            const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
            await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
            log(`Sent simplified alert for ${symbol} after error`, 'warning');
        } catch (retryError) {
            log(`Failed to send even simplified message: ${retryError.message}`, 'error');
        }
    }
}

// Check if we should alert for this symbol based on direction change and cooldown
function shouldAlert(symbol, currentState) {
    const now = Date.now();
    const previousState = coinStates.get(symbol);
    const lastAlertTime = lastAlerts.get(symbol) || 0;

    if (previousState !== currentState) {
        coinStates.set(symbol, currentState);
        if (now - lastAlertTime >= ALERT_COOLDOWN) {
            lastAlerts.set(symbol, now);
            return true;
        } else {
            log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
        }
    }
    return false; // No alert if state hasn't changed or cooldown active
}

// WebSocket setup for a symbol
function setupSymbolWebSocket(symbol) {
    // Close existing connection if any
    if (activeWebSockets.has(symbol)) {
        try {
            activeWebSockets.get(symbol).close();
        } catch (e) {
            // Ignore errors when closing
        }
    }

    // Create WebSocket URL based on timeframe
    const wsSymbol = symbol.toLowerCase();
    const wsUrl = `wss://fstream.binance.com/ws/${wsSymbol}@kline_${TIMEFRAME}`;

    // Only log to file, not to console
    fs.appendFileSync(
        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
        `[${new Date().toISOString()}] Setting up WebSocket for ${symbol} on ${TIMEFRAME} timeframe\n`
    );

    try {
        const ws = new WebSocket(wsUrl);

        ws.on('open', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection established for ${symbol}\n`
            );
        });

        ws.on('message', (data) => {
            try {
                const message = JSON.parse(data);

                // Process kline data
                if (message.e === 'kline') {
                    const kline = message.k;

                    // Only process if the candle is closed or if we want to process real-time
                    if (kline.x === true) { // Candle closed
                        processClosedCandle(symbol, kline);
                    } else {
                        // Process real-time candle updates without logging unconfirmed events
                        processRealtimeCandle(symbol, kline, false); // Added parameter to suppress logging
                    }
                }
            } catch (error) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Error processing WebSocket message for ${symbol}: ${error.message}\n`
                );
            }
        });

        ws.on('error', (error) => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket error for ${symbol}: ${error.message}\n`
            );
            // Try to reconnect after a delay
            setTimeout(() => setupSymbolWebSocket(symbol), 5000);
        });

        ws.on('close', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection closed for ${symbol}\n`
            );
            // Try to reconnect after a delay if it wasn't intentionally closed
            if (trackedPairs.has(symbol)) {
                setTimeout(() => setupSymbolWebSocket(symbol), 5000);
            }
        });

        // Store the WebSocket connection
        activeWebSockets.set(symbol, ws);

        // Initialize with historical data
        getKlines(symbol).then(() => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Historical data loaded for ${symbol}\n`
            );
        }).catch(error => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error loading historical data for ${symbol}: ${error.message}\n`
            );
        });

        return ws;
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSocket for ${symbol}: ${error.message}\n`
        );
        return null;
    }
}

// Calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) {
        return 0;
    }

    const trueRanges = [];

    // Calculate True Range for each candle
    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        // True Range is the greatest of:
        // 1. Current High - Current Low
        // 2. |Current High - Previous Close|
        // 3. |Current Low - Previous Close|
        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        const trueRange = Math.max(tr1, tr2, tr3);
        trueRanges.push(trueRange);
    }

    // Calculate ATR (simple average of true ranges)
    if (trueRanges.length < period) {
        return trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    }

    // Use the last 'period' true ranges
    const recentTrueRanges = trueRanges.slice(-period);
    return recentTrueRanges.reduce((sum, tr) => sum + tr, 0) / period;
}

// Collect data for ML training
async function collectDataForML(symbol, kline) {
    try {
        if (!ML_ENABLED) return;

        // Get cached klines
        const klines = klineCache.get(symbol) || [];
        if (klines.length < 30) return; // Need enough data for indicators

        // Get closes for indicators
        const closes = klines.map(k => k.close);
        const volumes = klines.map(k => k.volume);

        // Calculate indicators
        const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
        const rsi = calculateRSI(closes);
        const macd = calculateMACD(closes);
        const bb = calculateBollingerBands(closes);
        const atr = calculateATR(klines);

        // Create data point
        const dataPoint = {
            timestamp: kline.t,
            symbol: symbol,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v),
            ema: emaCache.get(symbol)[emaCache.get(symbol).length - 1],
            ema_diff: (parseFloat(kline.c) - emaCache.get(symbol)[emaCache.get(symbol).length - 1]) /
                emaCache.get(symbol)[emaCache.get(symbol).length - 1] * 100,
            rsi: rsi[rsi.length - 1],
            macd: macd.macd[macd.macd.length - 1],
            macd_signal: macd.signal[macd.signal.length - 1],
            macd_hist: macd.histogram[macd.histogram.length - 1],
            bb_upper: bb.upper[bb.upper.length - 1],
            bb_middle: bb.middle[bb.middle.length - 1],
            bb_lower: bb.lower[bb.lower.length - 1],
            bb_width: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) /
                bb.middle[bb.middle.length - 1],
            atr: atr,
            volume_change: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
            future_price_change: null, // To be filled later
            label: null // To be filled later
        };

        // Initialize training data array for this symbol if it doesn't exist
        if (!trainingData.has(symbol)) {
            trainingData.set(symbol, []);
        }

        // Add to training data
        trainingData.get(symbol).push(dataPoint);

        // Keep training data size manageable (last 1000 candles)
        if (trainingData.get(symbol).length > 1000) {
            trainingData.set(symbol, trainingData.get(symbol).slice(-1000));
        }

        // Schedule update of future price change (after 24 hours)
        setTimeout(() => updateFuturePriceChange(symbol, kline.t), 8 * 60 * 60 * 1000);
    } catch (error) {
        log(`Error collecting ML data for ${symbol}: ${error.message}`, 'error');
    }
}

// Process a closed candle from WebSocket
async function processClosedCandle(symbol, kline) {
    try {
        // Get cached klines or initialize if not exists
        let klines = klineCache.get(symbol) || [];

        // Create new kline object
        const newKline = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
        };

        // Add new kline to cache
        klines.push(newKline);

        // Keep cache size reasonable
        if (klines.length > EMA_PERIOD * 2) {
            klines = klines.slice(-EMA_PERIOD * 2);
        }

        klineCache.set(symbol, klines);

        // Get closes for EMA calculation
        const closes = klines.map(k => k.close);

        // Calculate new EMA values
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        // Collect data for ML training
        await collectDataForML(symbol, kline);

        // Check for crossover
        if (emaValues.length >= 2) {
            const lastPrice = closes[closes.length - 1];
            const prevPrice = closes[closes.length - 2];
            const lastEMA = emaValues[emaValues.length - 1];
            const prevEMA = emaValues[emaValues.length - 2];

            checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA);
        }
    } catch (error) {
        log(`Error processing closed candle for ${symbol}: ${error.message}`, 'error');
    }
}

// Process real-time candle updates
function processRealtimeCandle(symbol, kline, logUnconfirmed = true) {
    try {
        // Get cached klines
        const klines = klineCache.get(symbol);
        if (!klines || klines.length === 0) {
            return; // No historical data yet
        }

        // Get current price
        const currentPrice = parseFloat(kline.c);

        // Get cached EMA values
        const emaValues = emaCache.get(symbol);
        if (!emaValues || emaValues.length < 2) {
            return; // Not enough EMA values yet
        }

        // Get the last closed price and EMA
        const lastClosedPrice = klines[klines.length - 1].close;
        const lastEMA = emaValues[emaValues.length - 1];

        // Determine current state (above or below)
        // Determine current state (above or below EMA)
        const prevState = lastClosedPrice > lastEMA ? 'above' : 'below';
        const currentState = currentPrice > lastEMA ? 'above' : 'below';

        // If state changed, we have a potential real-time crossover
        if (prevState !== currentState) {
            // Calculate difference percentage
            const difference = (currentPrice - lastEMA) / lastEMA * 100;

            // Only log if explicitly requested (for debugging)
            if (logUnconfirmed) {
                // Log the potential crossover but don't send alert yet
                console.log('\n');
                const crossType = currentState === 'above' ? 'up' : 'down';
                const crossLabel = crossType === 'up' ?
                    'â–²'.yellow + ' POTENTIAL UPWARD CROSSOVER '.black.bgYellow :
                    'â–¼'.yellow + ' POTENTIAL DOWNWARD CROSSOVER '.black.bgYellow;

                console.log(crossLabel + ' ' + symbol.bold);
                console.log(`  Current Price: ${formatPrice(currentPrice)[crossType === 'up' ? 'green' : 'red']}`);
                console.log(`  EMA(${EMA_PERIOD}): ${formatPrice(lastEMA).cyan}`);
                console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);
                console.log(`  Status: ${'REAL-TIME (Unconfirmed)'.yellow}`);
            }

            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Potential ${currentState === 'above' ? 'upward' : 'downward'} crossover detected for ${symbol} (unconfirmed)\n`
            );
        }
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error processing real-time candle for ${symbol}: ${error.message}\n`
        );
    }
}

// Check for crossover and send alerts if needed
async function checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA) {
    try {
        // Determine current state (above or below EMA)
        const currentState = lastPrice > lastEMA ? 'above' : 'below';
        const difference = (lastPrice - lastEMA) / lastEMA * 100;

        // Get ML prediction if available, but handle errors gracefully
        let prediction = null;
        if (ML_ENABLED) {
            try {
                // Get additional technical indicators
                const klines = klineCache.get(symbol) || [];
                if (klines.length >= 30) {
                    const closes = klines.map(k => k.close);
                    const volumes = klines.map(k => k.volume || 0);

                    // Calculate indicators
                    const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
                    const rsi = calculateRSI(closes);
                    const macd = calculateMACD(closes);
                    const bb = calculateBollingerBands(closes);
                    const atr = calculateATR(klines);

                    // Prepare features for prediction
                    const features = {
                        priceDiff: difference,
                        rsi: rsi[rsi.length - 1],
                        macdHist: macd.histogram[macd.histogram.length - 1],
                        bbWidth: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.middle[bb.middle.length - 1],
                        volumeChange: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
                        atr: atr,
                        volume24h: volumes[volumes.length - 1]
                    };

                    // Get prediction using Brain.js
                    prediction = await brainML.predictPriceChange(symbol, features);

                    if (prediction !== null) {
                        console.log(`  ML Prediction: ${prediction.toFixed(2)}% expected change`.cyan);
                    }
                }
            } catch (predictionError) {
                log(`Error getting prediction for ${symbol}: ${predictionError.message}`, 'warning');
                // Continue without prediction
            }
        }

        // Upward crossover: price crossing from below to above EMA
        if (prevPrice < prevEMA && lastPrice > lastEMA) {
            console.log('\n');
            console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'up', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'up', lastPrice, lastEMA, difference);
                }
            }
        }
        // Downward crossover: price crossing from above to below EMA
        else if (prevPrice > prevEMA && lastPrice < lastEMA) {
            console.log('\n');
            console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'down', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'down', lastPrice, lastEMA, difference);
                }
            }
        } else {
            // Update state even if no crossover
            coinStates.set(symbol, currentState);
        }
    } catch (error) {
        log(`Error checking for crossover for ${symbol}: ${error.message}`, 'error');
    }
}

// Setup WebSockets for all tracked pairs
async function setupAllWebSockets() {
    try {
        const pairs = await getFuturesPairs();

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Setting up WebSockets for ${pairs.length} pairs\n`
        );

        // Close any existing WebSockets for pairs that are no longer tracked
        for (const [symbol, ws] of activeWebSockets.entries()) {
            if (!pairs.includes(symbol)) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Closing WebSocket for ${symbol} (no longer tracked)\n`
                );
                try {
                    ws.close();
                } catch (e) {
                    // Ignore errors when closing
                }
                activeWebSockets.delete(symbol);
            }
        }

        // Setup WebSockets for all tracked pairs
        for (const symbol of pairs) {
            if (!activeWebSockets.has(symbol) || activeWebSockets.get(symbol).readyState !== WebSocket.OPEN) {
                setupSymbolWebSocket(symbol);

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] WebSocket setup completed for ${pairs.length} pairs\n`
        );
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSockets: ${error.message}\n`
        );
    }
}

// Check for EMA crossovers (traditional method, still used for initial load and periodic checks)
async function checkEMACross() {
    try {
        const pairs = await getFuturesPairs();
        const timestamp = new Date().toLocaleString();

        console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
        process.stdout.write('Processing: '.cyan);

        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair =>
            getKlines(pair)
                .then(klines => ({ pair, klines, error: null }))
                .catch(error => ({ pair, klines: [], error }))
        );

        const results = await Promise.all(klinesPromises);

        for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');

            if (error || klines.length < EMA_PERIOD) {
                if (klines.length < EMA_PERIOD) {
                    log(`Skipping ${pair}: Not enough candles (${klines.length}/${EMA_PERIOD})`, 'warning');
                }
                continue;
            }

            const closes = klines.map(k => k.close);
            const ema = calculateEMA(closes, EMA_PERIOD);

            // Make sure we have enough EMA values
            if (ema.length < 2) {
                log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
                continue;
            }

            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];

            // Check for crossover
            checkForCrossover(pair, prevPrice, lastPrice, prevEMA, lastEMA);
        }

        console.log('\n');
        console.log(`Check completed at ${timestamp}. WebSockets are now monitoring in real-time.`.gray);
        console.log('='.repeat(80).dim);
    } catch (error) {
        log(`Error in checkEMACross: ${error.message}`, 'error');
        console.error('Stack trace:', error.stack);
    }
}

// Update future price change for training data
async function updateFuturePriceChange(symbol, timestamp) {
    try {
        if (!trainingData.has(symbol)) return;

        const data = trainingData.get(symbol);
        const dataPoint = data.find(d => d.timestamp === timestamp);

        if (!dataPoint) return;

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);
        const originalPrice = dataPoint.close;

        // Calculate price change percentage
        const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);

        // Update the data point
        Point.future_price_change = priceChange;
        Point.label = priceChange >= 0 ? 1 : 0;

        log(`Updated future price change for ${symbol}: ${priceChange.toFixed(2)}%`, 'info');

        // Save training data to disk periodically
        saveTrainingData();

        // Export updated data to CSV
        if (data.filter(d => d.future_price_change !== null).length % 50 === 0) {
            // Export to CSV every 50 completed data points
            await brainML.exportToCSV(symbol, data);
        }
    } catch (error) {
        log(`Error updating future price change: ${error.message}`, 'error');
    }
}

// Function to get current price
async function getCurrentPrice(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/price', {
            params: { symbol }
        });
        return parseFloat(response.data.price);
    } catch (error) {
        log(`Error getting current price for ${symbol}: ${error.message}`, 'error');
        throw error;
    }
}

// Save training data to disk
function saveTrainingData() {
    try {
        const dataDir = path.join(__dirname, 'data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir);
        }

        // Save each symbol's data to a separate file
        for (const [symbol, data] of trainingData.entries()) {
            fs.writeFileSync(
                path.join(dataDir, `${symbol}_training.json`),
                JSON.stringify(data)
            );

            // Export to CSV if we have enough data points with outcomes
            const completedData = data.filter(d => d.future_price_change !== null);
            if (completedData.length >= 50) {
                brainML.exportToCSV(symbol, data).catch(err => {
                    log(`Error exporting CSV for ${symbol}: ${err.message}`, 'error');
                });
            }
        }

        // Save model performance data
        fs.writeFileSync(
            path.join(dataDir, 'model_performance.json'),
            JSON.stringify(Array.from(modelPerformance.entries()))
        );

        log(`Saved training data for ${trainingData.size} symbols`, 'info');
    } catch (error) {
        log(`Error saving training data: ${error.message}`, 'error');
    }
}

// Add this to the initialize function
async function updateIncompleteDataPoints() {
    log('Checking for incomplete data points from previous sessions...', 'info');
    let updatedCount = 0;
    
    for (const [symbol, data] of trainingData.entries()) {
      const incompletePoints = data.filter(d => d.future_price_change === null);
      if (incompletePoints.length > 0) {
        log(`Found ${incompletePoints.length} incomplete data points for ${symbol}`, 'info');
        
        for (const point of incompletePoints) {
          try {
            const currentPrice = await getCurrentPrice(symbol);
            const originalPrice = point.close;
            const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);
            point.future_price_change = priceChange;
            point.label = priceChange >= 0 ? 1 : 0;
            updatedCount++;
          } catch (error) {
            log(`Error updating data point for ${symbol}: ${error.message}`, 'error');
          }
        }
      }
    }
    
    if (updatedCount > 0) {
      log(`Updated ${updatedCount} incomplete data points from previous sessions`, 'success');
      saveTrainingData();
    }
  }  

// Load training data from disk
function loadTrainingData() {
    try {
        const dataDir = path.join(__dirname, 'data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir);
            return;
        }

        // Load each symbol's data
        const files = fs.readdirSync(dataDir).filter(f => f.endsWith('_training.json'));

        for (const file of files) {
            try {
                const symbol = file.replace('_training.json', '');
                const data = JSON.parse(fs.readFileSync(path.join(dataDir, file), 'utf8'));
                trainingData.set(symbol, data);
                log(`Loaded ${data.length} training points for ${symbol}`, 'info');
            } catch (e) {
                log(`Error loading data for ${file}: ${e.message}`, 'warning');
            }
        }

        // Load model performance data
        const perfFile = path.join(dataDir, 'model_performance.json');
        if (fs.existsSync(perfFile)) {
            const perfData = JSON.parse(fs.readFileSync(perfFile, 'utf8'));
            for (const [symbol, data] of perfData) {
                modelPerformance.set(symbol, data);
            }
            log(`Loaded performance data for ${modelPerformance.size} models`, 'info');
        }
    } catch (error) {
        log(`Error loading training data: ${error.message}`, 'error');
    }
}

// Function to train all models
async function trainAllModels(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§  Starting Brain.js model training. This may take some time...');

        // Get all symbols with sufficient data
        const symbolsToTrain = Array.from(trainingData.keys())
            .filter(symbol => {
                const data = trainingData.get(symbol);
                const validData = data.filter(d => d.future_price_change !== null);
                return validData.length >= 100;
            });

        if (symbolsToTrain.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No symbols have enough data for training yet.');
            return;
        }

        await bot.sendMessage(chatId, `Training models for ${symbolsToTrain.length} symbols...`);

        let trainedCount = 0;
        let failedCount = 0;

        // Train models sequentially
        for (const symbol of symbolsToTrain) {
            try {
                // Export data to CSV first
                const data = trainingData.get(symbol);
                await brainML.exportToCSV(symbol, data);

                // Train model
                const result = await brainML.trainModelForSymbol(symbol);

                if (result) {
                    trainedCount++;

                    // Update model performance tracking
                    if (!modelPerformance.has(symbol)) {
                        modelPerformance.set(symbol, {
                            predictions: 0,
                            correctPredictions: 0,
                            directionAccuracy: 0,
                            mae: result.performance.mae || 0,
                            lastTraining: new Date().toISOString(),
                            dataPoints: data.filter(d => d.future_price_change !== null).length
                        });
                    } else {
                        const perf = modelPerformance.get(symbol);
                        perf.lastTraining = new Date().toISOString();
                        perf.dataPoints = data.filter(d => d.future_price_change !== null).length;
                        perf.mae = result.performance.mae || 0;
                        perf.directionAccuracy = result.performance.directionAccuracy || 0;
                        modelPerformance.set(symbol, perf);
                    }

                    // Send progress updates every 5 models
                    if (trainedCount % 5 === 0) {
                        await bot.sendMessage(
                            chatId,
                            `Progress: ${trainedCount}/${symbolsToTrain.length} models trained`
                        );
                    }
                } else {
                    failedCount++;
                }

                // Add a small delay between training sessions
                await new Promise(resolve => setTimeout(resolve, 5000));
            } catch (error) {
                log(`Error training model for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        await bot.sendMessage(
            chatId,
            `ðŸ§  *Brain.js ML Training Complete*\n\n` +
            `âœ… Successfully trained: ${trainedCount} models\n` +
            `âŒ Failed: ${failedCount} models\n\n` +
            `Use /mlstatus to check model performance.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in trainAllModels: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error training models: ${error.message}`);
    }
}

// Enhanced Telegram alert with ML prediction
async function sendTelegramAlertWithML(symbol, crossType, price, ema, difference, prediction) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Format ML prediction with confidence emoji
        let confidenceEmoji = 'âš ï¸'; // Neutral/uncertain
        if (Math.abs(prediction) > 3) {
            confidenceEmoji = prediction > 0 ? 'ðŸ”¥' : 'â„ï¸'; // Strong signal
        } else if (Math.abs(prediction) > 1) {
            confidenceEmoji = prediction > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰'; // Moderate signal
        }

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n` +
            `*Brain.js Prediction:* ${confidenceEmoji} ${prediction.toFixed(2)}% (24h)\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, ML Prediction: ${prediction.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`ML-enhanced Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending ML-enhanced Telegram message: ${error.message}`, 'error');

        // Fall back to regular alert
        sendTelegramAlert(symbol, crossType, price, ema, difference);
    }
}

// Function to manually collect data for all tracked pairs
async function startManualDataCollection(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ“Š Starting manual data collection for all tracked pairs...');

        const pairs = await getFuturesPairs();
        if (pairs.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No pairs are currently being tracked.');
            return;
        }

        await bot.sendMessage(chatId, `Collecting data for ${pairs.length} pairs...`);

        let successCount = 0;
        let failedCount = 0;

        for (const symbol of pairs) {
            try {
                // Get historical klines
                const klines = await getKlines(symbol);
                if (klines.length < 30) {
                    log(`Skipping ${symbol}: Not enough candles`, 'warning');
                    failedCount++;
                    continue;
                }

                // Process each candle
                for (let i = 0; i < klines.length; i++) {
                    // Skip very old candles
                    if (i < klines.length - 100) continue;

                    const candle = klines[i];

                    // Create kline object in the format expected by processClosedCandle
                    const klineObj = {
                        t: candle.time,
                        o: candle.open.toString(),
                        h: candle.high.toString(),
                        l: candle.low.toString(),
                        c: candle.close.toString(),
                        v: candle.volume.toString()
                    };

                    // Process this candle
                    await processClosedCandle(symbol, klineObj);
                }

                successCount++;

                // Send progress updates
                if ((successCount + failedCount) % 10 === 0) {
                    await bot.sendMessage(
                        chatId,
                        `Progress: ${successCount + failedCount}/${pairs.length} pairs processed`
                    );
                }

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                log(`Error collecting data for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        // Save all collected data
        saveTrainingData();

        // Send completion message
        await bot.sendMessage(
            chatId,
            `ðŸ“Š *Data Collection Complete*\n\n` +
            `âœ… Successfully collected data for ${successCount} pairs\n` +
            `âŒ Failed: ${failedCount} pairs\n\n` +
            `Future price changes will be updated in 24 hours.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in manual data collection: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error during data collection: ${error.message}`);
    }
}

// Export data to CSV
async function exportToCSV(symbol, data) {
    try {
        // Create directory for this symbol if it doesn't exist
        const symbolDir = path.join(CSV_DATA_DIR, symbol);
        if (!fs.existsSync(symbolDir)) {
            fs.mkdirSync(symbolDir, { recursive: true });
        }

        const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

        // Filter out data points without future price change
        const validData = data.filter(d => d.future_price_change !== null);

        if (validData.length === 0) {
            log(`No valid data points with outcomes for ${symbol}`, 'warning');
            return;
        }

        // Create CSV writer
        const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
                { id: 'timestamp', title: 'Timestamp' },
                { id: 'open', title: 'Open' },
                { id: 'high', title: 'High' },
                { id: 'low', title: 'Low' },
                { id: 'close', title: 'Close' },
                { id: 'volume', title: 'Volume' },
                { id: 'ema', title: 'EMA' },
                { id: 'ema_diff', title: 'EMA_Diff_Pct' },
                { id: 'rsi', title: 'RSI' },
                { id: 'macd', title: 'MACD' },
                { id: 'macd_signal', title: 'MACD_Signal' },
                { id: 'macd_hist', title: 'MACD_Hist' },
                { id: 'bb_width', title: 'BB_Width' },
                { id: 'atr', title: 'ATR' },
                { id: 'volume_change', title: 'Volume_Change' },
                { id: 'future_price_change', title: 'Future_Price_Change' }
            ]
        });

        // Write data to CSV
        await csvWriter.writeRecords(validData);

        log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
        return true;
    } catch (error) {
        log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error');
        return false;
    }
}

// Send model performance data
async function sendModelPerformance(chatId) {
    try {
        if (modelPerformance.size === 0) {
            await bot.sendMessage(chatId, 'âŒ No model performance data available yet.');
            return;
        }

        let message = '*Brain.js Model Performance*\n\n';

        // Sort symbols by direction accuracy
        const sortedSymbols = Array.from(modelPerformance.keys())
            .sort((a, b) => {
                const aMetrics = modelPerformance.get(a);
                const bMetrics = modelPerformance.get(b);
                return (bMetrics.directionAccuracy || 0) - (aMetrics.directionAccuracy || 0);
            })
            .slice(0, 10); // Top 10 performing models

        for (const symbol of sortedSymbols) {
            const metrics = modelPerformance.get(symbol);
            if (!metrics.dataPoints || metrics.dataPoints < 50) continue; // Skip models with few data points

            message += `*${symbol}*\n` +
                `- Direction Accuracy: ${((metrics.directionAccuracy || 0) * 100).toFixed(2)}%\n` +
                `- Mean Absolute Error: ${(metrics.mae || 0).toFixed(4)}\n` +
                `- Data Points: ${metrics.dataPoints}\n` +
                `- Last Trained: ${new Date(metrics.lastTraining).toLocaleString()}\n\n`;
        }

        // Add information about CSV data
        const csvSymbols = fs.existsSync(CSV_DATA_DIR) ?
            fs.readdirSync(CSV_DATA_DIR).filter(item => fs.statSync(path.join(CSV_DATA_DIR, item)).isDirectory()) : [];

        if (csvSymbols.length > 0) {
            message += `\n*CSV Training Data Available*\n`;
            message += `${csvSymbols.length} symbols have CSV data for visualization.\n`;
            message += `CSV files are stored in: ${CSV_DATA_DIR}\n\n`;
            message += `You can use these CSV files with external tools for data analysis.`;
        }

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Train All Models', callback_data: 'train_models' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending model performance: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching model performance data');
    }
}

// Command handler
function handleMessage(msg) {
    const chatId = msg.chat.id;

    if (msg.text === '/start' || msg.text === '/menu') {
        sendMainMenu(chatId);
    } else if (msg.text === '/status') {
        sendStatusUpdate(chatId);
    } else if (msg.text === '/settings') {
        sendSettingsMenu(chatId);
    } else if (msg.text === '/help') {
        sendHelpMessage(chatId);
    } else if (msg.text === '/top') {
        sendTopPerformers(chatId);
    } else if (msg.text === '/refresh') {
        refreshWebSockets(chatId);
    } else if (msg.text === '/mlstatus') {
        sendModelPerformance(chatId);
    } else if (msg.text === '/train') {
        trainAllModels(chatId);
    } else if (msg.text === '/collectdata') {
        startManualDataCollection(chatId);
    } else if (msg.text === '/listdata') {
        listAvailableCSVData(chatId);
    } else if (msg.text && msg.text.startsWith('/viewdata ')) {
        const symbol = msg.text.split(' ')[1].toUpperCase();
        viewSymbolCSVData(chatId, symbol);
    }
}

// List available CSV data
async function listAvailableCSVData(chatId) {
    try {
        if (!fs.existsSync(CSV_DATA_DIR)) {
            await bot.sendMessage(chatId, 'âŒ No CSV data directory found. Run data collection first.');
            return;
        }

        const symbols = fs.readdirSync(CSV_DATA_DIR)
            .filter(item => fs.statSync(path.join(CSV_DATA_DIR, item)).isDirectory());

        if (symbols.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No CSV data available yet. Run data collection first.');
            return;
        }

        // Get data points count for each symbol
        const symbolData = [];
        for (const symbol of symbols) {
            const csvPath = path.join(CSV_DATA_DIR, symbol, `${symbol}_training_data.csv`);
            if (fs.existsSync(csvPath)) {
                const stats = fs.statSync(csvPath);
                const fileSize = (stats.size / 1024).toFixed(2) + ' KB';

                // Count lines (data points) - simple approach
                const content = fs.readFileSync(csvPath, 'utf8');
                const lines = content.split('\n').length - 1; // -1 for header

                symbolData.push({
                    symbol,
                    dataPoints: lines,
                    fileSize
                });
            }
        }

        // Sort by data points (descending)
        symbolData.sort((a, b) => b.dataPoints - a.dataPoints);

        let message = '*Available CSV Training Data*\n\n';

        for (const data of symbolData) {
            message += `*${data.symbol}*: ${data.dataPoints} data points (${data.fileSize})\n`;
        }

        message += '\nUse /viewdata SYMBOL to get details about a specific symbol\'s data.';

        // Create inline keyboard with symbols
        const keyboard = [];
        const buttonsPerRow = 3;

        for (let i = 0; i < symbolData.length; i += buttonsPerRow) {
            const row = [];
            for (let j = 0; j < buttonsPerRow && i + j < symbolData.length; j++) {
                row.push({
                    text: symbolData[i + j].symbol,
                    callback_data: `viewdata_${symbolData[i + j].symbol}`
                });
            }
            keyboard.push(row);
        }

        keyboard.push([{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]);

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        log(`Error listing CSV data: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error listing CSV data: ${error.message}`);
    }
}

// View CSV data for a specific symbol
async function viewSymbolCSVData(chatId, symbol) {
    try {
        const csvPath = path.join(CSV_DATA_DIR, symbol, `${symbol}_training_data.csv`);

        if (!fs.existsSync(csvPath)) {
            await bot.sendMessage(chatId, `âŒ No CSV data found for ${symbol}`);
            return;
        }

        // Get file stats
        const stats = fs.statSync(csvPath);
        const fileSize = (stats.size / 1024).toFixed(2) + ' KB';
        const modifiedDate = new Date(stats.mtime).toLocaleString();

        // Count lines (data points)
        const content = fs.readFileSync(csvPath, 'utf8');
        const lines = content.split('\n');
        const dataPoints = lines.length - 1; // -1 for header

        // Get a preview of the data (first 5 rows)
        const preview = lines.slice(0, 6).join('\n');

        // Calculate some basic stats from the data
        const rows = content.split('\n').slice(1).filter(row => row.trim() !== '');

        let avgPriceChange = 0;
        let positiveChanges = 0;
        let negativeChanges = 0;

        for (const row of rows) {
            const columns = row.split(',');
            if (columns.length > 15) { // Make sure we have enough columns
                const priceChange = parseFloat(columns[15]); // Future_Price_Change column
                if (!isNaN(priceChange)) {
                    avgPriceChange += priceChange;
                    if (priceChange > 0) positiveChanges++;
                    else if (priceChange < 0) negativeChanges++;
                }
            }
        }

        avgPriceChange = avgPriceChange / rows.length;

        // Create message
        let message = `*CSV Data for ${symbol}*\n\n`;
        message += `ðŸ“Š *Statistics:*\n`;
        message += `- Data Points: ${dataPoints}\n`;
        message += `- File Size: ${fileSize}\n`;
        message += `- Last Modified: ${modifiedDate}\n`;
        message += `- Avg Price Change: ${avgPriceChange.toFixed(2)}%\n`;
        message += `- Positive Changes: ${positiveChanges} (${((positiveChanges / rows.length) * 100).toFixed(2)}%)\n`;
        message += `- Negative Changes: ${negativeChanges} (${((negativeChanges / rows.length) * 100).toFixed(2)}%)\n\n`;

        // Check if model exists for this symbol
        const modelPath = path.join(MODEL_PATH, symbol, 'model.json');
        if (fs.existsSync(modelPath)) {
            message += `âœ… *Brain.js model is available for this symbol*\n\n`;
        } else {
            message += `âš ï¸ *No Brain.js model trained yet for this symbol*\n\n`;
        }

        message += `The CSV file contains the following columns:\n`;
        message += `Timestamp, Open, High, Low, Close, Volume, EMA, EMA_Diff_Pct, RSI, MACD, MACD_Signal, MACD_Hist, BB_Width, ATR, Volume_Change, Future_Price_Change\n\n`;

        message += `You can use this data with external tools for visualization and analysis.`;

        // Send message with inline keyboard
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“Š List All Data', callback_data: 'list_data' },
                        { text: 'ðŸ§  Train Model', callback_data: 'train_models' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });

        // Send CSV file
        await bot.sendDocument(chatId, csvPath, {
            caption: `CSV training data for ${symbol} with ${dataPoints} data points`
        });
    } catch (error) {
        log(`Error viewing CSV data for ${symbol}: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error viewing CSV data: ${error.message}`);
    }
}

// Refresh WebSockets command
async function refreshWebSockets(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ”„ Refreshing WebSocket connections...');

        // Close all existing WebSockets
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
            } catch (e) {
                // Ignore errors when closing
            }
            activeWebSockets.delete(symbol);
        }

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        await bot.sendMessage(chatId, 'âœ… WebSocket connections refreshed successfully!');
    } catch (error) {
        log(`Error refreshing WebSockets: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error refreshing WebSockets: ${error.message}`);
    }
}

// Callback query handler for inline buttons
async function handleCallbackQuery(callbackQuery) {
    const action = callbackQuery.data;
    const chatId = callbackQuery.message.chat.id;

    try {
        if (action === 'status') {
            await sendStatusUpdate(chatId);
        } else if (action === 'settings') {
            await sendSettingsMenu(chatId);
        } else if (action === 'top_gainers') {
            await sendTopPerformers(chatId, 'gainers');
        } else if (action === 'top_losers') {
            await sendTopPerformers(chatId, 'losers');
        } else if (action === 'top_volume') {
            await sendTopPerformers(chatId, 'volume');
        } else if (action === 'menu') {
            await sendMainMenu(chatId);
        } else if (action === 'help') {
            await sendHelpMessage(chatId);
        } else if (action === 'refresh_ws') {
            await refreshWebSockets(chatId);
        } else if (action.startsWith('timeframe_')) {
            const newTimeframe = action.replace('timeframe_', '');
            // Update the timeframe
            TIMEFRAME = newTimeframe;
            log(`Timeframe updated to ${newTimeframe}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new timeframe
            await bot.sendMessage(chatId, `âœ… Timeframe updated to ${newTimeframe}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('ema_')) {
            const newEma = parseInt(action.replace('ema_', ''), 10);
            // Update the EMA period
            EMA_PERIOD = newEma;
            log(`EMA period updated to ${newEma}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new EMA period
            await bot.sendMessage(chatId, `âœ… EMA period updated to ${newEma}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('volume_')) {
            const newVolume = parseInt(action.replace('volume_', ''), 10);
            // Update the volume threshold
            VOLUME_THRESHOLD = newVolume;
            log(`Volume threshold updated to ${newVolume}`, 'success');
            saveSettings();

            // Refresh tracked pairs based on new volume threshold
            await bot.sendMessage(chatId, `âœ… Volume threshold updated to ${formatVolume(newVolume)}. Refreshing tracked pairs...`);
            await setupAllWebSockets();

            await sendSettingsMenu(chatId);
        } else if (action === 'ml_status') {
            await sendModelPerformance(chatId);
        } else if (action === 'train_models') {
            await trainAllModels(chatId);
        } else if (action === 'list_data') {
            await listAvailableCSVData(chatId);
        } else if (action === 'collect_data') {
            await startManualDataCollection(chatId);
        } else if (action.startsWith('viewdata_')) {
            const symbol = action.replace('viewdata_', '');
            await viewSymbolCSVData(chatId, symbol);
        }

        // Answer callback query to remove loading state
        await bot.answerCallbackQuery(callbackQuery.id);
    } catch (error) {
        log(`Error handling callback query: ${error.message}`, 'error');
        await bot.answerCallbackQuery(callbackQuery.id, { text: 'An error occurred' });
    }
}

// Add this function to save settings to a file
function saveSettings() {
    try {
        const settings = {
            EMA_PERIOD,
            TIMEFRAME,
            VOLUME_THRESHOLD,
            CHECK_INTERVAL,
            ALERT_COOLDOWN,
            ML_ENABLED
        };

        fs.writeFileSync(
            path.join(__dirname, 'settings.json'),
            JSON.stringify(settings, null, 2)
        );
        log('Settings saved to file', 'success');
    } catch (error) {
        log(`Error saving settings: ${error.message}`, 'error');
    }
}

// Add this function to load settings from file
function loadSettings() {
    try {
        const settingsPath = path.join(__dirname, 'settings.json');
        if (fs.existsSync(settingsPath)) {
            const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

            // Update variables with saved settings
            EMA_PERIOD = settings.EMA_PERIOD || EMA_PERIOD;
            TIMEFRAME = settings.TIMEFRAME || TIMEFRAME;
            VOLUME_THRESHOLD = settings.VOLUME_THRESHOLD || VOLUME_THRESHOLD;
            ML_ENABLED = settings.ML_ENABLED !== undefined ? settings.ML_ENABLED : ML_ENABLED;

            log('Settings loaded from file', 'success');
        }
    } catch (error) {
        log(`Error loading settings: ${error.message}`, 'error');
    }
}

// Send main menu with Brain.js options
async function sendMainMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [{ text: 'ðŸ“Š Status', callback_data: 'status' }],
            [{ text: 'âš™ï¸ Settings', callback_data: 'settings' }],
            [
                { text: 'ðŸ“ˆ Top Gainers', callback_data: 'top_gainers' },
                { text: 'ðŸ“‰ Top Losers', callback_data: 'top_losers' }
            ],
            [{ text: 'ðŸ’° Highest Volume', callback_data: 'top_volume' }],
            [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
            [
                { text: 'ðŸ§  ML Status', callback_data: 'ml_status' },
                { text: 'ðŸ”¬ Train Models', callback_data: 'train_models' }
            ],
            [
                { text: 'ðŸ“Š List Data', callback_data: 'list_data' },
                { text: 'ðŸ“¥ Collect Data', callback_data: 'collect_data' }
            ],
            [{ text: 'â“ Help', callback_data: 'help' }]
        ]
    };

    await bot.sendMessage(chatId, '*EMA Tracker Bot Menu*\nSelect an option:', {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send status update
async function sendStatusUpdate(chatId) {
    try {
        const pairs = await getFuturesPairs();
        const activeWsCount = Array.from(activeWebSockets.values())
            .filter(ws => ws.readyState === WebSocket.OPEN).length;

        // Get Brain.js model stats
        const modelCount = fs.existsSync(MODEL_PATH) ?
            fs.readdirSync(MODEL_PATH).filter(item => fs.existsSync(path.join(MODEL_PATH, item, 'model.json'))).length : 0;

        // Get data collection stats
        const dataPointCount = Array.from(trainingData.entries())
            .reduce((sum, [_, data]) => sum + data.length, 0);

        const message = `*EMA Tracker Status*\n\n` +
            `*Active Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Monitoring: ${pairs.length} pairs\n` +
            `- Active WebSockets: ${activeWsCount}/${pairs.length}\n` +
            `- Last Check: ${new Date().toLocaleString()}\n\n` +
            `*Brain.js ML Status:*\n` +
            `- ML Enabled: ${ML_ENABLED ? 'âœ…' : 'âŒ'}\n` +
            `- Trained Models: ${modelCount}\n` +
            `- Data Points Collected: ${dataPointCount}\n\n` +
            `Bot is actively monitoring for EMA crossovers in real-time.`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending status update: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching status');
    }
}

// Send settings menu
async function sendSettingsMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [
                { text: '1m', callback_data: 'timeframe_1m' },
                { text: '5m', callback_data: 'timeframe_5m' },
                { text: '15m', callback_data: 'timeframe_15m' },
                { text: '1h', callback_data: 'timeframe_1h' },
                { text: '4h', callback_data: 'timeframe_4h' }
            ],
            [
                { text: 'EMA 50', callback_data: 'ema_50' },
                { text: 'EMA 100', callback_data: 'ema_100' },
                { text: 'EMA 200', callback_data: 'ema_200' }
            ],
            [
                { text: 'Vol 50M', callback_data: 'volume_50000000' },
                { text: 'Vol 100M', callback_data: 'volume_100000000' },
                { text: 'Vol 200M', callback_data: 'volume_200000000' }
            ],
            [
                { text: ML_ENABLED ? 'ðŸ§  Disable ML' : 'ðŸ§  Enable ML', callback_data: 'toggle_ml' }
            ],
            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
        ]
    };

    await bot.sendMessage(chatId, `*Settings*\n\nCurrent Configuration:\n- EMA: ${EMA_PERIOD}\n- Timeframe: ${TIMEFRAME}\n- Volume Threshold: ${formatVolume(VOLUME_THRESHOLD)}\n- ML Enabled: ${ML_ENABLED ? 'âœ…' : 'âŒ'}\n\nSelect a new setting:`, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send help message
async function sendHelpMessage(chatId) {
    const helpText = `*EMA Tracker Bot Help*\n\n` +
        `This bot monitors Binance Futures markets for EMA crossovers and sends alerts when they occur.\n\n` +
        `*Available Commands:*\n` +
        `/menu - Show the main menu\n` +
        `/status - Check bot status\n` +
        `/settings - Configure bot settings\n` +
        `/top - View top performing coins\n` +
        `/refresh - Refresh WebSocket connections\n` +
        `/mlstatus - Check ML model performance\n` +
        `/train - Train ML models\n` +
        `/collectdata - Manually collect training data\n` +
        `/listdata - List available CSV data\n` +
        `/viewdata SYMBOL - View data for a specific symbol\n` +
        `/help - Show this help message\n\n` +
        `*How It Works:*\n` +
        `The bot uses WebSockets to track price movements in real-time and detect when price crosses above or below the ${EMA_PERIOD} EMA on the ${TIMEFRAME} timeframe for high-volume coins.\n\n` +
        `*Brain.js ML Integration:*\n` +
        `The bot collects data and trains neural network models to predict price movements after EMA crossovers. These predictions are included in the alerts to help you make more informed trading decisions.`;

    await bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
        }
    });
}

// Send top performers (gainers, losers, or by volume)
async function sendTopPerformers(chatId, type = 'gainers') {
    try {
        await bot.sendMessage(chatId, 'â³ Fetching data...');

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        let coins = response.data.filter(coin => coin.symbol.endsWith('USDT'));

        // Sort based on type
        if (type === 'gainers') {
            coins.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 gainers
        } else if (type === 'losers') {
            coins.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 losers
        } else if (type === 'volume') {
            coins.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            coins = coins.slice(0, 10); // Top 10 by volume
        }

        let title;
        if (type === 'gainers') title = 'ðŸ“ˆ *Top Gainers (24h)*';
        else if (type === 'losers') title = 'ðŸ“‰ *Top Losers (24h)*';
        else title = 'ðŸ’° *Highest Volume (24h)*';

        let message = `${title}\n\n`;

        coins.forEach((coin, index) => {
            const symbol = coin.symbol;
            const price = formatPrice(parseFloat(coin.lastPrice));
            const change = parseFloat(coin.priceChangePercent).toFixed(2);
            const volume = formatVolume(parseFloat(coin.quoteVolume));

            const changeEmoji = parseFloat(change) >= 0 ? 'ðŸŸ¢' : 'ðŸ”´';
            message += `${index + 1}. ${symbol}: ${price} (${changeEmoji} ${change}%) - Vol: ${volume}\n`;
        });

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“ˆ Gainers', callback_data: 'top_gainers' },
                        { text: 'ðŸ“‰ Losers', callback_data: 'top_losers' },
                        { text: 'ðŸ’° Volume', callback_data: 'top_volume' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error fetching top performers: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching data');
    }
}

// Send initial startup message to Telegram
async function sendStartupMessage() {
    try {
        const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
            `*Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Check Interval: ${(CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
            `- Alert Cooldown: ${(ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n` +
            `- WebSocket Monitoring: Enabled\n` +
            `- Brain.js ML: ${ML_ENABLED ? 'Enabled' : 'Disabled'}\n\n` +
            `Bot is now monitoring for EMA crossovers in real-time with ML predictions...`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
        log('Startup message sent to Telegram', 'success');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Started',
            `Monitoring ${TIMEFRAME} timeframe with ${EMA_PERIOD} EMA in real-time`,
            'info'
        );

        // Send the menu after startup message
        await sendMainMenu(TELEGRAM_CHAT_ID);
    } catch (error) {
        log(`Error sending startup message: ${error.message}`, 'error');
    }
}

// WebSocket heartbeat function to keep connections alive
function startWebSocketHeartbeat() {
    // Check WebSocket connections every minute
    setInterval(() => {
        try {
            let reconnected = 0;

            for (const [symbol, ws] of activeWebSockets.entries()) {
                // If WebSocket is closed or closing, reconnect
                if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    // Only log to file, not to console
                    fs.appendFileSync(
                        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                        `[${new Date().toISOString()}] WebSocket for ${symbol} is closed or closing. Reconnecting...\n`
                    );
                    setupSymbolWebSocket(symbol);
                    reconnected++;
                }
            }

            if (reconnected > 0) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Reconnected ${reconnected} WebSocket connections during heartbeat check\n`
                );
            }
        } catch (error) {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error in WebSocket heartbeat: ${error.message}\n`
            );
        }
    }, 60000); // Check every minute
}

// Set up message and callback query handlers
bot.on('message', handleMessage);
bot.on('callback_query', handleCallbackQuery);

// Handle process termination gracefully
process.on('SIGINT', async () => {
    try {
        log('Received SIGINT. Shutting down gracefully...', 'warning');

        // Close all WebSocket connections
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
                log(`Closed WebSocket for ${symbol}`, 'info');
            } catch (e) {
                // Ignore errors when closing
            }
        }

        await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Shutting Down',
            'The bot is shutting down gracefully',
            'warning'
        );

        process.exit(0);
    } catch (error) {
        log(`Error during shutdown: ${error.message}`, 'error');
        process.exit(1);
    }
});

// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');

    // Show desktop notification for unhandled rejection
    showDesktopNotification(
        'Error in EMA Tracker',
        'An unhandled rejection occurred. Check logs for details.',
        'error'
    );
});

// Initialize Brain.js ML module
const brainML = {
    trainModelForSymbol: async function (symbol) {
        try {
            // Check if we have enough data
            if (!trainingData.has(symbol)) {
                log(`No training data for ${symbol}`, 'warning');
                return null;
            }

            const data = trainingData.get(symbol);
            const validData = data.filter(d => d.future_price_change !== null);

            if (validData.length < 100) {
                log(`Not enough valid data for ${symbol}: ${validData.length} points`, 'warning');
                return null;
            }

            log(`Training Brain.js model for ${symbol} with ${validData.length} data points`, 'info');

            // Import the ml_alternative.js module
            const ml_alternative = require('./ml_alternative');

            // Train the model using Brain.js
            const result = await ml_alternative.trainModelForSymbol(symbol);

            if (result) {
                log(`Successfully trained Brain.js model for ${symbol}`, 'success');
                return result;
            } else {
                log(`Failed to train Brain.js model for ${symbol}`, 'error');
                return null;
            }
        } catch (error) {
            log(`Error training Brain.js model for ${symbol}: ${error.message}`, 'error');
            return null;
        }
    },

    predictPriceChange: async function (symbol, features) {
        try {
            // Import the ml_alternative.js module
            const ml_alternative = require('./ml_alternative');

            // Make prediction using Brain.js
            const prediction = await ml_alternative.predictPriceChange(symbol, features);

            return prediction;
        } catch (error) {
            log(`Error making Brain.js prediction for ${symbol}: ${error.message}`, 'error');
            return null;
        }
    },

    exportToCSV: async function (symbol, data) {
        try {
            // Create CSV data directory if it doesn't exist
            const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
            if (!fs.existsSync(CSV_DATA_DIR)) {
                fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
            }

            // Create directory for this symbol if it doesn't exist
            const symbolDir = path.join(CSV_DATA_DIR, symbol);
            if (!fs.existsSync(symbolDir)) {
                fs.mkdirSync(symbolDir, { recursive: true });
            }

            const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

            // Filter out data points without future price change
            const validData = data.filter(d => d.future_price_change !== null);

            if (validData.length === 0) {
                log(`No valid data points with outcomes for ${symbol}`, 'warning');
                return false;
            }

            // Create CSV content
            let csvContent = 'timestamp,open,high,low,close,volume,ema,ema_diff,rsi,macd,macd_signal,macd_hist,bb_width,volume_change,future_price_change\n';

            for (const point of validData) {
                csvContent += `${point.timestamp},${point.open},${point.high},${point.low},${point.close},${point.volume},${point.ema},${point.ema_diff},${point.rsi},${point.macd || 0},${point.macd_signal || 0},${point.macd_hist || 0},${point.bb_width},${point.volume_change || 0},${point.future_price_change}\n`;
            }

            // Write to file
            fs.writeFileSync(csvPath, csvContent);

            log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
            return true;
        } catch (error) {
            log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error');
            return false;
        }
    }
};

// Calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) {
        return 0;
    }

    const trueRanges = [];

    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        // True Range is the greatest of:
        // 1. Current High - Current Low
        // 2. |Current High - Previous Close|
        // 3. |Current Low - Previous Close|
        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        const trueRange = Math.max(tr1, tr2, tr3);
        trueRanges.push(trueRange);
    }

    // Calculate simple moving average of true ranges
    if (trueRanges.length < period) {
        return trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    }

    const atr = trueRanges.slice(-period).reduce((sum, tr) => sum + tr, 0) / period;
    return atr;
}

// Install required packages if not already installed
async function installRequiredPackages() {
    const { exec } = require('child_process');
    const requiredPackages = ['ws', 'brain.js']; // WebSocket and Brain.js packages

    for (const pkg of requiredPackages) {
        try {
            require.resolve(pkg);
            log(`Package ${pkg} is already installed`, 'info');
        } catch (e) {
            log(`Installing required package: ${pkg}...`, 'info');

            try {
                await new Promise((resolve, reject) => {
                    exec(`npm install ${pkg}`, (error, stdout, stderr) => {
                        if (error) {
                            log(`Error installing ${pkg}: ${error.message}`, 'error');
                            reject(error);
                            return;
                        }
                        log(`Successfully installed ${pkg}`, 'success');
                        resolve();
                    });
                });
            } catch (error) {
                log(`Failed to install ${pkg}: ${error.message}`, 'error');
                throw error;
            }
        }
    }
}

// Initialize the terminal and start monitoring
async function initialize() {
    try {
        // Install required packages
        await installRequiredPackages();

        // Initialize terminal and load settings
        initializeTerminal();
        loadSettings();

        console.log('\nStarting initial check...'.green);

        // Initialize ML components
        console.log('Initializing Brain.js machine learning components...'.cyan);

        // Create models directory if it doesn't exist
        const modelsDir = path.join(__dirname, 'ml_models');
        if (!fs.existsSync(modelsDir)) {
            fs.mkdirSync(modelsDir, { recursive: true });
        }

        // Create CSV data directory if it doesn't exist
        const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
        if (!fs.existsSync(CSV_DATA_DIR)) {
            fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
        }

        // Send startup message
        await sendStartupMessage();

        // Do initial check to populate data
        await checkEMACross();

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        // Start WebSocket heartbeat
        startWebSocketHeartbeat();

        // Load ML training data
        loadTrainingData();

        await updateIncompleteDataPoints();

        // Schedule periodic saving of training data
        setInterval(saveTrainingData, 30 * 60 * 1000); // Save every 30 minutes

        // Now set flag to enable volume threshold notifications for subsequent checks
        initialLoadComplete = true;
        log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');

        // Run the check at the specified interval as a backup
        // This is in addition to the real-time WebSocket monitoring
        monitoringInterval = setInterval(async () => {
            log('Running periodic check as backup to WebSockets...', 'info');
            await checkEMACross();
        }, CHECK_INTERVAL);

        log('Initialization complete. Bot is now monitoring in real-time via WebSockets with Brain.js ML enhancement.', 'success');
    } catch (error) {
        log(`Failed to initialize: ${error.message}`, 'error');

        // Show desktop notification for startup failure
        showDesktopNotification(
            'EMA Tracker Failed to Start',
            `Error: ${error.message}`,
            'error'
        );

        // Try to send error message to Telegram
        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, `âŒ *Error Starting Bot*\n\n${error.message}`, {
                parse_mode: 'Markdown'
            });
        } catch (e) {
            log(`Could not send error message to Telegram: ${e.message}`, 'error');
        }
    }
}

// Start the bot
initialize();


-------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------


/**
 * EMA Tracker with Machine Learning
 * A real-time cryptocurrency price tracker with EMA crossover detection and ML predictions
 */

// Core dependencies
const axios = require('axios');
const colors = require('colors');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');
const WebSocket = require('ws');
const { createObjectCsvWriter } = require('csv-writer');
const brain = require('brain.js');
const os = require('os');

// Custom modules
const technicalIndicators = require('./technical_indicators');
const { mlModel } = require('./ml_alternative');
// node.js
const { startWatcher } = require('./node1.js');
const { initializeMLOS } = require('./ml_model');



// Configuration and state managementT
const CONFIG = {
    // Default configuration (will be overridden by settings.json if available)
    EMA_PERIOD: parseInt(process.env.EMA_PERIOD, 10) || 200,
    TIMEFRAME: process.env.TIMEFRAME || '5m',
    VOLUME_THRESHOLD: parseInt(process.env.VOLUME_THRESHOLD, 10) || 100_000_000,
    CHECK_INTERVAL: parseInt(process.env.CHECK_INTERVAL, 10) || 15 * 60 * 1000, // 15 minutes
    ALERT_COOLDOWN: parseInt(process.env.ALERT_COOLDOWN, 10) || 15 * 60 * 1000, // 15 minutes
    ML_ENABLED: true,
    MAX_WEBSOCKET_RECONNECT_ATTEMPTS: 5,
    WEBSOCKET_RECONNECT_DELAY: 5000, // 5 seconds
    MAX_MEMORY_USAGE_MB: 900, // Maximum memory usage in MB
    MAX_CACHE_SIZE: 1000, // Maximum number of items in caches
};


// Telegram configuration
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// State tracking
let initialLoadComplete = false;
let dataCollectionInProgress = false;
let monitoringInterval = null;

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Caches and state management
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring
const activeWebSockets = new Map(); // Track active WebSocket connections
const webSocketReconnectAttempts = new Map(); // Track reconnection attempts
const klineCache = new Map(); // Cache for kline data
const emaCache = new Map(); // Cache for calculated EMAs
const trainingData = new Map(); // Store historical data for ML training
const modelPerformance = new Map(); // Track model performance

// Directories
const DIRECTORIES = {
    ML_DATA: path.join(__dirname, 'ml_data'),
    CSV_DATA: path.join(__dirname, 'csv_data'),
    MODEL_PATH: path.join(__dirname, 'ml_models'),
    LOG_DIR: path.join(__dirname, 'logs'),
    DATA_DIR: path.join(__dirname, 'data'),
};

// // Create required directories
// Object.values(DIRECTORIES).forEach(dir => {
//     if (!fs.existsSync(dir)) {
//         fs.mkdirSync(dir, { recursive: true });
//     }
// });


const mlModule = initializeMLOS(CONFIG, DIRECTORIES);


/**
 * Enhanced logging with severity levels and structured format
 * @param {string} message - The message to log
 * @param {string} type - Log type (info, success, warning, error)
 * @param {Object} details - Additional details for the log
 */
function log(message, type = 'info', details = null) {
    const timestamp = new Date().toISOString();
    let logMessage = `[${timestamp}] [${type.toUpperCase()}] ${message}`;

    // Add details if available
    if (details) {
        if (details instanceof Error) {
            logMessage += `\nStack: ${details.stack}`;
        } else if (typeof details === 'object') {
            try {
                logMessage += `\nDetails: ${JSON.stringify(details)}`;
            } catch (e) {
                logMessage += `\nDetails: [Object]`;
            }
        } else {
            logMessage += `\nDetails: ${details}`;
        }
    }

    // Console logging with colors
    switch (type) {
        case 'error':
            console.error(logMessage.red);
            break;
        case 'success':
            console.log(logMessage.green);
            break;
        case 'warning':
            console.log(logMessage.yellow);
            break;
        default:
            console.log(logMessage);
    }

    // File logging with rotation
    try {
        const today = new Date().toISOString().split('T')[0];
        const logFile = path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${today}.log`);

        // Check log file size for rotation
        let stats;
        try {
            stats = fs.statSync(logFile);
        } catch (e) {
            // File doesn't exist yet
        }

        // If log file is larger than 10MB, rotate it
        if (stats && stats.size > 10 * 1024 * 1024) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            fs.renameSync(logFile, path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${today}-${timestamp}.log`));
        }

        fs.appendFileSync(logFile, logMessage + '\n');
    } catch (error) {
        console.error(`Failed to write to log file: ${error.message}`.red);
    }
}

/**
 * Validate symbol to prevent security issues
 * @param {string} symbol - The symbol to validate
 * @returns {boolean} True if symbol is valid, false otherwise
 */
function validateSymbol(symbol) {
    // Only allow alphanumeric characters and limited special chars
    if (!symbol || typeof symbol !== 'string' || !/^[A-Z0-9]+$/.test(symbol)) {
        log(`Invalid symbol format: ${symbol}`, 'error');
        return false;
    }
    return true;
}

/**
 * Show desktop notification using node-notifier
 * @param {string} title - Notification title
 * @param {string} message - Notification message
 * @param {string} type - Notification type (info, warning, error)
 */
function showDesktopNotification(title, message, type = 'info') {
    try {
        notifier.notify({
            title: title,
            message: message,
            sound: true,
            wait: true,
            icon: path.join(__dirname, type === 'error' ? 'error.png' :
                type === 'warning' ? 'warning.png' : 'info.png')
        });

        log(`Desktop notification shown: ${title} - ${message}`);
    } catch (error) {
        log(`Failed to show desktop notification: ${error.message}`, 'error', error);
    }
}

/**
 * Initialize terminal with application header
 */
function initializeTerminal() {
    console.clear();
    console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);

    const health = mlModule.systemHealthCheck();
    console.log(`System Health: ${health.memory.usage}% RAM Used | CPU Load: ${health.cpu.load[0].toFixed(2)}`.cyan);

    console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
    console.log(`Configuration: ${CONFIG.EMA_PERIOD} EMA | ${CONFIG.TIMEFRAME} Timeframe | Volume > ${CONFIG.VOLUME_THRESHOLD.toLocaleString()}`.cyan);
    console.log(`Alert Cooldown: ${CONFIG.ALERT_COOLDOWN / 60000} minutes`.magenta);
    console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
    console.log(`WebSocket Real-Time Monitoring: Enabled`.green);
    console.log(`Machine Learning: ${CONFIG.ML_ENABLED ? 'Enabled'.green : 'Disabled'.red}`);
    console.log('='.repeat(80).dim);
    console.log('\nCROSSOVER EVENTS:'.cyan.bold);

    log(`EMA Tracker started with configuration: EMA=${CONFIG.EMA_PERIOD}, Timeframe=${CONFIG.TIMEFRAME}, Volume Threshold=${CONFIG.VOLUME_THRESHOLD}, ML=${CONFIG.ML_ENABLED}`);
}



/**
 * Helper function to format volume
 * @param {number} volume - Volume to format
 * @returns {string} Formatted volume
 */
function formatVolume(volume) {
    if (volume >= 1_000_000_000) {
        return (volume / 1_000_000_000).toFixed(2) + 'B';
    } else if (volume >= 1_000_000) {
        return (volume / 1_000_000).toFixed(2) + 'M';
    } else if (volume >= 1_000) {
        return (volume / 1_000).toFixed(2) + 'K';
    }
    return volume.toFixed(2);
}

/**
 * Format price with appropriate precision based on value
 * @param {number} price - Price to format
 * @returns {string} Formatted price
 */
function formatPrice(price) {
    if (price < 0.001) return price.toFixed(8);
    if (price < 1) return price.toFixed(6);
    if (price < 100) return price.toFixed(4);
    return price.toFixed(2);
}

/**
 * Get 24hr stats for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<Object>} 24hr stats
 */
async function get24HrStats(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            return { priceChangePercent: '0.00', quoteVolume: '0' };
        }

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            params: { symbol },
            timeout: 10000 // 10 second timeout
        });

        return {
            priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
            quoteVolume: parseFloat(response.data.quoteVolume)
        };
    } catch (error) {
        log(`Error fetching 24hr stats for ${symbol}: ${error.message}`, 'error', error);
        return { priceChangePercent: '0.00', quoteVolume: '0' };
    }
}

/**
 * Fetch Binance Futures pairs with 24hr quote volume above the threshold
 * @returns {Promise<string[]>} Array of symbol names
 */
async function getFuturesPairs() {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            timeout: 15000 // 15 second timeout
        });

        const newPairs = [];

        const pairs = response.data
            .filter(pair => {
                const volume = parseFloat(pair.quoteVolume);
                const symbol = pair.symbol;

                if (volume > CONFIG.VOLUME_THRESHOLD) {
                    // Only track new pairs that cross threshold after initial load
                    if (initialLoadComplete && !trackedPairs.has(symbol)) {
                        newPairs.push({
                            symbol,
                            volume,
                            price: parseFloat(pair.lastPrice),
                            change: parseFloat(pair.priceChangePercent)
                        });
                    }
                    trackedPairs.add(symbol);
                    return true;
                }
                return false;
            })
            .map(pair => pair.symbol);

        // Alert for new pairs that crossed the volume threshold (only after initial load)
        if (newPairs.length > 0) {
            alertNewHighVolumePairs(newPairs);
        }

        return pairs;
    } catch (error) {
        log(`Error fetching futures pairs: ${error.message}`, 'error', error);
        return [];
    }
}

/**
 * Alert when new pairs cross the volume threshold
 * @param {Array<Object>} newPairs - Array of new high volume pairs
 */
async function alertNewHighVolumePairs(newPairs) {
    for (const pair of newPairs) {
        if (!validateSymbol(pair.symbol)) {
            continue;
        }

        const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
            `*Symbol:* ${pair.symbol}\n` +
            `*Volume:* ${formatVolume(pair.volume)}\n` +
            `*Price:* ${formatPrice(pair.price)}\n` +
            `*24h Change:* ${pair.change.toFixed(2)}%\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `This pair has been added to the monitoring list.` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

            // Show desktop notification
            showDesktopNotification(
                'New High Volume Pair',
                `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
                'info'
            );

            log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');

            // Setup WebSocket for the new pair
            setupSymbolWebSocket(pair.symbol);
        } catch (error) {
            log(`Error sending new pair alert for ${pair.symbol}: ${error.message}`, 'error', error);
        }
    }
}

/**
 * Retrieve historical candlestick data for the given symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<Array>} Array of candlestick data
 */
async function getKlines(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            return [];
        }

        const limit = CONFIG.EMA_PERIOD + 100; // Request extra candles to be safe

        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: { symbol, interval: CONFIG.TIMEFRAME, limit: limit },
            timeout: 15000 // 15 second timeout
        });

        const klines = response.data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));

        // Update the kline cache with size limit
        if (klineCache.size > CONFIG.MAX_CACHE_SIZE) {
            // Remove oldest entry
            const oldestKey = klineCache.keys().next().value;
            klineCache.delete(oldestKey);
        }
        klineCache.set(symbol, klines);

        // Calculate and cache EMA
        const closes = klines.map(k => k.close);
        const emaValues = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);

        // Update EMA cache with size limit
        if (emaCache.size > CONFIG.MAX_CACHE_SIZE) {
            // Remove oldest entry
            const oldestKey = emaCache.keys().next().value;
            emaCache.delete(oldestKey);
        }
        emaCache.set(symbol, emaValues);

        if (klines.length < CONFIG.EMA_PERIOD) {
            log(`Warning: Not enough candles for ${symbol}. Needed ${CONFIG.EMA_PERIOD}, got ${klines.length}`, 'warning');
        }

        return klines;
    } catch (error) {
        log(`Error fetching klines for ${symbol}: ${error.message}`, 'error', error);
        return [];
    }
}

/**
 * Update EMA with a new price (for real-time updates)
 * @param {string} symbol - The trading pair symbol
 * @param {number} newPrice - The new price to update EMA with
 * @returns {boolean} Success status
 */
function updateEMA(symbol, newPrice) {
    try {
        // Get cached EMA values
        let emaValues = emaCache.get(symbol);

        // If no cached values, we need to fetch historical data first
        if (!emaValues || emaValues.length === 0) {
            log(`No cached EMA values for ${symbol}, fetching historical data...`, 'warning');
            return false;
        }

        const k = 2 / (CONFIG.EMA_PERIOD + 1);
        const lastEMA = emaValues[emaValues.length - 1];
        const newEMA = (newPrice - lastEMA) * k + lastEMA;

        // Add the new EMA to the cache
        emaValues.push(newEMA);

        // Keep the cache size reasonable by removing older values
        if (emaValues.length > CONFIG.EMA_PERIOD * 2) {
            emaValues = emaValues.slice(-CONFIG.EMA_PERIOD * 2);
        }

        emaCache.set(symbol, emaValues);
        return true;
    } catch (error) {
        log(`Error updating EMA for ${symbol}: ${error.message}`, 'error', error);
        return false;
    }
}

/**
 * Send Telegram notification with enhanced formatting
 * @param {string} symbol - The trading pair symbol
 * @param {string} crossType - Type of crossover ('up' or 'down')
 * @param {number} price - Current price
 * @param {number} ema - Current EMA value
 * @param {number} difference - Percentage difference between price and EMA
 */
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // ML Prediction
        let predictionText = '';
        if (CONFIG.ML_ENABLED) {
            const prediction = makePrediction(symbol); //Call makePrediction here
            predictionText = `\n*ML Prediction:* ${prediction.toUpperCase()}\n`;
        }

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${CONFIG.EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${CONFIG.TIMEFRAME}\n\n` +
            predictionText +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending Telegram message: ${error.message}`, 'error', error);

        // Retry with simpler message if parse_mode might be the issue
        try {
            const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
            await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
            log(`Sent simplified alert for ${symbol} after error`, 'warning');
        } catch (retryError) {
            log(`Failed to send even simplified message: ${retryError.message}`, 'error', retryError);
        }
    }
}

/**
 * Check if we should alert for this symbol based on direction change and cooldown
 * @param {string} symbol - The trading pair symbol
 * @param {string} currentState - Current state ('above' or 'below')
 * @returns {boolean} Whether to send an alert
 */
function shouldAlert(symbol, currentState) {
    // Don't send alerts during data collection
    if (dataCollectionInProgress) {
        return false;
    }

    const now = Date.now();
    const previousState = coinStates.get(symbol);
    const lastAlertTime = lastAlerts.get(symbol) || 0;

    if (previousState !== currentState) {
        coinStates.set(symbol, currentState);
        if (now - lastAlertTime >= CONFIG.ALERT_COOLDOWN) {
            lastAlerts.set(symbol, now);
            return true;
        } else {
            log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
        }
    }
    return false; // No alert if state hasn't changed or cooldown active
}


/**
 * WebSocket setup for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {WebSocket|null} The WebSocket connection
 */
// Add a connection state tracking map
const wsConnectionStates = new Map(); // Possible states: 'connecting', 'open', 'closing', 'closed'

function setupSymbolWebSocket(symbol) {
    // Close existing connection if any, but only if it's not in 'connecting' state
    if (activeWebSockets.has(symbol)) {
        const existingWs = activeWebSockets.get(symbol);
        const connectionState = wsConnectionStates.get(symbol) || 'unknown';

        // Only try to close if it's not already connecting (to avoid the error)
        if (connectionState !== 'connecting') {
            try {
                existingWs.close();
            } catch (e) {
                // Ignore errors when closing
            }
        }
    }

    // // Create WebSocket URL based on timeframe
    // function setupSymbolWebSocket(symbol) {
    //     if (!validateSymbol(symbol)) return null;

    //     // Close existing connection if any
    //     if (activeWebSockets.has(symbol)) {
    //         const existingWs = activeWebSockets.get(symbol);
    //         const connectionState = wsConnectionStates.get(symbol) || 'unknown';

    //         // Only try to close if not already connecting
    //         if (connectionState !== 'connecting') {
    //             try {
    //                 existingWs.close();
    //             } catch (e) {
    //                 // Ignore errors when closing
    //             }
    //         }
    //     }

    // Set connection state to connecting
    wsConnectionStates.set(symbol, 'connecting');

    const ws = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${CONFIG.TIMEFRAME}`);

    // Add connection timeout
    const connectionTimeout = setTimeout(() => {
        if (wsConnectionStates.get(symbol) === 'connecting') {
            log(`WebSocket connection timeout for ${symbol}`, 'warning');
            ws.terminate();
            handleWebSocketReconnect(symbol);
        }
    }, 10000);

    ws.on('open', () => {
        clearTimeout(connectionTimeout);
        wsConnectionStates.set(symbol, 'open');
        webSocketReconnectAttempts.set(symbol, 0);
    });

    // ws.on('message', (data) => {
    //     // Handle incoming WebSocket messages
    //     handleWebSocketMessage(symbol, data);
    // });

    ws.on('message', (data) => {
        try {
            const message = JSON.parse(data);
            if (message.k) {  // kline data
                const kline = message.k;

                // Process real-time data
                if (kline.x) {  // If candle closed
                    processClosedCandle(symbol, kline);
                } else {  // Real-time update
                    processRealtimeCandle(symbol, kline, true);
                }
            }
        } catch (error) {
            log(`Error processing WebSocket message for ${symbol}: ${error.message}`, 'error', error);
        }
    });




    ws.on('close', () => {
        wsConnectionStates.set(symbol, 'closed');
        //handleWebSocketReconnect(symbol);
    });

    ws.on('error', (error) => {
        log(`WebSocket error for ${symbol}: ${error.message}`, 'error', error);
        ws.terminate();
        handleWebSocketReconnect(symbol);
    });

    activeWebSockets.set(symbol, ws);
    return ws;
}


async function handleWebSocketMessage(symbol, data) {
    try {
        const message = JSON.parse(data);

        if (message.e === 'kline') {
            const kline = message.k;
            const currentPrice = parseFloat(kline.c);
            const lastEMA = emaCache.get(symbol)?.slice(-1)[0];

            if (lastEMA) {
                const prevState = coinStates.get(symbol);
                const currentState = currentPrice > lastEMA ? 'above' : 'below';

                // Check for potential crossover
                if (prevState !== currentState) {
                    const difference = ((currentPrice - lastEMA) / lastEMA) * 100;

                    // Update EMA with new price
                    if (updateEMA(symbol, currentPrice)) {
                        // If it's a confirmed crossover, send alert
                        if (shouldAlert(symbol, currentState)) {
                            await sendTelegramAlert(symbol,
                                currentState === 'above' ? 'up' : 'down',
                                currentPrice,
                                lastEMA,
                                difference);
                        }
                    }
                }
            }
        }
    } catch (error) {
        log(`Error handling WebSocket message: ${error.message}`, 'error', error);
    }
}
/**
 * Handle WebSocket reconnection with exponential backoff
 * @param {string} symbol - The trading pair symbol
 */
function handleWebSocketReconnect(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        const attempts = webSocketReconnectAttempts.get(symbol) || 0;

        if (attempts >= CONFIG.MAX_WEBSOCKET_RECONNECT_ATTEMPTS) {
            log(`Maximum reconnect attempts reached for ${symbol}, giving up`, 'warning');
            return;
        }

        // Exponential backoff: 5s, 10s, 20s, 40s, 80s
        const delay = CONFIG.WEBSOCKET_RECONNECT_DELAY * Math.pow(2, attempts);

        log(`Scheduling WebSocket reconnect for ${symbol} in ${delay}ms (attempt ${attempts + 1}/${CONFIG.MAX_WEBSOCKET_RECONNECT_ATTEMPTS})`, 'info');

        // Increment reconnect attempts
        webSocketReconnectAttempts.set(symbol, attempts + 1);

        setTimeout(() => {
            if (trackedPairs.has(symbol)) {
                log(`Attempting to reconnect WebSocket for ${symbol}`, 'info');
                setupSymbolWebSocket(symbol);
            }
        }, delay);
    } catch (error) {
        log(`Error in WebSocket reconnect handler: ${error.message}`, 'error', error);
    }
}

/**
 * Collect data for ML training
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 */
async function collectDataForML(symbol, kline) {
    try {
        if (!CONFIG.ML_ENABLED || !validateSymbol(symbol)) {
            return;
        }

        // Get cached klines
        const klines = klineCache.get(symbol) || [];
        if (klines.length < 30) return; // Need enough data for indicators

        // Get closes for indicators
        const closes = klines.map(k => k.close);
        const volumes = klines.map(k => k.volume);

        // Calculate indicators
        const rsi = technicalIndicators.calculateRSI(closes);
        const macd = technicalIndicators.calculateMACD(closes);
        const bb = technicalIndicators.calculateBollingerBands(closes);
        const atr = technicalIndicators.calculateATR(klines);

        // Create data point
        const dataPoint = {
            timestamp: kline.t,
            symbol: symbol,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v),
            ema: emaCache.get(symbol)[emaCache.get(symbol).length - 1],
            ema_diff: (parseFloat(kline.c) - emaCache.get(symbol)[emaCache.get(symbol).length - 1]) /
                emaCache.get(symbol)[emaCache.get(symbol).length - 1] * 100,
            rsi: rsi[rsi.length - 1],
            macd: macd.macd[macd.macd.length - 1],
            macd_signal: macd.signal[macd.signal.length - 1],
            macd_hist: macd.histogram[macd.histogram.length - 1],
            bb_upper: bb.upper[bb.upper.length - 1],
            bb_middle: bb.middle[bb.middle.length - 1],
            bb_lower: bb.lower[bb.lower.length - 1],
            bb_width: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) /
                bb.middle[bb.middle.length - 1],
            atr: atr,
            volume_change: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
            future_price_change: null, // To be filled later
            label: null // To be filled later
        };

        // Initialize training data array for this symbol if it doesn't exist
        if (!trainingData.has(symbol)) {
            trainingData.set(symbol, []);
        }

        // Add to training data
        trainingData.get(symbol).push(dataPoint);

        //exportToCSV();

        // Keep training data size manageable (last 1000 candles)
        if (trainingData.get(symbol).length > 1000) {
            trainingData.set(symbol, trainingData.get(symbol).slice(-1000));
        }

        // Schedule update of future price change (after 24 hours)
        setTimeout(() => updateFuturePriceChange(symbol, kline.t), 24 * 60 * 60 * 1000);
    } catch (error) {
        log(`Error collecting ML data for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Process closed candle data
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 * @param {boolean} dataCollectionMode - Whether in data collection mode
 */
async function processClosedCandle(symbol, kline, dataCollectionMode = false) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        // Get cached klines or initialize if not exists
        let klines = klineCache.get(symbol) || [];

        // Create new kline object
        const newKline = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
        };

        // Add new kline to cache
        klines.push(newKline);

        // Keep cache size reasonable
        if (klines.length > CONFIG.EMA_PERIOD * 2) {
            klines = klines.slice(-CONFIG.EMA_PERIOD * 2);
        }

        klineCache.set(symbol, klines);

        // Get closes for EMA calculation
        const closes = klines.map(k => k.close);

        // Calculate new EMA values
        const emaValues = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        // Collect data for ML training
        await collectDataForML(symbol, kline);

        // Check for crossover only if not in data collection mode
        if (!dataCollectionMode && emaValues.length >= 2) {
            const lastPrice = closes[closes.length - 1];
            const prevPrice = closes[closes.length - 2];
            const lastEMA = emaValues[emaValues.length - 1];
            const prevEMA = emaValues[emaValues.length - 2];

            checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA);
        }
    } catch (error) {
        log(`Error processing closed candle for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Process real-time candle updates
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 * @param {boolean} logUnconfirmed - Whether to log unconfirmed crossovers
 */
async function processRealtimeCandle(symbol, kline, logUnconfirmed = true) {
    try {
        // Validate symbol
        if (!validateSymbol(symbol)) {
            return;
        }

        // Get cached klines and validate
        const klines = klineCache.get(symbol);
        if (!klines || klines.length === 0) {
            return; // No historical data yet
        }

        // Get current price and validate
        const currentPrice = parseFloat(kline.c);
        if (isNaN(currentPrice)) {
            throw new Error('Invalid price data');
        }

        // Get cached EMA values and validate
        const emaValues = emaCache.get(symbol);
        if (!emaValues || emaValues.length < 2) {
            return; // Not enough EMA values yet
        }

        // Get the last closed price and EMA
        const lastClosedPrice = klines[klines.length - 1].close;
        const lastEMA = emaValues[emaValues.length - 1];

        // Get ML prediction if enabled
        let prediction = null;
        let confidenceScore = null;

        if (CONFIG.ML_ENABLED && mlModel) {
            try {
                const features = await prepareFeaturesForPrediction(symbol, klines, currentPrice);
                const predictionResult = await mlModel.predictPriceChange(symbol, features);
                if (predictionResult) {
                    prediction = predictionResult.prediction;
                    confidenceScore = predictionResult.confidenceScore;
                }
            } catch (predictionError) {
                log(`ML prediction error for ${symbol}: ${predictionError.message}`, 'warning');
            }
        }

        // Determine states
        const prevState = lastClosedPrice > lastEMA ? 'above' : 'below';
        const currentState = currentPrice > lastEMA ? 'above' : 'below';

        // Calculate difference percentage
        const difference = ((currentPrice - lastEMA) / lastEMA) * 100;

        // If state changed, we have a potential real-time crossover
        if (prevState !== currentState) {
            // Only log if explicitly requested
            if (logUnconfirmed) {
                const crossType = currentState === 'above' ? 'up' : 'down';
                const crossLabel = crossType === 'up' ?
                    'â–² POTENTIAL UPWARD CROSSOVER' :
                    'â–¼ POTENTIAL DOWNWARD CROSSOVER';

                // Log to file only
                const logMessage = [
                    `[${new Date().toISOString()}] ${crossLabel} detected for ${symbol}`,
                    `Current Price: ${formatPrice(currentPrice)}`,
                    `EMA(${CONFIG.EMA_PERIOD}): ${formatPrice(lastEMA)}`,
                    `Difference: ${difference.toFixed(2)}%`,
                    `Status: REAL-TIME (Unconfirmed)`,
                    prediction !== null ? `ML Prediction: ${prediction.toFixed(2)}% (Confidence: ${(confidenceScore * 100).toFixed(1)}%)` : ''
                ].join('\n');

                fs.appendFileSync(
                    path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    logMessage + '\n\n'
                );
            }

            // Update EMA with new price
            if (updateEMA(symbol, currentPrice)) {
                // If crossover confirmed and should alert
                if (shouldAlert(symbol, currentState)) {
                    if (prediction !== null) {
                        await sendTelegramAlertWithML(
                            symbol,
                            currentState === 'above' ? 'up' : 'down',
                            currentPrice,
                            lastEMA,
                            difference,
                            prediction,
                            confidenceScore
                        );
                    } else {
                        await sendTelegramAlert(
                            symbol,
                            currentState === 'above' ? 'up' : 'down',
                            currentPrice,
                            lastEMA,
                            difference
                        );
                    }
                }
            }

            // Collect data for ML training if enabled
            if (CONFIG.ML_ENABLED) {
                await collectDataForML(symbol, kline);
            }
        }

        // Update coin state even if no crossover
        coinStates.set(symbol, currentState);

    } catch (error) {
        // Log error to file
        fs.appendFileSync(
            path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error processing real-time candle for ${symbol}: ${error.message}\n`
        );
    }
}


/**
 * Check for EMA crossover and send alerts
 * @param {string} symbol - The trading pair symbol
 * @param {number} prevPrice - Previous price
 * @param {number} lastPrice - Current price
 * @param {number} prevEMA - Previous EMA
 * @param {number} lastEMA - Current EMA
 */
async function checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        // Determine current state (above or below EMA)
        const currentState = lastPrice > lastEMA ? 'above' : 'below';
        const difference = (lastPrice - lastEMA) / lastEMA * 100;

        // Get ML prediction if available, but handle errors gracefully
        let prediction = null;
        let confidenceScore = null;

        if (CONFIG.ML_ENABLED) {
            try {
                // Check if model exists for this symbol before attempting prediction
                const modelPath = path.join(DIRECTORIES.MODEL_PATH, symbol, 'model.json');
                if (fs.existsSync(modelPath)) {
                    // Get additional technical indicators
                    const klines = klineCache.get(symbol) || [];
                    if (klines.length >= 30) {
                        const closes = klines.map(k => k.close);
                        const volumes = klines.map(k => k.volume || 0);

                        // Calculate indicators
                        const rsi = technicalIndicators.calculateRSI(closes);
                        const macd = technicalIndicators.calculateMACD(closes);
                        const bb = technicalIndicators.calculateBollingerBands(closes);
                        const atr = technicalIndicators.calculateATR(klines);

                        // Prepare features for prediction
                        const features = {
                            priceDiff: difference,
                            rsi: rsi[rsi.length - 1],
                            macdHist: macd.histogram[macd.histogram.length - 1],
                            bbWidth: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.middle[bb.middle.length - 1],
                            volumeChange: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
                            atr: atr,
                            volume24h: volumes[volumes.length - 1]
                        };

                        // Get prediction using Brain.js
                        const predictionResult = await mlModel.predictPriceChange(symbol, features);

                        if (predictionResult && typeof predictionResult.prediction === 'number') {
                            prediction = predictionResult.prediction;
                            confidenceScore = predictionResult.confidenceScore / 100 || 0.5;

                            // Improved ML prediction log with symbol and key indicators
                            const predictionColor = prediction >= 0 ? 'green' : 'red';
                            const predictionSign = prediction >= 0 ? '+' : '';
                            console.log(`  ${symbol} ML Prediction: ${predictionSign}${prediction.toFixed(2)}% expected change (Confidence: ${(confidenceScore * 100).toFixed(1)}%)`.cyan);
                            console.log(`  Key Indicators: RSI=${rsi[rsi.length - 1].toFixed(2)}, MACD=${macd.histogram[macd.histogram.length - 1].toFixed(4)}`.gray);
                        }
                    }
                }
            } catch (predictionError) {
                log(`Error getting prediction for ${symbol}: ${predictionError.message}`, 'warning', predictionError);
                // Continue without prediction
            }
        }

        // Upward crossover: price crossing from below to above EMA
        if (prevPrice < prevEMA && lastPrice > lastEMA) {
            console.log('\n');
            console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'up', lastPrice, lastEMA, difference, prediction, confidenceScore);
                } else {
                    await sendTelegramAlert(symbol, 'up', lastPrice, lastEMA, difference);
                }
            }
        }
        // Downward crossover: price crossing from above to below EMA
        else if (prevPrice > prevEMA && lastPrice < lastEMA) {
            console.log('\n');
            console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'down', lastPrice, lastEMA, difference, prediction, confidenceScore);
                } else {
                    await sendTelegramAlert(symbol, 'down', lastPrice, lastEMA, difference);
                }
            }
        } else {
            // Update state even if no crossover
            coinStates.set(symbol, currentState);
        }
    } catch (error) {
        log(`Error checking for crossover for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Setup WebSockets for all tracked pairs
 */
async function setupAllWebSockets() {
    try {
        const pairs = await getFuturesPairs();

        log(`Setting up WebSockets for ${pairs.length} pairs`, 'info');

        // Close any existing WebSockets for pairs that are no longer tracked
        for (const [symbol, ws] of activeWebSockets.entries()) {
            if (!pairs.includes(symbol)) {
                log(`Closing WebSocket for ${symbol} (no longer tracked)`, 'info');
                try {
                    ws.close();
                } catch (e) {
                    // Ignore errors when closing
                }
                activeWebSockets.delete(symbol);
            }
        }

        // Setup WebSockets for all tracked pairs
        for (const symbol of pairs) {
            if (!activeWebSockets.has(symbol) || activeWebSockets.get(symbol).readyState !== WebSocket.OPEN) {
                setupSymbolWebSocket(symbol);

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        log(`WebSocket setup completed for ${pairs.length} pairs`, 'success');
    } catch (error) {
        log(`Error setting up WebSockets: ${error.message}`, 'error', error);
    }
}

/**
 * Check for EMA crossovers (traditional method, still used for initial load and periodic checks)
 */
async function checkEMACross() {
    try {
        // Check memory usage before heavy operation
        if (!checkMemoryUsage()) {
            log('Skipping EMA check due to high memory usage', 'warning');
            return;
        }

        const pairs = await getFuturesPairs();
        const timestamp = new Date().toLocaleString();

        console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
        process.stdout.write('Processing: '.cyan);

        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair =>
            getKlines(pair)
                .then(klines => ({ pair, klines, error: null }))
                .catch(error => ({ pair, klines: [], error }))
        );

        const results = await Promise.all(klinesPromises);

        for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');

            if (error || klines.length < CONFIG.EMA_PERIOD) {
                if (klines.length < CONFIG.EMA_PERIOD) {
                    log(`Skipping ${pair}: Not enough candles (${klines.length}/${CONFIG.EMA_PERIOD})`, 'warning');
                }
                continue;
            }

            const closes = klines.map(k => k.close);
            const ema = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);

            // Make sure we have enough EMA values
            if (ema.length < 2) {
                log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
                continue;
            }

            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];

            // Check for crossover
            checkForCrossover(pair, prevPrice, lastPrice, prevEMA, lastEMA);
        }

        console.log('\n');
        console.log(`Check completed at ${timestamp}. WebSockets are now monitoring in real-time.`.gray);
        console.log('='.repeat(80).dim);
    } catch (error) {
        log(`Error in checkEMACross: ${error.message}`, 'error', error);
        console.error('Stack trace:', error.stack);
    }
}

/**
 * Update future price change for training data
 * @param {string} symbol - The trading pair symbol
 * @param {number} timestamp - Timestamp of the data point
 */
async function updateFuturePriceChange(symbol, timestamp) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        if (!trainingData.has(symbol)) return;

        const data = trainingData.get(symbol);
        const dataPoint = data.find(d => d.timestamp === timestamp);

        if (!dataPoint) return;

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);
        const originalPrice = dataPoint.close;

        // Calculate price change percentage
        const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);

        // Update the data point
        dataPoint.future_price_change = priceChange;
        dataPoint.label = priceChange >= 0 ? 1 : 0;

        log(`Updated future price change for ${symbol}: ${priceChange.toFixed(2)}%`, 'info');

        // Save training data to disk periodically
        saveTrainingData();

        // Export updated data to CSV
        if (data.filter(d => d.future_price_change !== null).length % 50 === 0) {
            // Export to CSV every 50 completed data points
            await mlModel.exportToCSV(symbol, data);
        }
    } catch (error) {
        log(`Error updating future price change: ${error.message}`, 'error', error);
    }
}

/**
 * Get current price for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<number>} Current price
 */
async function getCurrentPrice(symbol) {
    try {
        if (!validateSymbol(symbol)) {
            throw new Error('Invalid symbol');
        }

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/price', {
            params: { symbol },
            timeout: 10000 // 10 second timeout
        });
        return parseFloat(response.data.price);
    } catch (error) {
        log(`Error getting current price for ${symbol}: ${error.message}`, 'error', error);
        throw error;
    }
}

/**
 * Save training data to disk
 */
function saveTrainingData() {
    try {
        // Check memory usage before heavy operation
        if (!checkMemoryUsage()) {
            log('Skipping training data save due to high memory usage', 'warning');
            return;
        }

        
        // Save each symbol's data to a separate file
        for (const [symbol, data] of trainingData.entries()) {
            if (!validateSymbol(symbol)) {
                continue;
            }
            
            if (!fs.existsSync(DIRECTORIES.DATA_DIR)) {
                fs.mkdirSync(DIRECTORIES.DATA_DIR, { recursive: true });
            }

            fs.writeFileSync(
                path.join(DIRECTORIES.DATA_DIR, `${symbol}_training.json`),
                JSON.stringify(data)
            );

            // Export to CSV if we have enough data points with outcomes
            const completedData = data.filter(d => d.future_price_change !== null);
            if (completedData.length >= 50) {
                mlModel.exportToCSV(symbol, data).catch(err => {
                    log(`Error exporting CSV for ${symbol}: ${err.message}`, 'error', err);
                });
            }
        }

        // Save model performance data
        fs.writeFileSync(
            path.join(DIRECTORIES.DATA_DIR, 'model_performance.json'),
            JSON.stringify(Array.from(modelPerformance.entries()))
        );

        log(`Saved training data for ${trainingData.size} symbols`, 'info');
    } catch (error) {
        log(`Error saving training data: ${error.message}`, 'error', error);
    }
}

/**
 * Load training data from disk
 */
function loadTrainingData() {
    try {
        if (!fs.existsSync(DIRECTORIES.DATA_DIR)) {
            fs.mkdirSync(DIRECTORIES.DATA_DIR, { recursive: true });
            return;
        }

        // Load each symbol's data
        const files = fs.readdirSync(DIRECTORIES.DATA_DIR).filter(f => f.endsWith('_training.json'));

        for (const file of files) {
            try {
                const symbol = file.replace('_training.json', '');

                if (!validateSymbol(symbol)) {
                    log(`Skipping invalid symbol file: ${file}`, 'warning');
                    continue;
                }

                const data = JSON.parse(fs.readFileSync(path.join(DIRECTORIES.DATA_DIR, file), 'utf8'));
                trainingData.set(symbol, data);
                log(`Loaded ${data.length} training points for ${symbol}`, 'info');
            } catch (e) {
                log(`Error loading data for ${file}: ${e.message}`, 'warning', e);
            }
        }

        // Load model performance data
        const perfFile = path.join(DIRECTORIES.DATA_DIR, 'model_performance.json');
        if (fs.existsSync(perfFile)) {
            const perfData = JSON.parse(fs.readFileSync(perfFile, 'utf8'));
            for (const [symbol, data] of perfData) {
                if (validateSymbol(symbol)) {
                    modelPerformance.set(symbol, data);
                }
            }
            log(`Loaded performance data for ${modelPerformance.size} models`, 'info');
        }
    } catch (error) {
        log(`Error loading training data: ${error.message}`, 'error', error);
    }
}

/**
 * Train all models
 * @param {string} chatId - Telegram chat ID for progress updates
 */
async function trainAllModels(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§  Starting Brain.js model training. This may take some time...');

        // Get all symbols with sufficient data
        const symbolsToTrain = Array.from(trainingData.keys())
            .filter(symbol => {
                if (!validateSymbol(symbol)) return false;

                const data = trainingData.get(symbol);
                const validData = data.filter(d => d.future_price_change !== null);
                return validData.length >= 100;
            });

        if (symbolsToTrain.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No symbols have enough data for training yet.');
            return;
        }

        await bot.sendMessage(chatId, `Training models for ${symbolsToTrain.length} symbols...`);

        let trainedCount = 0;
        let failedCount = 0;

        // Train models sequentially
        for (const symbol of symbolsToTrain) {
            try {
                // Check memory usage before training each model
                if (!checkMemoryUsage()) {
                    await bot.sendMessage(chatId, 'âš ï¸ Training stopped due to high memory usage. Please try again later.');
                    break;
                }

                // Export data to CSV first
                const data = trainingData.get(symbol);
                await mlModel.exportToCSV(symbol, data);

                // Train model
                const result = await mlModel.trainModelForSymbol(symbol);

                if (result) {
                    trainedCount++;

                    // Update model performance tracking
                    if (!modelPerformance.has(symbol)) {
                        modelPerformance.set(symbol, {
                            predictions: 0,
                            correctPredictions: 0,
                            directionAccuracy: result.performance?.directionAccuracy || 0,
                            mae: result.performance?.mae || 0,
                            lastTraining: new Date().toISOString(),
                            dataPoints: data.filter(d => d.future_price_change !== null).length
                        });
                    } else {
                        const perf = modelPerformance.get(symbol);
                        perf.lastTraining = new Date().toISOString();
                        perf.dataPoints = data.filter(d => d.future_price_change !== null).length;
                        perf.mae = result.performance?.mae || perf.mae;
                        perf.directionAccuracy = result.performance?.directionAccuracy || perf.directionAccuracy;
                        modelPerformance.set(symbol, perf);
                    }

                    // Send progress updates every 5 models
                    if (trainedCount % 5 === 0) {
                        await bot.sendMessage(
                            chatId,
                            `Progress: ${trainedCount}/${symbolsToTrain.length} models trained`
                        );
                    }
                } else {
                    failedCount++;
                }

                // Add a small delay between training sessions
                await new Promise(resolve => setTimeout(resolve, 5000));
            } catch (error) {
                log(`Error training model for ${symbol}: ${error.message}`, 'error', error);
                failedCount++;
            }
        }

        await bot.sendMessage(
            chatId,
            `ðŸ§  *Brain.js ML Training Complete*\n\n` +
            `âœ… Successfully trained: ${trainedCount} models\n` +
            `âŒ Failed: ${failedCount} models\n\n` +
            `Use /mlstatus to check model performance.`,
            { parse_mode: 'Markdown' }
        );

        // Save updated performance data
        saveTrainingData();
    } catch (error) {
        log(`Error in trainAllModels: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error training models: ${error.message}`);
    }
}

/**
 * Enhanced Telegram alert with ML prediction
 * @param {string} symbol - The trading pair symbol
 * @param {string} crossType - Type of crossover ('up' or 'down')
 * @param {number} price - Current price
 * @param {number} ema - Current EMA value
 * @param {number} difference - Percentage difference between price and EMA
 * @param {number} prediction - ML prediction value
 * @param {number} confidenceScore - Confidence score (0-1)
 */
async function sendTelegramAlertWithML(symbol, crossType, price, ema, difference, prediction, confidenceScore = 0.5) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Format ML prediction with confidence emoji
        let confidenceEmoji = 'âš ï¸'; // Neutral/uncertain
        if (confidenceScore > 0.8) {
            confidenceEmoji = prediction > 0 ? 'ðŸ”¥' : 'â„ï¸'; // Strong signal with high confidence
        } else if (confidenceScore > 0.6) {
            confidenceEmoji = prediction > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰'; // Moderate signal
        }

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${CONFIG.EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${CONFIG.TIMEFRAME}\n` +
            `*Brain.js Prediction:* ${confidenceEmoji} ${prediction.toFixed(2)}% (24h)\n` +
            `*Confidence:* ${(confidenceScore * 100).toFixed(1)}%\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, ML Prediction: ${prediction.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`ML-enhanced Telegram alert sent for ${symbol} (${crossType})`, 'success');

        // Update model performance tracking
        if (modelPerformance.has(symbol)) {
            const perf = modelPerformance.get(symbol);
            perf.predictions = (perf.predictions || 0) + 1;
            modelPerformance.set(symbol, perf);

            // Schedule a check after 24 hours to see if prediction was correct
            setTimeout(() => {
                checkPredictionAccuracy(symbol, prediction, price);
            }, 24 * 60 * 60 * 1000);
        }
    } catch (error) {
        log(`Error sending ML-enhanced Telegram message: ${error.message}`, 'error', error);

        // Fall back to regular alert
        sendTelegramAlert(symbol, crossType, price, ema, difference);
    }
}

/**
 * Check if a prediction was accurate after 24 hours
 * @param {string} symbol - The trading pair symbol
 * @param {number} prediction - The predicted price change percentage
 * @param {number} originalPrice - The price at time of prediction
 */
async function checkPredictionAccuracy(symbol, prediction, originalPrice) {
    try {
        if (!validateSymbol(symbol)) {
            return;
        }

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);

        // Calculate actual price change
        const actualChange = ((currentPrice - originalPrice) / originalPrice) * 100;

        // Check if direction was correct
        const predictionDirection = prediction > 0;
        const actualDirection = actualChange > 0;
        const isCorrect = predictionDirection === actualDirection;

        log(`Prediction check for ${symbol}: Predicted ${prediction.toFixed(2)}%, Actual ${actualChange.toFixed(2)}%, Correct: ${isCorrect}`,
            isCorrect ? 'success' : 'warning');

        // Update model performance
        if (modelPerformance.has(symbol)) {
            const perf = modelPerformance.get(symbol);
            if (isCorrect) {
                perf.correctPredictions = (perf.correctPredictions || 0) + 1;
            }

            // Update direction accuracy
            if (perf.predictions > 0) {
                perf.directionAccuracy = perf.correctPredictions / perf.predictions;
            }

            modelPerformance.set(symbol, perf);

            // Save updated performance data
            fs.writeFileSync(
                path.join(DIRECTORIES.DATA_DIR, 'model_performance.json'),
                JSON.stringify(Array.from(modelPerformance.entries()))
            );
        }
    } catch (error) {
        log(`Error checking prediction accuracy for ${symbol}: ${error.message}`, 'error', error);
    }
}

/**
 * Start manual data collection for all tracked pairs
 * @param {string} chatId - Telegram chat ID for progress updates
 */
async function startManualDataCollection(chatId) {
    try {
        // Check if data collection is already in progress
        if (dataCollectionInProgress) {
            await bot.sendMessage(chatId, 'âš ï¸ Data collection is already in progress. Please wait for it to complete.');
            return;
        }

        dataCollectionInProgress = true;
        await bot.sendMessage(chatId, 'ðŸ“Š Starting manual data collection for all tracked pairs...');

        const pairs = await getFuturesPairs();
        if (pairs.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No pairs are currently being tracked.');
            dataCollectionInProgress = false;
            return;
        }

        await bot.sendMessage(chatId, `Collecting data for ${pairs.length} pairs...`);

        let successCount = 0;
        let failedCount = 0;

        for (const symbol of pairs) {
            try {
                if (!validateSymbol(symbol)) {
                    failedCount++;
                    continue;
                }

                // Check memory usage before processing each symbol
                if (!checkMemoryUsage()) {
                    await bot.sendMessage(chatId, 'âš ï¸ Data collection stopped due to high memory usage. Please try again later.');
                    break;
                }

                // Get historical klines
                const klines = await getKlines(symbol);
                if (klines.length < 30) {
                    log(`Skipping ${symbol}: Not enough candles`, 'warning');
                    failedCount++;
                    continue;
                }

                // Process each candle
                for (let i = 0; i < klines.length; i++) {
                    // Skip very old candles
                    if (i < klines.length - 100) continue;

                    const candle = klines[i];

                    // Create kline object in the format expected by processClosedCandle
                    const klineObj = {
                        t: candle.time,
                        o: candle.open.toString(),
                        h: candle.high.toString(),
                        l: candle.low.toString(),
                        c: candle.close.toString(),
                        v: candle.volume.toString()
                    };

                    // Process this candle
                    await processClosedCandle(symbol, klineObj, true); // Pass true to indicate data collection mode
                }

                successCount++;

                // Send progress updates
                if ((successCount + failedCount) % 10 === 0) {
                    await bot.sendMessage(
                        chatId,
                        `Progress: ${successCount + failedCount}/${pairs.length} pairs processed`
                    );
                }

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                log(`Error collecting data for ${symbol}: ${error.message}`, 'error', error);
                failedCount++;
            }
        }

        // Save all collected data
        saveTrainingData();


        // Send completion message
        await bot.sendMessage(
            chatId,
            `ðŸ“Š *Data Collection Complete*\n\n` +
            `âœ… Successfully collected data for ${successCount} pairs\n` +
            `âŒ Failed: ${failedCount} pairs\n\n` +
            `Future price changes will be updated in 24 hours.`,
            { parse_mode: 'Markdown' }
        );

        // Reset the flag
        dataCollectionInProgress = false;
    } catch (error) {
        log(`Error in manual data collection: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error during data collection: ${error.message}`);
        dataCollectionInProgress = false;
    }
}

/**

 * Export data to CSV
 * @param {string} symbol - The trading pair symbol
 * @param {Array} data - Data to export
 * @returns {Promise<boolean>} Success status
 */
async function exportToCSV(symbol, data) {
    try {
        if (!validateSymbol(symbol)) {
            return false;
        }

        // Create directory for this symbol if it doesn't exist
        const symbolDir = path.join(DIRECTORIES.CSV_DATA, symbol);
        if (!fs.existsSync(symbolDir)) {
            fs.mkdirSync(symbolDir, { recursive: true });
        }

        const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

        // Filter out data points without future price change
        const validData = data.filter(d => d.future_price_change !== null);

        if (validData.length === 0) {
            log(`No valid data points with outcomes for ${symbol}`, 'warning');
            return false;
        }

        // Create CSV writer
        const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
                { id: 'timestamp', title: 'Timestamp' },
                { id: 'open', title: 'Open' },
                { id: 'high', title: 'High' },
                { id: 'low', title: 'Low' },
                { id: 'close', title: 'Close' },
                { id: 'volume', title: 'Volume' },
                { id: 'ema', title: 'EMA' },
                { id: 'ema_diff', title: 'EMA_Diff_Pct' },
                { id: 'rsi', title: 'RSI' },
                { id: 'macd', title: 'MACD' },
                { id: 'macd_signal', title: 'MACD_Signal' },
                { id: 'macd_hist', title: 'MACD_Hist' },
                { id: 'bb_width', title: 'BB_Width' },
                { id: 'atr', title: 'ATR' },
                { id: 'volume_change', title: 'Volume_Change' },
                { id: 'future_price_change', title: 'Future_Price_Change' }
            ]
        });

        // Write data to CSV
        await csvWriter.writeRecords(validData);

        log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
        return true;
    } catch (error) {
        log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error', error);
        return false;
    }
}

/**
 * Send model performance data
 * @param {string} chatId - Telegram chat ID
 */
async function sendModelPerformance(chatId) {
    try {
        if (modelPerformance.size === 0) {
            await bot.sendMessage(chatId, 'âŒ No model performance data available yet.');
            return;
        }

        let message = '*Brain.js Model Performance*\n\n';

        // Sort symbols by direction accuracy
        const sortedSymbols = Array.from(modelPerformance.keys())
            .filter(symbol => validateSymbol(symbol))
            .sort((a, b) => {
                const aMetrics = modelPerformance.get(a);
                const bMetrics = modelPerformance.get(b);
                return (bMetrics.directionAccuracy || 0) - (aMetrics.directionAccuracy || 0);
            })
            .slice(0, 10); // Top 10 performing models

        for (const symbol of sortedSymbols) {
            const metrics = modelPerformance.get(symbol);
            if (!metrics.dataPoints || metrics.dataPoints < 50) continue; // Skip models with few data points

            message += `*${symbol}*\n` +
                `- Direction Accuracy: ${((metrics.directionAccuracy || 0) * 100).toFixed(2)}%\n` +
                `- Mean Absolute Error: ${(metrics.mae || 0).toFixed(4)}\n` +
                `- Data Points: ${metrics.dataPoints}\n` +
                `- Last Trained: ${new Date(metrics.lastTraining).toLocaleString()}\n\n`;
        }

        // Add information about CSV data
        const csvSymbols = fs.existsSync(DIRECTORIES.CSV_DATA) ?
            fs.readdirSync(DIRECTORIES.CSV_DATA).filter(item => fs.statSync(path.join(DIRECTORIES.CSV_DATA, item)).isDirectory()) : [];

        if (csvSymbols.length > 0) {
            message += `\n*CSV Training Data Available*\n`;
            message += `${csvSymbols.length} symbols have CSV data for visualization.\n`;
            message += `CSV files are stored in: ${DIRECTORIES.CSV_DATA}\n\n`;
            message += `You can use these CSV files with external tools for data analysis.`;
        }

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Train All Models', callback_data: 'train_models' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending model performance: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, 'âŒ Error fetching model performance data');
    }
}

/**
 * Command handler for Telegram messages
 * @param {Object} msg - Telegram message object
 */
function handleMessage(msg) {
    try {
        const chatId = msg.chat.id;
        const text = msg.text || '';

        // Rate limiting for commands
        const now = Date.now();
        const lastCommandTime = lastCommandTimes.get(chatId) || 0;

        if (now - lastCommandTime < 1000) { // 1 second rate limit
            return; // Ignore command if rate limited
        }

        lastCommandTimes.set(chatId, now);

        if (text === '/start' || text === '/menu') {
            sendMainMenu(chatId);
        } else if (text === '/status') {
            sendStatusUpdate(chatId);
        } else if (text === '/settings') {
            sendSettingsMenu(chatId);
        } else if (text === '/help') {
            sendHelpMessage(chatId);
        } else if (text === '/top') {
            sendTopPerformers(chatId);
        } else if (text === '/refresh') {
            refreshWebSockets(chatId);
        } else if (text === '/mlstatus') {
            sendModelPerformance(chatId);
        } else if (text === '/train') {
            trainAllModels(chatId);
        } else if (text === '/collectdata') {
            startManualDataCollection(chatId);
        } else if (text === '/listdata') {
            listAvailableCSVData(chatId);
        } else if (text && text.startsWith('/viewdata ')) {
            const symbol = text.split(' ')[1].toUpperCase();
            if (validateSymbol(symbol)) {
                viewSymbolCSVData(chatId, symbol);
            } else {
                bot.sendMessage(chatId, 'âŒ Invalid symbol format');
            }
        }
    } catch (error) {
        log(`Error handling message: ${error.message}`, 'error', error);
    }
}

// Track last command times for rate limiting
const lastCommandTimes = new Map();

/**
 * List available CSV data
 * @param {string} chatId - Telegram chat ID
 */
async function listAvailableCSVData(chatId) {
    try {
        if (!fs.existsSync(DIRECTORIES.CSV_DATA)) {
            await bot.sendMessage(chatId, 'âŒ No CSV data directory found. Run data collection first.');
            return;
        }

        const symbols = fs.readdirSync(DIRECTORIES.CSV_DATA)
            .filter(item => fs.statSync(path.join(DIRECTORIES.CSV_DATA, item)).isDirectory() && validateSymbol(item));

        if (symbols.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No CSV data available yet. Run data collection first.');
            return;
        }

        // Get data points count for each symbol
        const symbolData = [];
        for (const symbol of symbols) {
            const csvPath = path.join(DIRECTORIES.CSV_DATA, symbol, `${symbol}_training_data.csv`);
            if (fs.existsSync(csvPath)) {
                const stats = fs.statSync(csvPath);
                const fileSize = (stats.size / 1024).toFixed(2) + ' KB';

                // Count lines (data points) - simple approach
                const content = fs.readFileSync(csvPath, 'utf8');
                const lines = content.split('\n').length - 1; // -1 for header

                symbolData.push({
                    symbol,
                    dataPoints: lines,
                    fileSize
                });
            }
        }

        // Sort by data points (descending)
        symbolData.sort((a, b) => b.dataPoints - a.dataPoints);

        let message = '*Available CSV Training Data*\n\n';

        for (const data of symbolData) {
            message += `*${data.symbol}*: ${data.dataPoints} data points (${data.fileSize})\n`;
        }

        message += '\nUse /viewdata SYMBOL to get details about a specific symbol\'s data.';

        // Create inline keyboard with symbols
        const keyboard = [];
        const buttonsPerRow = 3;

        for (let i = 0; i < symbolData.length; i += buttonsPerRow) {
            const row = [];
            for (let j = 0; j < buttonsPerRow && i + j < symbolData.length; j++) {
                row.push({
                    text: symbolData[i + j].symbol,
                    callback_data: `viewdata_${symbolData[i + j].symbol}`
                });
            }
            keyboard.push(row);
        }

        keyboard.push([{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]);

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        log(`Error listing CSV data: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error listing CSV data: ${error.message}`);
    }
}


/**
 * View CSV data for a specific symbol
 * @param {string} chatId - Telegram chat ID
 * @param {string} symbol - The trading pair symbol
 */
async function viewSymbolCSVData(chatId, symbol) {
    try {
        if (!validateSymbol(symbol)) {
            await bot.sendMessage(chatId, `âŒ Invalid symbol format: ${symbol}`);
            return;
        }

        const csvPath = path.join(DIRECTORIES.CSV_DATA, symbol, `${symbol}_training_data.csv`);

        if (!fs.existsSync(csvPath)) {
            await bot.sendMessage(chatId, `âŒ No CSV data found for ${symbol}`);
            return;
        }

        // Get file stats
        const stats = fs.statSync(csvPath);
        const fileSize = (stats.size / 1024).toFixed(2) + ' KB';
        const modifiedDate = new Date(stats.mtime).toLocaleString();

        // Count lines (data points)
        const content = fs.readFileSync(csvPath, 'utf8');
        const lines = content.split('\n');
        const dataPoints = lines.length - 1; // -1 for header

        // Get a preview of the data (first 5 rows)
        const preview = lines.slice(0, 6).join('\n');

        // Calculate some basic stats from the data
        const rows = content.split('\n').slice(1).filter(row => row.trim() !== '');

        let avgPriceChange = 0;
        let positiveChanges = 0;
        let negativeChanges = 0;

        for (const row of rows) {
            const columns = row.split(',');
            if (columns.length > 15) { // Make sure we have enough columns
                const priceChange = parseFloat(columns[15]); // Future_Price_Change column
                if (!isNaN(priceChange)) {
                    avgPriceChange += priceChange;
                    if (priceChange > 0) positiveChanges++;
                    else if (priceChange < 0) negativeChanges++;
                }
            }
        }

        avgPriceChange = avgPriceChange / rows.length;

        // Create message
        let message = `*CSV Data for ${symbol}*\n\n`;
        message += `ðŸ“Š *Statistics:*\n`;
        message += `- Data Points: ${dataPoints}\n`;
        message += `- File Size: ${fileSize}\n`;
        message += `- Last Modified: ${modifiedDate}\n`;
        message += `- Avg Price Change: ${avgPriceChange.toFixed(2)}%\n`;
        message += `- Positive Changes: ${positiveChanges} (${((positiveChanges / rows.length) * 100).toFixed(2)}%)\n`;
        message += `- Negative Changes: ${negativeChanges} (${((negativeChanges / rows.length) * 100).toFixed(2)}%)\n\n`;

        // Check if model exists for this symbol
        const modelPath = path.join(DIRECTORIES.MODEL_PATH, symbol, 'model.json');
        if (fs.existsSync(modelPath)) {
            message += `âœ… *Brain.js model is available for this symbol*\n\n`;
        } else {
            message += `âš ï¸ *No Brain.js model trained yet for this symbol*\n\n`;
        }

        message += `The CSV file contains the following columns:\n`;
        message += `Timestamp, Open, High, Low, Close, Volume, EMA, EMA_Diff_Pct, RSI, MACD, MACD_Signal, MACD_Hist, BB_Width, ATR, Volume_Change, Future_Price_Change\n\n`;

        message += `You can use this data with external tools for visualization and analysis.`;

        // Send message with inline keyboard
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“Š List All Data', callback_data: 'list_data' },
                        { text: 'ðŸ§  Train Model', callback_data: `train_single_${symbol}` }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });

        // Send CSV file
        await bot.sendDocument(chatId, csvPath, {
            caption: `CSV training data for ${symbol} with ${dataPoints} data points`
        });
    } catch (error) {
        log(`Error viewing CSV data for ${symbol}: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error viewing CSV data: ${error.message}`);
    }
}

/**
 * Train a single model
 * @param {string} chatId - Telegram chat ID
 * @param {string} symbol - The trading pair symbol
 */
async function trainSingleModel(chatId, symbol) {
    try {
        if (!validateSymbol(symbol)) {
            await bot.sendMessage(chatId, `âŒ Invalid symbol format: ${symbol}`);
            return;
        }

        await bot.sendMessage(chatId, `ðŸ§  Starting Brain.js model training for ${symbol}...`);

        // Check if we have data for this symbol
        if (!trainingData.has(symbol)) {
            await bot.sendMessage(chatId, `âŒ No training data found for ${symbol}. Please collect data first.`);
            return;
        }

        const data = trainingData.get(symbol);
        const validData = data.filter(d => d.future_price_change !== null);

        if (validData.length < 100) {
            await bot.sendMessage(chatId, `âŒ Not enough valid data for ${symbol}: ${validData.length}/100 points needed.`);
            return;
        }

        // Export data to CSV first
        await mlModel.exportToCSV(symbol, data);

        // Train model
        const result = await mlModel.trainModelForSymbol(symbol);

        if (result) {
            // Update model performance tracking
            if (!modelPerformance.has(symbol)) {
                modelPerformance.set(symbol, {
                    predictions: 0,
                    correctPredictions: 0,
                    directionAccuracy: result.performance?.directionAccuracy || 0,
                    mae: result.performance?.mae || 0,
                    lastTraining: new Date().toISOString(),
                    dataPoints: validData.length
                });
            } else {
                const perf = modelPerformance.get(symbol);
                perf.lastTraining = new Date().toISOString();
                perf.dataPoints = validData.length;
                perf.mae = result.performance?.mae || perf.mae;
                perf.directionAccuracy = result.performance?.directionAccuracy || perf.directionAccuracy;
                modelPerformance.set(symbol, perf);
            }

            // Save updated performance data
            saveTrainingData();

            await bot.sendMessage(chatId,
                `âœ… Successfully trained model for ${symbol}\n\n` +
                `- Direction Accuracy: ${(result.performance?.directionAccuracy * 100).toFixed(2)}%\n` +
                `- Mean Absolute Error: ${result.performance?.mae.toFixed(4)}\n` +
                `- Training Data Points: ${validData.length}\n\n` +
                `The model is now ready for predictions.`,
                {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                        ]
                    }
                }
            );
        } else {
            await bot.sendMessage(chatId, `âŒ Failed to train model for ${symbol}. Please try again later.`);
        }
    } catch (error) {
        log(`Error training model for ${symbol}: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error training model: ${error.message}`);
    }
}

/**
 * Refresh WebSockets command
 * @param {string} chatId - Telegram chat ID
 */
async function refreshWebSockets(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ”„ Refreshing WebSocket connections...');

        // Close all existing WebSockets
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
            } catch (e) {
                // Ignore errors when closing
            }
            activeWebSockets.delete(symbol);
        }

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        await bot.sendMessage(chatId, 'âœ… WebSocket connections refreshed successfully!');
    } catch (error) {
        log(`Error refreshing WebSockets: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error refreshing WebSockets: ${error.message}`);
    }
}

/**
 * Callback query handler for inline buttons
 * @param {Object} callbackQuery - Telegram callback query object
 */
async function handleCallbackQuery(callbackQuery) {
    const queryId = callbackQuery.id;
    const chatId = callbackQuery.message.chat.id;
    const action = callbackQuery.data;
    try {
        //const action = callbackQuery.data;
        //const chatId = callbackQuery.message.chat.id;

        // Rate limiting for callback queries
        const now = Date.now();
        const lastCallbackTime = lastCallbackTimes.get(chatId) || 0;

        if (now - lastCallbackTime < 1000) { // 1 second rate limit
            await bot.answerCallbackQuery(callbackQuery.id);
            return; // Ignore callback if rate limited
        }

        lastCallbackTimes.set(chatId, now);

        if (action === 'status') {
            await sendStatusUpdate(chatId);
        } else if (action === 'settings') {
            await sendSettingsMenu(chatId);
        } else if (action === 'top_gainers') {
            await sendTopPerformers(chatId, 'gainers');
        } else if (action === 'top_losers') {
            await sendTopPerformers(chatId, 'losers');
        } else if (action === 'top_volume') {
            await sendTopPerformers(chatId, 'volume');
        } else if (action === 'menu') {
            await sendMainMenu(chatId);
        } else if (action === 'help') {
            await sendHelpMessage(chatId);
        } else if (action === 'refresh_ws') {
            await refreshWebSockets(chatId);
        } else if (action.startsWith('timeframe_')) {
            const newTimeframe = action.replace('timeframe_', '');
            // Update the timeframe
            CONFIG.TIMEFRAME = newTimeframe;
            log(`Timeframe updated to ${newTimeframe}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new timeframe
            await bot.sendMessage(chatId, `âœ… Timeframe updated to ${newTimeframe}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('ema_')) {
            const newEma = parseInt(action.replace('ema_', ''), 10);
            // Update the EMA period
            CONFIG.EMA_PERIOD = newEma;
            log(`EMA period updated to ${newEma}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new EMA period
            await bot.sendMessage(chatId, `âœ… EMA period updated to ${newEma}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('volume_')) {
            const newVolume = parseInt(action.replace('volume_', ''), 10);
            // Update the volume threshold
            CONFIG.VOLUME_THRESHOLD = newVolume;
            log(`Volume threshold updated to ${newVolume}`, 'success');
            saveSettings();

            // Refresh tracked pairs based on new volume threshold
            await bot.sendMessage(chatId, `âœ… Volume threshold updated to ${formatVolume(newVolume)}. Refreshing tracked pairs...`);
            await setupAllWebSockets();

            await sendSettingsMenu(chatId);
        } else if (action === 'ml_status') {
            await sendModelPerformance(chatId);
        } else if (action === 'train_models') {
            await trainAllModels(chatId);
        } else if (action === 'list_data') {
            await listAvailableCSVData(chatId);
        } else if (action === 'collect_data') {
            await startManualDataCollection(chatId);
        } else if (action.startsWith('viewdata_')) {
            const symbol = action.replace('viewdata_', '');
            if (validateSymbol(symbol)) {
                await viewSymbolCSVData(chatId, symbol);
            } else {
                await bot.sendMessage(chatId, 'âŒ Invalid symbol format');
            }
        } else if (action.startsWith('train_single_')) {
            const symbol = action.replace('train_single_', '');
            if (validateSymbol(symbol)) {
                await trainSingleModel(chatId, symbol);
            } else {
                await bot.sendMessage(chatId, 'âŒ Invalid symbol format');
            }
        } else if (action === 'toggle_ml') {
            // Toggle ML enabled state
            CONFIG.ML_ENABLED = !CONFIG.ML_ENABLED;
            log(`Machine Learning ${CONFIG.ML_ENABLED ? 'enabled' : 'disabled'}`, 'success');
            saveSettings();

            await bot.sendMessage(chatId, `âœ… Machine Learning ${CONFIG.ML_ENABLED ? 'enabled' : 'disabled'}`);
            await sendSettingsMenu(chatId);
        } else if (action === 'memory_status') {
            await sendMemoryStatus(chatId);
        } else if (action === 'clear_memory') {
            await clearMemoryCache(chatId);
        }

        // Answer callback query to remove loading state
        //await bot.answerCallbackQuery(callbackQuery.id);
        await bot.answerCallbackQuery(queryId, { text: 'Action received!' });
    } catch (error) {
        if (error.response && error.response.statusCode === 400) {
            log(`Error handling callback query: ${error.message}`, 'error', error);
        } else {
            throw error; // Re-throw if it's not the specific 400 error
        }
    }
}

// Track last callback times for rate limiting
const lastCallbackTimes = new Map();

/**
 * Send memory usage status
 * @param {string} chatId - Telegram chat ID
 */
async function sendMemoryStatus(chatId) {
    try {
        const memoryUsage = process.memoryUsage();
        const formatMemory = (bytes) => (bytes / 1024 / 1024).toFixed(2) + ' MB';

        const message = `*Memory Usage Status*\n\n` +
            `- RSS: ${formatMemory(memoryUsage.rss)}\n` +
            `- Heap Total: ${formatMemory(memoryUsage.heapTotal)}\n` +
            `- Heap Used: ${formatMemory(memoryUsage.heapUsed)}\n` +
            `- External: ${formatMemory(memoryUsage.external)}\n\n` +
            `*Cache Sizes:*\n` +
            `- Kline Cache: ${klineCache.size} symbols\n` +
            `- EMA Cache: ${emaCache.size} symbols\n` +
            `- Training Data: ${trainingData.size} symbols\n` +
            `- Active WebSockets: ${activeWebSockets.size} connections\n\n` +
            `Memory usage is ${memoryUsage.heapUsed > 500 * 1024 * 1024 ? 'âš ï¸ HIGH' : 'âœ… NORMAL'}`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ§¹ Clear Memory Cache', callback_data: 'clear_memory' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending memory status: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error getting memory status: ${error.message}`);
    }
}

/**
 * Clear memory caches
 * @param {string} chatId - Telegram chat ID
 */
async function clearMemoryCache(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§¹ Clearing memory caches...');

        // Save training data before clearing
        saveTrainingData();

        // Clear caches
        klineCache.clear();
        emaCache.clear();

        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }

        const memoryUsage = process.memoryUsage();
        const formatMemory = (bytes) => (bytes / 1024 / 1024).toFixed(2) + ' MB';

        await bot.sendMessage(chatId,
            `âœ… Memory caches cleared!\n\n` +
            `Current heap usage: ${formatMemory(memoryUsage.heapUsed)}\n\n` +
            `Note: Training data was saved before clearing.`,
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                        [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                    ]
                }
            }
        );
    } catch (error) {
        log(`Error clearing memory cache: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, `âŒ Error clearing memory: ${error.message}`);
    }
}

/**
 * Check memory usage and log warning if high
 * @returns {boolean} True if memory usage is acceptable, false if too high
 */
function checkMemoryUsage() {
    const memoryUsage = process.memoryUsage();
    const metrics = {
        heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024),
        heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024),
        rss: Math.round(memoryUsage.rss / 1024 / 1024),
        external: Math.round(memoryUsage.external / 1024 / 1024)
    };

    // Memory usage thresholds
    const maxMemory = CONFIG.MAX_MEMORY_USAGE_MB;
    const warningThreshold = maxMemory * 0.8;
    const criticalThreshold = maxMemory * 0.95;

    // Log warnings
    if (metrics.heapUsed > criticalThreshold) {
        log(`CRITICAL: Memory usage extremely high (${metrics.heapUsed}MB / ${maxMemory}MB). Attempting emergency cleanup.`, 'error');

        // Emergency cleanup
        if (global.klineCache) global.klineCache.clear();
        if (global.emaCache) global.emaCache.clear();

        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }

        return { isHealthy: false, metrics };
    } else if (metrics.heapUsed > warningThreshold) {
        log(`WARNING: High memory usage detected (${metrics.heapUsed}MB / ${metrics.heapTotal}MB)`, 'warning');
    }

    return { isHealthy: metrics.heapUsed < maxMemory, metrics };
}

/**
 * Save settings to a file
 */
function saveSettings() {
    try {
        const settings = {
            EMA_PERIOD: CONFIG.EMA_PERIOD,
            TIMEFRAME: CONFIG.TIMEFRAME,
            VOLUME_THRESHOLD: CONFIG.VOLUME_THRESHOLD,
            CHECK_INTERVAL: CONFIG.CHECK_INTERVAL,
            ALERT_COOLDOWN: CONFIG.ALERT_COOLDOWN,
            ML_ENABLED: CONFIG.ML_ENABLED
        };

        fs.writeFileSync(
            path.join(__dirname, 'settings.json'),
            JSON.stringify(settings, null, 2)
        );
        log('Settings saved to file', 'success');
    } catch (error) {
        log(`Error saving settings: ${error.message}`, 'error', error);
    }
}

/**
 * Load settings from file
 */
function loadSettings() {
    try {
        const settingsPath = path.join(__dirname, 'settings.json');
        if (fs.existsSync(settingsPath)) {
            const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

            // Update variables with saved settings
            CONFIG.EMA_PERIOD = settings.EMA_PERIOD || CONFIG.EMA_PERIOD;
            CONFIG.TIMEFRAME = settings.TIMEFRAME || CONFIG.TIMEFRAME;
            CONFIG.VOLUME_THRESHOLD = settings.VOLUME_THRESHOLD || CONFIG.VOLUME_THRESHOLD;
            CONFIG.ML_ENABLED = settings.ML_ENABLED !== undefined ? settings.ML_ENABLED : CONFIG.ML_ENABLED;

            log('Settings loaded from file', 'success');
        }
    } catch (error) {
        log(`Error loading settings: ${error.message}`, 'error', error);
    }
}

/**
 * Send main menu with Brain.js options
 * @param {string} chatId - Telegram chat ID
 */
async function sendMainMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [{ text: 'ðŸ“Š Status', callback_data: 'status' }],
            [{ text: 'âš™ï¸ Settings', callback_data: 'settings' }],
            [
                { text: 'ðŸ“ˆ Top Gainers', callback_data: 'top_gainers' },
                { text: 'ðŸ“‰ Top Losers', callback_data: 'top_losers' }
            ],
            [{ text: 'ðŸ’° Highest Volume', callback_data: 'top_volume' }],
            [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
            [
                { text: 'ðŸ§  ML Status', callback_data: 'ml_status' },
                { text: 'ðŸ”¬ Train Models', callback_data: 'train_models' }
            ],
            [
                { text: 'ðŸ“Š List Data', callback_data: 'list_data' },
                { text: 'ðŸ“¥ Collect Data', callback_data: 'collect_data' }
            ],
            [
                { text: 'ðŸ§® Memory Status', callback_data: 'memory_status' },
                { text: 'â“ Help', callback_data: 'help' }
            ]
        ]
    };

    await bot.sendMessage(chatId, '*EMA Tracker Bot Menu*\nSelect an option:', {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

/**
 * Send status update
 * @param {string} chatId - Telegram chat ID
 */
async function sendStatusUpdate(chatId) {
    try {
        const pairs = await getFuturesPairs();
        const activeWsCount = Array.from(activeWebSockets.values())
            .filter(ws => ws.readyState === WebSocket.OPEN).length;

        // Get Brain.js model stats
        const modelCount = fs.existsSync(DIRECTORIES.MODEL_PATH) ?
            fs.readdirSync(DIRECTORIES.MODEL_PATH).filter(item => fs.existsSync(path.join(DIRECTORIES.MODEL_PATH, item, 'model.json'))).length : 0;

        // Get data collection stats
        const dataPointCount = Array.from(trainingData.entries())
            .reduce((sum, [_, data]) => sum + data.length, 0);

        // Get memory usage
        const memoryUsage = process.memoryUsage();
        const heapUsedMB = (memoryUsage.heapUsed / 1024 / 1024).toFixed(2);

        const message = `*EMA Tracker Status*\n\n` +
            `*Active Configuration:*\n` +
            `- EMA Period: ${CONFIG.EMA_PERIOD}\n` +
            `- Timeframe: ${CONFIG.TIMEFRAME}\n` +
            `- Volume Threshold: ${formatVolume(CONFIG.VOLUME_THRESHOLD)}\n` +
            `- Monitoring: ${pairs.length} pairs\n` +
            `- Active WebSockets: ${activeWsCount}/${pairs.length}\n` +
            `- Last Check: ${new Date().toLocaleString()}\n\n` +
            `*Brain.js ML Status:*\n` +
            `- ML Enabled: ${CONFIG.ML_ENABLED ? 'âœ…' : 'âŒ'}\n` +
            `- Trained Models: ${modelCount}\n` +
            `- Data Points Collected: ${dataPointCount}\n\n` +
            `*System Status:*\n` +
            `- Memory Usage: ${heapUsedMB} MB\n` +
            `- Uptime: ${formatUptime(process.uptime())}\n\n` +
            `Bot is actively monitoring for EMA crossovers in real-time.`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending status update: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, 'âŒ Error fetching status');
    }
}

/**
 * Format uptime in a human-readable format
 * @param {number} seconds - Uptime in seconds
 * @returns {string} Formatted uptime
 */
function formatUptime(seconds) {
    const days = Math.floor(seconds / (3600 * 24));
    const hours = Math.floor((seconds % (3600 * 24)) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    let result = '';
    if (days > 0) result += `${days}d `;
    if (hours > 0) result += `${hours}h `;
    result += `${minutes}m`;

    return result;
}

/**
 * Send settings menu
 * @param {string} chatId - Telegram chat ID
 */
async function sendSettingsMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [
                { text: '1m', callback_data: 'timeframe_1m' },
                { text: '5m', callback_data: 'timeframe_5m' },
                { text: '15m', callback_data: 'timeframe_15m' },
                { text: '1h', callback_data: 'timeframe_1h' },
                { text: '4h', callback_data: 'timeframe_4h' }
            ],
            [
                { text: 'EMA 50', callback_data: 'ema_50' },
                { text: 'EMA 100', callback_data: 'ema_100' },
                { text: 'EMA 200', callback_data: 'ema_200' }
            ],
            [
                { text: 'Vol 50M', callback_data: 'volume_50000000' },
                { text: 'Vol 100M', callback_data: 'volume_100000000' },
                { text: 'Vol 200M', callback_data: 'volume_200000000' }
            ],
            [
                { text: CONFIG.ML_ENABLED ? 'ðŸ§  Disable ML' : 'ðŸ§  Enable ML', callback_data: 'toggle_ml' }
            ],
            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
        ]
    };

    await bot.sendMessage(chatId, `*Settings*\n\nCurrent Configuration:\n- EMA: ${CONFIG.EMA_PERIOD}\n- Timeframe: ${CONFIG.TIMEFRAME}\n- Volume Threshold: ${formatVolume(CONFIG.VOLUME_THRESHOLD)}\n- ML Enabled: ${CONFIG.ML_ENABLED ? 'âœ…' : 'âŒ'}\n\nSelect a new setting:`, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

/**
 * Send help message
 * @param {string} chatId - Telegram chat ID
 */
async function sendHelpMessage(chatId) {
    const helpText = `*EMA Tracker Bot Help*\n\n` +
        `This bot monitors Binance Futures markets for EMA crossovers and sends alerts when they occur.\n\n` +
        `*Available Commands:*\n` +
        `/menu - Show the main menu\n` +
        `/status - Check bot status\n` +
        `/settings - Configure bot settings\n` +
        `/top - View top performing coins\n` +
        `/refresh - Refresh WebSocket connections\n` +
        `/mlstatus - Check ML model performance\n` +
        `/train - Train ML models\n` +
        `/collectdata - Manually collect training data\n` +
        `/listdata - List available CSV data\n` +
        `/viewdata SYMBOL - View data for a specific symbol\n` +
        `/help - Show this help message\n\n` +
        `*How It Works:*\n` +
        `The bot uses WebSockets to track price movements in real-time and detect when price crosses above or below the ${CONFIG.EMA_PERIOD} EMA on the ${CONFIG.TIMEFRAME} timeframe for high-volume coins.\n\n` +
        `*Brain.js ML Integration:*\n` +
        `The bot collects data and trains neural network models to predict price movements after EMA crossovers. These predictions are included in the alerts to help you make more informed trading decisions.`;

    await bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
        }
    });
}

/**
 * Send top performers (gainers, losers, or by volume)
 * @param {string} chatId - Telegram chat ID
 * @param {string} type - Type of performers ('gainers', 'losers', or 'volume')
 */
async function sendTopPerformers(chatId, type = 'gainers') {
    try {
        await bot.sendMessage(chatId, 'â³ Fetching data...');

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            timeout: 10000 // 10 second timeout
        });
        let coins = response.data.filter(coin => coin.symbol.endsWith('USDT') && validateSymbol(coin.symbol));

        // Sort based on type
        if (type === 'gainers') {
            coins.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 gainers
        } else if (type === 'losers') {
            coins.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 losers
        } else if (type === 'volume') {
            coins.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            coins = coins.slice(0, 10); // Top 10 by volume
        }

        let title;
        if (type === 'gainers') title = 'ðŸ“ˆ *Top Gainers (24h)*';
        else if (type === 'losers') title = 'ðŸ“‰ *Top Losers (24h)*';
        else title = 'ðŸ’° *Highest Volume (24h)*';

        let message = `${title}\n\n`;

        coins.forEach((coin, index) => {
            const symbol = coin.symbol;
            const price = formatPrice(parseFloat(coin.lastPrice));
            const change = parseFloat(coin.priceChangePercent).toFixed(2);
            const volume = formatVolume(parseFloat(coin.quoteVolume));

            const changeEmoji = parseFloat(change) >= 0 ? 'ðŸŸ¢' : 'ðŸ”´';
            message += `${index + 1}. ${symbol}: ${price} (${changeEmoji} ${change}%) - Vol: ${volume}\n`;
        });

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“ˆ Gainers', callback_data: 'top_gainers' },
                        { text: 'ðŸ“‰ Losers', callback_data: 'top_losers' },
                        { text: 'ðŸ’° Volume', callback_data: 'top_volume' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error fetching top performers: ${error.message}`, 'error', error);
        await bot.sendMessage(chatId, 'âŒ Error fetching data');
    }
}

/**
 * Send initial startup message to Telegram
 */
async function sendStartupMessage() {
    try {
        const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
            `*Configuration:*\n` +
            `- EMA Period: ${CONFIG.EMA_PERIOD}\n` +
            `- Timeframe: ${CONFIG.TIMEFRAME}\n` +
            `- Volume Threshold: ${formatVolume(CONFIG.VOLUME_THRESHOLD)}\n` +
            `- Check Interval: ${(CONFIG.CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
            `- Alert Cooldown: ${(CONFIG.ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n` +
            `- WebSocket Monitoring: Enabled\n` +
            `- Brain.js ML: ${CONFIG.ML_ENABLED ? 'Enabled' : 'Disabled'}\n\n` +
            `Bot is now monitoring for EMA crossovers in real-time with ML predictions...`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
        log('Startup message sent to Telegram', 'success');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Started',
            `Monitoring ${CONFIG.TIMEFRAME} timeframe with ${CONFIG.EMA_PERIOD} EMA in real-time`,
            'info'
        );

        // Send the menu after startup message
        await sendMainMenu(TELEGRAM_CHAT_ID);
    } catch (error) {
        log(`Error sending startup message: ${error.message}`, 'error', error);
    }
}

/**
 * WebSocket heartbeat function to keep connections alive
 */
function startWebSocketHeartbeat() {
    // Check WebSocket connections every minute
    setInterval(() => {
        try {
            let reconnected = 0;

            for (const [symbol, ws] of activeWebSockets.entries()) {
                // If WebSocket is closed or closing, reconnect
                if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    // Only log to file, not to console
                    fs.appendFileSync(
                        path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                        `[${new Date().toISOString()}] WebSocket for ${symbol} is closed or closing. Reconnecting...\n`
                    );
                    setupSymbolWebSocket(symbol);
                    reconnected++;
                }
            }

            if (reconnected > 0) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Reconnected ${reconnected} WebSocket connections during heartbeat check\n`
                );
            }

            // Check memory usage periodically
            checkMemoryUsage();
        } catch (error) {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error in WebSocket heartbeat: ${error.message}\n`
            );
        }
    }, 60000); // Check every minute
}

// Set up message and callback query handlers
bot.on('message', handleMessage);
bot.on('callback_query', handleCallbackQuery);

// Handle process termination gracefully
process.on('SIGINT', async () => {
    try {
        log('Received SIGINT. Shutting down gracefully...', 'warning');

        // Close all WebSocket connections
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                symbol.close();
                ws.close();
                await bot.stopPolling();
                log('Bot stopped gracefully', 'info');
                process.exit(0);
            } catch (e) {
                log(`Error during process termination: ${error.message}`, 'error', error);
                process.exit(1);
            }
        }

        // Save training data before exit
        saveTrainingData();

        await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Shutting Down',
            'The bot is shutting down gracefully',
            'warning'
        );

        process.exit(0);
    } catch (error) {
        log(`Error during shutdown: ${error.message}`, 'error', error);
        process.exit(1);
    }
});

// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');

    // Show desktop notification for unhandled rejection
    showDesktopNotification(
        'Error in EMA Tracker',
        'An unhandled rejection occurred. Check logs for details.',
        'error'
    );
});

/**
 * Install required packages if not already installed
 * @returns {Promise<void>}
 */
async function installRequiredPackages() {
    const { exec } = require('child_process');
    const requiredPackages = ['ws', 'brain.js', 'csv-writer']; // WebSocket, Brain.js, and CSV writer packages

    for (const pkg of requiredPackages) {
        try {
            require.resolve(pkg);
            log(`Package ${pkg} is already installed`, 'info');
        } catch (e) {
            log(`Installing required package: ${pkg}...`, 'info');

            try {
                await new Promise((resolve, reject) => {
                    exec(`npm install ${pkg}`, (error, stdout, stderr) => {
                        if (error) {
                            log(`Error installing ${pkg}: ${error.message}`, 'error', error);
                            reject(error);
                            return;
                        }
                        log(`Successfully installed ${pkg}`, 'success');
                        resolve();
                    });
                });
            } catch (error) {
                log(`Failed to install ${pkg}: ${error.message}`, 'error', error);
                throw error;
            }
        }
    }
}

// Update your prediction calls
function makePrediction(symbol) {
    const currentData = klineCache.get(symbol).slice(-10);
    return mlModule.makePrediction(currentData);
}

/**
 * Initialize the terminal and start monitoring
 */
async function initialize() {
    try {
        // Install required packages
        await installRequiredPackages();

        // Initialize terminal and load settings
        initializeTerminal();
        loadSettings();

        console.log('\nStarting initial check...'.green);

        startWatcher();

        // Initialize ML components
        console.log('Initializing Brain.js machine learning components...'.cyan);

        // Create directories if they don't exist
        Object.values(DIRECTORIES).forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });

        // Send startup message
        await sendStartupMessage();

        await processRealtimeCandle();

        // Do initial check to populate data
        await checkEMACross();

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        //handleWebSocketReconnect();

        // Start WebSocket heartbeat
        startWebSocketHeartbeat();

        // Load ML training data
        loadTrainingData();

        // Schedule periodic saving of training data
        //setInterval(saveTrainingData, 30 * 60 * 1000); // Save every 30 minutes

        setInterval(async () => {
            if (trainingData.size > 100) {
                try {
                    await mlModule.trainModel(trainingData);
                    log('ML model training completed successfully', 'success');
                } catch (error) {
                    log(`ML training error: ${error.message}`, 'error');
                }
            }
        }, CONFIG.CHECK_INTERVAL * 6);

        // Schedule periodic memory check
        setInterval(checkMemoryUsage, 5 * 60 * 1000); // Check every 5 minutes

        // Now set flag to enable volume threshold notifications for subsequent checks
        initialLoadComplete = true;
        log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');

        // Run the check at the specified interval as a backup
        // This is in addition to the real-time WebSocket monitoring
        monitoringInterval = setInterval(async () => {
            log('Running periodic check as backup to WebSockets...', 'info');
            await checkEMACross();
        }, CONFIG.CHECK_INTERVAL);

        log('Initialization complete. Bot is now monitoring in real-time via WebSockets with Brain.js ML enhancement.', 'success');
    } catch (error) {
        log(`Failed to initialize: ${error.message}`, 'error', error);

        // Show desktop notification for startup failure
        showDesktopNotification(
            'EMA Tracker Failed to Start',
            `Error: ${error.message}`,
            'error'
        );

        // Try to send error message to Telegram
        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, `âŒ *Error Starting Bot*\n\n${error.message}`, {
                parse_mode: 'Markdown'
            });
        } catch (e) {
            log(`Could not send error message to Telegram: ${e.message}`, 'error', e);
        }
    }
}

// Start the bot
initialize();

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/**
 * EMA Tracker - Cryptocurrency monitoring system with ML capabilities
 * Monitors Binance Futures for EMA crossovers and provides alerts
 */

const axios = require('axios');
const colors = require('colors');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs').promises;
const fsSync = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');
const WebSocket = require('ws');
const { createObjectCsvWriter } = require('csv-writer');
const brain = require('brain.js');
const os = require('os');

// Custom modules
const technicalIndicators = require('./technical_indicators.js');
const { initializeMLOS } = require('./ml_model.js');
const { startWatcher } = require('./node1.js');

// ===== Error Handling =====
/**
 * Centralized error handler
 * @param {Error} error - The error object
 * @param {string} context - Context where the error occurred
 * @param {string} severity - Error severity (error, warning, info)
 * @param {Function} [callback] - Optional callback for custom handling
 */
function handleError(error, context, severity = 'error', callback = null) {
  const timestamp = new Date().toISOString();
  const errorMessage = `[${timestamp}] [${severity.toUpperCase()}] [${context}] ${error.message}`;
  
  // Console output with colors
  switch (severity) {
    case 'error':
      console.error(errorMessage.red);
      break;
    case 'warning':
      console.warn(errorMessage.yellow);
      break;
    default:
      console.info(errorMessage.gray);
  }
  
  // Log to file
  try {
    const today = new Date().toISOString().split('T')[0];
    const logDir = path.join(__dirname, 'logs');
    const logFile = path.join(logDir, `ema-tracker-${today}.log`);
    
    // Create logs directory if it doesn't exist
    if (!fsSync.existsSync(logDir)) {
      fsSync.mkdirSync(logDir, { recursive: true });
    }
    
    // Append to log file
    fsSync.appendFileSync(logFile, `${errorMessage}\n${error.stack ? `Stack: ${error.stack}\n` : ''}\n`);
  } catch (logError) {
    console.error(`Failed to write to log file: ${logError.message}`.red);
  }
  
  // Execute callback if provided
  if (typeof callback === 'function') {
    callback(error);
  }
  
  return error;
}

// ===== Configuration Management =====
// Define configuration schema with validation
const configSchema = {
  EMA_PERIOD: {
    type: 'integer',
    default: 200,
    validate: (val) => val > 0,
    errorMessage: 'EMA_PERIOD must be a positive integer'
  },
  TIMEFRAME: {
    type: 'string',
    default: '15m',
    validate: (val) => ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '12h', '1d'].includes(val),
    errorMessage: 'TIMEFRAME must be a valid Binance timeframe'
  },
  VOLUME_THRESHOLD: {
    type: 'integer',
    default: 100_000_000,
    validate: (val) => val > 0,
    errorMessage: 'VOLUME_THRESHOLD must be a positive integer'
  },
  CHECK_INTERVAL: {
    type: 'integer',
    default: 15 * 60 * 1000, // 15 minutes
    validate: (val) => val >= 60000, // At least 1 minute
    errorMessage: 'CHECK_INTERVAL must be at least 60000 ms (1 minute)'
  },
  ALERT_COOLDOWN: {
    type: 'integer',
    default: 15 * 60 * 1000, // 15 minutes
    validate: (val) => val >= 0,
    errorMessage: 'ALERT_COOLDOWN must be a non-negative integer'
  },
  ML_ENABLED: {
    type: 'boolean',
    default: true,
    validate: (val) => typeof val === 'boolean',
    errorMessage: 'ML_ENABLED must be a boolean'
  },
  MAX_WEBSOCKET_RECONNECT_ATTEMPTS: {
    type: 'integer',
    default: 5,
    validate: (val) => val > 0,
    errorMessage: 'MAX_WEBSOCKET_RECONNECT_ATTEMPTS must be a positive integer'
  },
  WEBSOCKET_RECONNECT_DELAY: {
    type: 'integer',
    default: 5000, // 5 seconds
    validate: (val) => val >= 1000, // At least 1 second
    errorMessage: 'WEBSOCKET_RECONNECT_DELAY must be at least 1000 ms (1 second)'
  },
  MAX_MEMORY_USAGE_MB: {
    type: 'integer',
    default: 900,
    validate: (val) => val > 100, // At least 100 MB
    errorMessage: 'MAX_MEMORY_USAGE_MB must be at least 100'
  },
  MAX_CACHE_SIZE: {
    type: 'integer',
    default: 1000,
    validate: (val) => val > 0,
    errorMessage: 'MAX_CACHE_SIZE must be a positive integer'
  }
};

// Load and validate configuration
function loadConfig() {
  // Start with default values
  const config = {};
  
  // Set defaults from schema
  Object.entries(configSchema).forEach(([key, schema]) => {
    config[key] = schema.default;
  });
  
  // Override with environment variables if available
  Object.keys(configSchema).forEach(key => {
    if (process.env[key] !== undefined) {
      const schema = configSchema[key];
      let value;
      
      // Parse value according to type
      switch (schema.type) {
        case 'integer':
          value = parseInt(process.env[key], 10);
          break;
        case 'boolean':
          value = process.env[key].toLowerCase() === 'true';
          break;
        default:
          value = process.env[key];
      }
      
      // Validate value
      if (schema.validate(value)) {
        config[key] = value;
      } else {
        handleError(
          new Error(`Invalid environment variable ${key}: ${schema.errorMessage}`),
          'Configuration',
          'warning'
        );
      }
    }
  });
  
  // Try to load from settings.json
  try {
    const settingsPath = path.join(__dirname, 'settings.json');
    if (fsSync.existsSync(settingsPath)) {
      const fileSettings = JSON.parse(fsSync.readFileSync(settingsPath, 'utf8'));
      
      // Override with file settings if valid
      Object.entries(fileSettings).forEach(([key, value]) => {
        if (configSchema[key] && configSchema[key].validate(value)) {
          config[key] = value;
        } else if (configSchema[key]) {
          handleError(
            new Error(`Invalid setting in settings.json for ${key}: ${configSchema[key].errorMessage}`),
            'Configuration',
            'warning'
          );
        }
      });
    }
  } catch (error) {
    handleError(error, 'Configuration', 'warning');
  }
  
  return config;
}

// Load configuration
const CONFIG = loadConfig();

// Telegram configuration - Use environment variables without fallbacks for security
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// Validate critical configuration
if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
  handleError(
    new Error('TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID environment variables must be set'),
    'Configuration',
    'error',
    () => process.exit(1)
  );
}

// Directories
const DIRECTORIES = {
  ML_DATA: path.join(__dirname, 'ml_data'),
  CSV_DATA: path.join(__dirname, 'csv_data'),
  MODEL_PATH: path.join(__dirname, 'ml_models'),
  LOG_DIR: path.join(__dirname, 'logs'),
  DATA_DIR: path.join(__dirname, 'data'),
};

// Create required directories
Object.values(DIRECTORIES).forEach(dir => {
  if (!fsSync.existsSync(dir)) {
    fsSync.mkdirSync(dir, { recursive: true });
  }
});

// State tracking
let initialLoadComplete = false;
let dataCollectionInProgress = false;
let monitoringInterval = null;

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Caches and state management
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring
const activeWebSockets = new Map(); // Track active WebSocket connections
const webSocketReconnectAttempts = new Map(); // Track reconnection attempts
const klineCache = new Map(); // Cache for kline data
const emaCache = new Map(); // Cache for calculated EMAs
const trainingData = new Map(); // Store historical data for ML training
const modelPerformance = new Map(); // Track model performance

// Initialize ML module
const mlModule = initializeMLOS(CONFIG, DIRECTORIES);

// ===== Memory Management =====
/**
 * Check memory usage and perform cleanup if necessary
 * @returns {Object} Memory status and health check
 */
function checkMemoryUsage() {
  const memoryUsage = process.memoryUsage();
  const metrics = {
    heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024),
    heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024),
    rss: Math.round(memoryUsage.rss / 1024 / 1024),
    external: Math.round(memoryUsage.external / 1024 / 1024)
  };

  // Memory usage thresholds
  const maxMemory = CONFIG.MAX_MEMORY_USAGE_MB;
  const warningThreshold = maxMemory * 0.8;
  const criticalThreshold = maxMemory * 0.95;

  // Check if we need to perform cleanup
  if (metrics.heapUsed > criticalThreshold) {
    handleError(
      new Error(`Critical memory usage: ${metrics.heapUsed}MB / ${maxMemory}MB`),
      'Memory Management',
      'error'
    );
    
    // Emergency cleanup
    performMemoryCleanup(true);
    return { isHealthy: false, metrics };
  } else if (metrics.heapUsed > warningThreshold) {
    handleError(
      new Error(`High memory usage: ${metrics.heapUsed}MB / ${maxMemory}MB`),
      'Memory Management',
      'warning'
    );
    
    // Regular cleanup
    performMemoryCleanup(false);
    return { isHealthy: true, metrics };
  }

  return { isHealthy: true, metrics };
}

/**
 * Perform memory cleanup
 * @param {boolean} emergency - Whether this is an emergency cleanup
 */
function performMemoryCleanup(emergency = false) {
  // Save important data first
  saveTrainingData().catch(error => {
    handleError(error, 'Memory Cleanup - Save Training Data', 'warning');
  });
  
  if (emergency) {
    // In emergency, clear all caches
    klineCache.clear();
    emaCache.clear();
    
    // Close inactive WebSockets
    for (const [symbol, ws] of activeWebSockets.entries()) {
      if (ws.readyState !== WebSocket.OPEN) {
        try {
          ws.terminate();
          activeWebSockets.delete(symbol);
        } catch (error) {
          // Ignore errors when closing
        }
      }
    }
  } else {
    // Regular cleanup - trim caches to reasonable sizes
    if (klineCache.size > CONFIG.MAX_CACHE_SIZE / 2) {
      // Keep only the most recently used entries
      const entries = Array.from(klineCache.entries());
      const toRemove = entries.slice(0, Math.floor(entries.length / 2));
      toRemove.forEach(([key]) => klineCache.delete(key));
    }
    
    if (emaCache.size > CONFIG.MAX_CACHE_SIZE / 2) {
      // Keep only the most recently used entries
      const entries = Array.from(emaCache.entries());
      const toRemove = entries.slice(0, Math.floor(entries.length / 2));
      toRemove.forEach(([key]) => emaCache.delete(key));
    }
  }
  
  // Force garbage collection if available
  if (global.gc) {
    global.gc();
  }
}

// ===== Input Validation =====
/**
 * Validate symbol to prevent security issues
 * @param {string} symbol - The symbol to validate
 * @returns {boolean} True if symbol is valid, false otherwise
 */
function validateSymbol(symbol) {
  // Only allow alphanumeric characters and limited special chars
  if (!symbol || typeof symbol !== 'string' || !/^[A-Z0-9]+$/.test(symbol)) {
    handleError(
      new Error(`Invalid symbol format: ${symbol}`),
      'Input Validation',
      'warning'
    );
    return false;
  }
  return true;
}

/**
 * Validate numeric input
 * @param {any} value - Value to validate
 * @param {string} name - Name of the parameter
 * @param {number} min - Minimum allowed value
 * @param {number} max - Maximum allowed value
 * @returns {boolean} True if value is valid, false otherwise
 */
function validateNumeric(value, name, min = null, max = null) {
  const num = Number(value);
  
  if (isNaN(num)) {
    handleError(
      new Error(`${name} must be a number, got: ${value}`),
      'Input Validation',
      'warning'
    );
    return false;
  }
  
  if (min !== null && num < min) {
    handleError(
      new Error(`${name} must be at least ${min}, got: ${num}`),
      'Input Validation',
      'warning'
    );
    return false;
  }
  
  if (max !== null && num > max) {
    handleError(
      new Error(`${name} must be at most ${max}, got: ${num}`),
      'Input Validation',
      'warning'
    );
    return false;
  }
  
  return true;
}

/**
 * Enhanced logging with severity levels and structured format
 * @param {string} message - The message to log
 * @param {string} type - Log type (info, success, warning, error)
 * @param {Object} details - Additional details for the log
 */
function log(message, type = 'info', details = null) {
  const timestamp = new Date().toISOString();
  let logMessage = `[${timestamp}] [${type.toUpperCase()}] ${message}`;

  // Add details if available
  if (details) {
    if (details instanceof Error) {
      logMessage += `\nStack: ${details.stack}`;
    } else if (typeof details === 'object') {
      try {
        logMessage += `\nDetails: ${JSON.stringify(details)}`;
      } catch (e) {
        logMessage += `\nDetails: [Object]`;
      }
    } else {
      logMessage += `\nDetails: ${details}`;
    }
  }

  // Console logging with colors
  switch (type) {
    case 'error':
      console.error(logMessage.red);
      break;
    case 'success':
      console.log(logMessage.green);
      break;
    case 'warning':
      console.log(logMessage.yellow);
      break;
    default:
      console.log(logMessage);
  }

  // File logging with rotation
  try {
    const today = new Date().toISOString().split('T')[0];
    const logFile = path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${today}.log`);

    // Check log file size for rotation
    let stats;
    try {
      stats = fsSync.statSync(logFile);
    } catch (e) {
      // File doesn't exist yet
    }

    // If log file is larger than 10MB, rotate it
    if (stats && stats.size > 10 * 1024 * 1024) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      fsSync.renameSync(logFile, path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${today}-${timestamp}.log`));
    }

    fsSync.appendFileSync(logFile, logMessage + '\n');
  } catch (error) {
    console.error(`Failed to write to log file: ${error.message}`.red);
  }
}

/**
 * Show desktop notification using node-notifier
 * @param {string} title - Notification title
 * @param {string} message - Notification message
 * @param {string} type - Notification type (info, warning, error)
 */
function showDesktopNotification(title, message, type = 'info') {
  try {
    notifier.notify({
      title: title,
      message: message,
      sound: true,
      wait: true,
      icon: path.join(__dirname, type === 'error' ? 'error.png' :
        type === 'warning' ? 'warning.png' : 'info.png')
    });

    log(`Desktop notification shown: ${title} - ${message}`);
  } catch (error) {
    handleError(error, 'Desktop Notification', 'warning');
  }
}

/**
 * Initialize terminal with application header
 */
function initializeTerminal() {
  console.clear();
  console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);

  const health = mlModule.systemHealthCheck();
  console.log(`System Health: ${health.memory.usage}% RAM Used | CPU Load: ${health.cpu.load[0].toFixed(2)}`.cyan);

  console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
  console.log(`Configuration: ${CONFIG.EMA_PERIOD} EMA | ${CONFIG.TIMEFRAME} Timeframe | Volume > ${CONFIG.VOLUME_THRESHOLD.toLocaleString()}`.cyan);
  console.log(`Alert Cooldown: ${CONFIG.ALERT_COOLDOWN / 60000} minutes`.magenta);
  console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
  console.log(`WebSocket Real-Time Monitoring: Enabled`.green);
  console.log(`Machine Learning: ${CONFIG.ML_ENABLED ? 'Enabled'.green : 'Disabled'.red}`);
  console.log('='.repeat(80).dim);
  console.log('\nCROSSOVER EVENTS:'.cyan.bold);

  log(`EMA Tracker started with configuration: EMA=${CONFIG.EMA_PERIOD}, Timeframe=${CONFIG.TIMEFRAME}, Volume Threshold=${CONFIG.VOLUME_THRESHOLD}, ML=${CONFIG.ML_ENABLED}`);
}

/**
 * Helper function to format volume
 * @param {number} volume - Volume to format
 * @returns {string} Formatted volume
 */
function formatVolume(volume) {
  if (!validateNumeric(volume, 'Volume', 0)) {
    return '0';
  }
  
  if (volume >= 1_000_000_000) {
    return (volume / 1_000_000_000).toFixed(2) + 'B';
  } else if (volume >= 1_000_000) {
    return (volume / 1_000_000).toFixed(2) + 'M';
  } else if (volume >= 1_000) {
    return (volume / 1_000).toFixed(2) + 'K';
  }
  return volume.toFixed(2);
}

/**
 * Format price with appropriate precision based on value
 * @param {number} price - Price to format
 * @returns {string} Formatted price
 */
function formatPrice(price) {
  if (!validateNumeric(price, 'Price', 0)) {
    return '0';
  }
  
  if (price < 0.001) return price.toFixed(8);
  if (price < 1) return price.toFixed(6);
  if (price < 100) return price.toFixed(4);
  return price.toFixed(2);
}

/**
 * Get 24hr stats for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<Object>} 24hr stats
 */
async function get24HrStats(symbol) {
  try {
    if (!validateSymbol(symbol)) {
      return { priceChangePercent: '0.00', quoteVolume: '0' };
    }

    const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
      params: { symbol },
      timeout: 10000 // 10 second timeout
    });

    return {
      priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
      quoteVolume: parseFloat(response.data.quoteVolume)
    };
  } catch (error) {
    handleError(error, `24hr Stats for ${symbol}`, 'warning');
    return { priceChangePercent: '0.00', quoteVolume: '0' };
  }
}

/**
 * Fetch Binance Futures pairs with 24hr quote volume above the threshold
 * @returns {Promise<string[]>} Array of symbol names
 */
async function getFuturesPairs() {
  try {
    const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
      timeout: 15000 // 15 second timeout
    });

    const newPairs = [];

    const pairs = response.data
      .filter(pair => {
        const volume = parseFloat(pair.quoteVolume);
        const symbol = pair.symbol;

        if (!validateSymbol(symbol)) {
          return false;
        }

        if (volume > CONFIG.VOLUME_THRESHOLD) {
          // Only track new pairs that cross threshold after initial load
          if (initialLoadComplete && !trackedPairs.has(symbol)) {
            newPairs.push({
              symbol,
              volume,
              price: parseFloat(pair.lastPrice),
              change: parseFloat(pair.priceChangePercent)
            });
          }
          trackedPairs.add(symbol);
          return true;
        }
        return false;
      })
      .map(pair => pair.symbol);

    // Alert for new pairs that crossed the volume threshold (only after initial load)
    if (newPairs.length > 0) {
      alertNewHighVolumePairs(newPairs);
    }

    return pairs;
  } catch (error) {
    handleError(error, 'Fetch Futures Pairs', 'error');
    return [];
  }
}

/**
 * Alert when new pairs cross the volume threshold
 * @param {Array<Object>} newPairs - Array of new high volume pairs
 */
async function alertNewHighVolumePairs(newPairs) {
  for (const pair of newPairs) {
    if (!validateSymbol(pair.symbol)) {
      continue;
    }

    // Create a TradingView link
    const tvSymbol = pair.symbol.replace('USDT', '');
    const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

    const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
      `*Symbol:* ${pair.symbol}\n` +
      `*Volume:* ${formatVolume(pair.volume)}\n` +
      `*Price:* ${formatPrice(pair.price)}\n` +
      `*24h Change:* ${pair.change.toFixed(2)}%\n` +
      `*Time:* ${new Date().toLocaleString()}\n\n` +
      `This pair has been added to the monitoring list.\n` +
      `[View Chart on TradingView](${tradingViewUrl})`;

    try {
      await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

      // Show desktop notification
      showDesktopNotification(
        'New High Volume Pair',
        `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
        'info'
      );

      log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');

      // Setup WebSocket for the new pair
      setupSymbolWebSocket(pair.symbol);
    } catch (error) {
      handleError(error, `New Pair Alert for ${pair.symbol}`, 'warning');
    }
  }
}

/**
 * Retrieve historical candlestick data for the given symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {Promise<Array>} Array of candlestick data
 */
async function getKlines(symbol) {
  try {
    if (!validateSymbol(symbol)) {
      return [];
    }

    const limit = CONFIG.EMA_PERIOD + 100; // Request extra candles to be safe

    const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
      params: { symbol, interval: CONFIG.TIMEFRAME, limit: limit },
      timeout: 15000 // 15 second timeout
    });

    const klines = response.data.map(k => ({
      time: k[0],
      open: parseFloat(k[1]),
      high: parseFloat(k[2]),
      low: parseFloat(k[3]),
      close: parseFloat(k[4]),
      volume: parseFloat(k[5])
    }));

    // Update the kline cache with size limit
    if (klineCache.size > CONFIG.MAX_CACHE_SIZE) {
      // Remove oldest entry
      const oldestKey = klineCache.keys().next().value;
      klineCache.delete(oldestKey);
    }
    klineCache.set(symbol, klines);

    // Calculate and cache EMA
    const closes = klines.map(k => k.close);
    
    try {
      const emaValues = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);

      // Update EMA cache with size limit
      if (emaCache.size > CONFIG.MAX_CACHE_SIZE) {
        // Remove oldest entry
        const oldestKey = emaCache.keys().next().value;
        emaCache.delete(oldestKey);
      }
      emaCache.set(symbol, emaValues);
    } catch (emaError) {
      handleError(emaError, `EMA Calculation for ${symbol}`, 'warning');
    }

    if (klines.length < CONFIG.EMA_PERIOD) {
      log(`Warning: Not enough candles for ${symbol}. Needed ${CONFIG.EMA_PERIOD}, got ${klines.length}`, 'warning');
    }

    return klines;
  } catch (error) {
    handleError(error, `Fetch Klines for ${symbol}`, 'warning');
    return [];
  }
}

/**
 * Update EMA with a new price (for real-time updates)
 * @param {string} symbol - The trading pair symbol
 * @param {number} newPrice - The new price to update EMA with
 * @returns {boolean} Success status
 */
function updateEMA(symbol, newPrice) {
  try {
    if (!validateSymbol(symbol) || !validateNumeric(newPrice, 'Price', 0)) {
      return false;
    }
    
    // Get cached EMA values
    let emaValues = emaCache.get(symbol);

    // If no cached values, we need to fetch historical data first
    if (!emaValues || emaValues.length === 0) {
      log(`No cached EMA values for ${symbol}, fetching historical data...`, 'warning');
      return false;
    }

    const k = 2 / (CONFIG.EMA_PERIOD + 1);
    const lastEMA = emaValues[emaValues.length - 1];
    const newEMA = (newPrice - lastEMA) * k + lastEMA;

    // Add the new EMA to the cache
    emaValues.push(newEMA);

    // Keep the cache size reasonable by removing older values
    if (emaValues.length > CONFIG.EMA_PERIOD * 2) {
      emaValues = emaValues.slice(-CONFIG.EMA_PERIOD * 2);
    }

    emaCache.set(symbol, emaValues);
    return true;
  } catch (error) {
    handleError(error, `Update EMA for ${symbol}`, 'warning');
    return false;
  }
}

/**
 * Send Telegram notification with enhanced formatting
 * @param {string} symbol - The trading pair symbol
 * @param {string} crossType - Type of crossover ('up' or 'down')
 * @param {number} price - Current price
 * @param {number} ema - Current EMA value
 * @param {number} difference - Percentage difference between price and EMA
 */
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
  try {
    if (!validateSymbol(symbol)) {
      return;
    }

    const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
    const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
    const formattedPrice = formatPrice(price);
    const formattedEma = formatPrice(ema);

    // Get 24hr stats for the symbol
    const stats = await get24HrStats(symbol);

    // ML Prediction
    let predictionText = '';
    if (CONFIG.ML_ENABLED) {
      try {
        const currentData = klineCache.get(symbol)?.slice(-10);
        if (currentData && currentData.length > 0) {
          const prediction = mlModule.makePrediction(currentData);
          predictionText = `\n*ML Prediction:* ${prediction.toUpperCase()}\n`;
        }
      } catch (predictionError) {
        handleError(predictionError, `ML Prediction for ${symbol}`, 'warning');
      }
    }

    // Create a TradingView link
    const tvSymbol = symbol.replace('USDT', '');
    const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

    const message = `${emoji} *${signal}* ${emoji}\n\n` +
      `*Symbol:* ${symbol}\n` +
      `*Price:* ${formattedPrice}\n` +
      `*EMA(${CONFIG.EMA_PERIOD}):* ${formattedEma}\n` +
      `*Difference:* ${difference.toFixed(2)}%\n` +
      `*24h Change:* ${stats.priceChangePercent}%\n` +
      `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
      `*Timeframe:* ${CONFIG.TIMEFRAME}\n\n` +
      predictionText +
      `*Time:* ${new Date().toLocaleString()}\n\n` +
      `[View Chart on TradingView](${tradingViewUrl})`;

    await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
      parse_mode: 'Markdown',
      disable_web_page_preview: false
    });

    // Show desktop notification
    showDesktopNotification(
      `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
      `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
      crossType === 'up' ? 'info' : 'warning'
    );

    log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
  } catch (error) {
    handleError(error, `Telegram Alert for ${symbol}`, 'error');

    // Retry with simpler message if parse_mode might be the issue
    try {
      const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
      await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
      log(`Sent simplified alert for ${symbol} after error`, 'warning');
    } catch (retryError) {
      handleError(retryError, `Simplified Alert for ${symbol}`, 'error');
    }
  }
}

/**
 * Check if we should alert for this symbol based on direction change and cooldown
 * @param {string} symbol - The trading pair symbol
 * @param {string} currentState - Current state ('above' or 'below')
 * @returns {boolean} Whether to send an alert
 */
function shouldAlert(symbol, currentState) {
  // Don't send alerts during data collection
  if (dataCollectionInProgress) {
    return false;
  }

  if (!validateSymbol(symbol)) {
    return false;
  }

  const now = Date.now();
  const previousState = coinStates.get(symbol);
  const lastAlertTime = lastAlerts.get(symbol) || 0;

  if (previousState !== currentState) {
    coinStates.set(symbol, currentState);
    if (now - lastAlertTime >= CONFIG.ALERT_COOLDOWN) {
      lastAlerts.set(symbol, now);
      return true;
    } else {
      log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
    }
  }
  return false; // No alert if state hasn't changed or cooldown active
}

// Connection state tracking map
const wsConnectionStates = new Map(); // Possible states: 'connecting', 'open', 'closing', 'closed'

/**
 * WebSocket setup for a symbol
 * @param {string} symbol - The trading pair symbol
 * @returns {WebSocket|null} The WebSocket connection
 */
function setupSymbolWebSocket(symbol) {
  try {
    if (!validateSymbol(symbol)) {
      return null;
    }
    
    // Close existing connection if any, but only if it's not in 'connecting' state
    if (activeWebSockets.has(symbol)) {
      const existingWs = activeWebSockets.get(symbol);
      const connectionState = wsConnectionStates.get(symbol) || 'unknown';

      // Only try to close if it's not already connecting (to avoid the error)
      if (connectionState !== 'connecting') {
        try {
          existingWs.close();
        } catch (e) {
          // Ignore errors when closing
        }
      }
    }

    // Set connection state to connecting
    wsConnectionStates.set(symbol, 'connecting');

    const wsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${CONFIG.TIMEFRAME}`;
    const ws = new WebSocket(wsUrl);

    // Add connection timeout
    const connectionTimeout = setTimeout(() => {
      if (wsConnectionStates.get(symbol) === 'connecting') {
        log(`WebSocket connection timeout for ${symbol}`, 'warning');
        ws.terminate();
        handleWebSocketReconnect(symbol);
      }
    }, 10000);

    ws.on('open', () => {
      clearTimeout(connectionTimeout);
      wsConnectionStates.set(symbol, 'open');
      webSocketReconnectAttempts.set(symbol, 0);
      log(`WebSocket connected for ${symbol}`, 'success');
    });

    ws.on('message', (data) => {
      try {
        const message = JSON.parse(data);
        if (message.k) {  // kline data
          const kline = message.k;

          // Process real-time data
          if (kline.x) {  // If candle closed
            processClosedCandle(symbol, kline);
          } else {  // Real-time update
            processRealtimeCandle(symbol, kline, true);
          }
        }
      } catch (error) {
        handleError(error, `WebSocket Message for ${symbol}`, 'warning');
      }
    });

    ws.on('close', () => {
      wsConnectionStates.set(symbol, 'closed');
      log(`WebSocket closed for ${symbol}`, 'info');
      handleWebSocketReconnect(symbol);
    });

    ws.on('error', (error) => {
      handleError(error, `WebSocket for ${symbol}`, 'warning');
      ws.terminate();
      handleWebSocketReconnect(symbol);
    });

    activeWebSockets.set(symbol, ws);
    return ws;
  } catch (error) {
    handleError(error, `Setup WebSocket for ${symbol}`, 'error');
    return null;
  }
}

/**
 * Handle WebSocket reconnection with exponential backoff
 * @param {string} symbol - The trading pair symbol
 */
function handleWebSocketReconnect(symbol) {
  try {
    if (!validateSymbol(symbol)) {
      return;
    }

    const attempts = webSocketReconnectAttempts.get(symbol) || 0;

    if (attempts >= CONFIG.MAX_WEBSOCKET_RECONNECT_ATTEMPTS) {
      log(`Maximum reconnect attempts reached for ${symbol}, giving up`, 'warning');
      return;
    }

    // Exponential backoff: 5s, 10s, 20s, 40s, 80s
    const delay = CONFIG.WEBSOCKET_RECONNECT_DELAY * Math.pow(2, attempts);

    log(`Scheduling WebSocket reconnect for ${symbol} in ${delay}ms (attempt ${attempts + 1}/${CONFIG.MAX_WEBSOCKET_RECONNECT_ATTEMPTS})`, 'info');

    // Increment reconnect attempts
    webSocketReconnectAttempts.set(symbol, attempts + 1);

    setTimeout(() => {
      if (trackedPairs.has(symbol)) {
        log(`Attempting to reconnect WebSocket for ${symbol}`, 'info');
        setupSymbolWebSocket(symbol);
      }
    }, delay);
  } catch (error) {
    handleError(error, `WebSocket Reconnect for ${symbol}`, 'error');
  }
}

/**
 * Collect data for ML training
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 */
async function collectDataForML(symbol, kline) {
  try {
    if (!CONFIG.ML_ENABLED || !validateSymbol(symbol)) {
      return;
    }

    // Get cached klines
    const klines = klineCache.get(symbol) || [];
    if (klines.length < 30) return; // Need enough data for indicators

    // Get closes for indicators
    const closes = klines.map(k => k.close);
    const volumes = klines.map(k => k.volume);

    // Calculate indicators with proper error handling
    let rsi, macd, bb, atr;
    
    try {
      rsi = technicalIndicators.calculateRSI(closes);
    } catch (error) {
      handleError(error, `RSI Calculation for ${symbol}`, 'warning');
      rsi = Array(closes.length).fill(50);
    }
    
    try {
      macd = technicalIndicators.calculateMACD(closes);
    } catch (error) {
      handleError(error, `MACD Calculation for ${symbol}`, 'warning');
      macd = { macd: Array(closes.length).fill(0), signal: Array(closes.length).fill(0), histogram: Array(closes.length).fill(0) };
    }
    
    try {
      bb = technicalIndicators.calculateBollingerBands(closes);
    } catch (error) {
      handleError(error, `Bollinger Bands Calculation for ${symbol}`, 'warning');
      bb = { 
        upper: Array(closes.length).fill(closes[closes.length-1] * 1.1), 
        middle: Array(closes.length).fill(closes[closes.length-1]), 
        lower: Array(closes.length).fill(closes[closes.length-1] * 0.9) 
      };
    }
    
    try {
      atr = technicalIndicators.calculateATR(klines);
    } catch (error) {
      handleError(error, `ATR Calculation for ${symbol}`, 'warning');
      atr = 0;
    }

    // Create data point
    const dataPoint = {
      timestamp: kline.t,
      symbol: symbol,
      open: parseFloat(kline.o),
      high: parseFloat(kline.h),
      low: parseFloat(kline.l),
      close: parseFloat(kline.c),
      volume: parseFloat(kline.v),
      ema: emaCache.get(symbol)[emaCache.get(symbol).length - 1],
      ema_diff: (parseFloat(kline.c) - emaCache.get(symbol)[emaCache.get(symbol).length - 1]) /
        emaCache.get(symbol)[emaCache.get(symbol).length - 1] * 100,
      rsi: rsi[rsi.length - 1],
      macd: macd.macd[macd.macd.length - 1],
      macd_signal: macd.signal[macd.signal.length - 1],
      macd_hist: macd.histogram[macd.histogram.length - 1],
      bb_upper: bb.upper[bb.upper.length - 1],
      bb_middle: bb.middle[bb.middle.length - 1],
      bb_lower: bb.lower[bb.lower.length - 1],
      bb_width: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) /
        bb.middle[bb.middle.length - 1],
      atr: atr,
      volume_change: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
      future_price_change: null, // To be filled later
      label: null // To be filled later
    };

    // Initialize training data array for this symbol if it doesn't exist
    if (!trainingData.has(symbol)) {
      trainingData.set(symbol, []);
    }

    // Add to training data
    trainingData.get(symbol).push(dataPoint);

    // Keep training data size manageable (last 1000 candles)
    if (trainingData.get(symbol).length > 1000) {
      trainingData.set(symbol, trainingData.get(symbol).slice(-1000));
    }

    // Schedule update of future price change (after 24 hours)
    setTimeout(() => updateFuturePriceChange(symbol, kline.t), 24 * 60 * 60 * 1000);
  } catch (error) {
    handleError(error, `Collect ML Data for ${symbol}`, 'warning');
  }
}

/**
 * Process closed candle data
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 * @param {boolean} dataCollectionMode - Whether in data collection mode
 */
async function processClosedCandle(symbol, kline, dataCollectionMode = false) {
  try {
    if (!validateSymbol(symbol)) {
      return;
    }

    // Get cached klines or initialize if not exists
    let klines = klineCache.get(symbol) || [];

    // Create new kline object
    const newKline = {
      time: kline.t,
      open: parseFloat(kline.o),
      high: parseFloat(kline.h),
      low: parseFloat(kline.l),
      close: parseFloat(kline.c),
      volume: parseFloat(kline.v)
    };

    // Add new kline to cache
    klines.push(newKline);

    // Keep cache size reasonable
    if (klines.length > CONFIG.EMA_PERIOD * 2) {
      klines = klines.slice(-CONFIG.EMA_PERIOD * 2);
    }

    klineCache.set(symbol, klines);

    // Get closes for EMA calculation
    const closes = klines.map(k => k.close);

    // Calculate new EMA values with error handling
    try {
      const emaValues = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);
      emaCache.set(symbol, emaValues);
    } catch (emaError) {
      handleError(emaError, `EMA Calculation for ${symbol}`, 'warning');
    }

    // Collect data for ML training
    await collectDataForML(symbol, kline);

    // Check for crossover only if not in data collection mode
    if (!dataCollectionMode && emaCache.has(symbol)) {
      const emaValues = emaCache.get(symbol);
      
      if (emaValues && emaValues.length >= 2) {
        const lastPrice = closes[closes.length - 1];
        const prevPrice = closes[closes.length - 2];
        const lastEMA = emaValues[emaValues.length - 1];
        const prevEMA = emaValues[emaValues.length - 2];

        checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA);
      }
    }
} catch (error) {
    handleError(error, `Process Closed Candle for ${symbol}`, 'error');
  }
}

/**
 * Process real-time candle updates
 * @param {string} symbol - The trading pair symbol
 * @param {Object} kline - Kline data
 * @param {boolean} logUnconfirmed - Whether to log unconfirmed crossovers
 */
async function processRealtimeCandle(symbol, kline, logUnconfirmed = true) {
  try {
    // Validate symbol
    if (!validateSymbol(symbol)) {
      return;
    }

    // Get cached klines and validate
    const klines = klineCache.get(symbol);
    if (!klines || klines.length === 0) {
      return; // No historical data yet
    }

    // Get current price and validate
    const currentPrice = parseFloat(kline.c);
    if (isNaN(currentPrice)) {
      throw new Error('Invalid price data');
    }

    // Get cached EMA values and validate
    const emaValues = emaCache.get(symbol);
    if (!emaValues || emaValues.length < 2) {
      return; // Not enough EMA values yet
    }

    // Get the last closed price and EMA
    const lastClosedPrice = klines[klines.length - 1].close;
    const lastEMA = emaValues[emaValues.length - 1];

    // Get ML prediction if enabled
    let prediction = null;
    let confidenceScore = null;

    if (CONFIG.ML_ENABLED) {
      try {
        const currentData = klines.slice(-10);
        prediction = mlModule.makePrediction(currentData);
        confidenceScore = 0.5; // Default confidence score
      } catch (predictionError) {
        handleError(predictionError, `ML Prediction for ${symbol}`, 'warning');
      }
    }

    // Determine states
    const prevState = lastClosedPrice > lastEMA ? 'above' : 'below';
    const currentState = currentPrice > lastEMA ? 'above' : 'below';

    // Calculate difference percentage
    const difference = ((currentPrice - lastEMA) / lastEMA) * 100;

    // If state changed, we have a potential real-time crossover
    if (prevState !== currentState) {
      // Only log if explicitly requested
      if (logUnconfirmed) {
        const crossType = currentState === 'above' ? 'up' : 'down';
        const crossLabel = crossType === 'up' ?
          'â–² POTENTIAL UPWARD CROSSOVER' :
          'â–¼ POTENTIAL DOWNWARD CROSSOVER';

        // Log to file only
        const logMessage = [
          `[${new Date().toISOString()}] ${crossLabel} detected for ${symbol}`,
          `Current Price: ${formatPrice(currentPrice)}`,
          `EMA(${CONFIG.EMA_PERIOD}): ${formatPrice(lastEMA)}`,
          `Difference: ${difference.toFixed(2)}%`,
          `Status: REAL-TIME (Unconfirmed)`,
          prediction !== null ? `ML Prediction: ${prediction} (Confidence: ${(confidenceScore * 100).toFixed(1)}%)` : ''
        ].join('\n');

        fsSync.appendFileSync(
          path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
          logMessage + '\n\n'
        );
      }

      // Update EMA with new price
      if (updateEMA(symbol, currentPrice)) {
        // If crossover confirmed and should alert
        if (shouldAlert(symbol, currentState)) {
          if (prediction !== null) {
            await sendTelegramAlertWithML(
              symbol,
              currentState === 'above' ? 'up' : 'down',
              currentPrice,
              lastEMA,
              difference,
              prediction,
              confidenceScore
            );
          } else {
            await sendTelegramAlert(
              symbol,
              currentState === 'above' ? 'up' : 'down',
              currentPrice,
              lastEMA,
              difference
            );
          }
        }
      }

      // Collect data for ML training if enabled
      if (CONFIG.ML_ENABLED) {
        await collectDataForML(symbol, kline);
      }
    }

    // Update coin state even if no crossover
    coinStates.set(symbol, currentState);

  } catch (error) {
    // Log error to file
    fsSync.appendFileSync(
      path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
      `[${new Date().toISOString()}] Error processing real-time candle for ${symbol}: ${error.message}\n`
    );
    
    handleError(error, `Process Realtime Candle for ${symbol}`, 'warning');
  }
}

/**
 * Check for EMA crossover and send alerts
 * @param {string} symbol - The trading pair symbol
 * @param {number} prevPrice - Previous price
 * @param {number} lastPrice - Current price
 * @param {number} prevEMA - Previous EMA
 * @param {number} lastEMA - Current EMA
 */
async function checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA) {
  try {
    if (!validateSymbol(symbol)) {
      return;
    }

    // Validate inputs
    if (!validateNumeric(prevPrice, 'Previous Price', 0) || 
        !validateNumeric(lastPrice, 'Last Price', 0) || 
        !validateNumeric(prevEMA, 'Previous EMA', 0) || 
        !validateNumeric(lastEMA, 'Last EMA', 0)) {
      return;
    }

    // Determine current state (above or below EMA)
    const currentState = lastPrice > lastEMA ? 'above' : 'below';
    const difference = (lastPrice - lastEMA) / lastEMA * 100;

    // Get ML prediction if available, but handle errors gracefully
    let prediction = null;
    let confidenceScore = null;

    if (CONFIG.ML_ENABLED) {
      try {
        // Get additional technical indicators
        const klines = klineCache.get(symbol) || [];
        if (klines.length >= 10) {
          const currentData = klines.slice(-10);
          prediction = mlModule.makePrediction(currentData);
          confidenceScore = 0.5; // Default confidence score
        }
      } catch (predictionError) {
        handleError(predictionError, `ML Prediction for ${symbol}`, 'warning');
      }
    }

    // Upward crossover: price crossing from below to above EMA
    if (prevPrice < prevEMA && lastPrice > lastEMA) {
      console.log('\n');
      console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + symbol.bold);
      console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
      console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
      console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

      if (shouldAlert(symbol, currentState)) {
        if (prediction !== null) {
          await sendTelegramAlertWithML(symbol, 'up', lastPrice, lastEMA, difference, prediction, confidenceScore);
        } else {
          await sendTelegramAlert(symbol, 'up', lastPrice, lastEMA, difference);
        }
      }
    }
    // Downward crossover: price crossing from above to below EMA
    else if (prevPrice > prevEMA && lastPrice < lastEMA) {
      console.log('\n');
      console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + symbol.bold);
      console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
      console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
      console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

      if (shouldAlert(symbol, currentState)) {
        if (prediction !== null) {
          await sendTelegramAlertWithML(symbol, 'down', lastPrice, lastEMA, difference, prediction, confidenceScore);
        } else {
          await sendTelegramAlert(symbol, 'down', lastPrice, lastEMA, difference);
        }
      }
    } else {
      // Update state even if no crossover
      coinStates.set(symbol, currentState);
    }
  } catch (error) {
    handleError(error, `Check Crossover for ${symbol}`, 'error');
  }
}

/**
 * Enhanced Telegram alert with ML prediction
 * @param {string} symbol - The trading pair symbol
 * @param {string} crossType - Type of crossover ('up' or 'down')
 * @param {number} price - Current price
 * @param {number} ema - Current EMA value
 * @param {number} difference - Percentage difference between price and EMA
 * @param {string} prediction - ML prediction value
 * @param {number} confidenceScore - Confidence score (0-1)
 */
async function sendTelegramAlertWithML(symbol, crossType, price, ema, difference, prediction, confidenceScore = 0.5) {
  try {
    if (!validateSymbol(symbol)) {
      return;
    }

    const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
    const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
    const formattedPrice = formatPrice(price);
    const formattedEma = formatPrice(ema);

    // Get 24hr stats for the symbol
    const stats = await get24HrStats(symbol);

    // Format ML prediction with confidence emoji
    let confidenceEmoji = 'âš ï¸'; // Neutral/uncertain
    if (confidenceScore > 0.8) {
      confidenceEmoji = prediction === 'bullish' ? 'ðŸ”¥' : 'â„ï¸'; // Strong signal with high confidence
    } else if (confidenceScore > 0.6) {
      confidenceEmoji = prediction === 'bullish' ? 'ðŸ“ˆ' : 'ðŸ“‰'; // Moderate signal
    }

    // Create a TradingView link
    const tvSymbol = symbol.replace('USDT', '');
    const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

    const message = `${emoji} *${signal}* ${emoji}\n\n` +
      `*Symbol:* ${symbol}\n` +
      `*Price:* ${formattedPrice}\n` +
      `*EMA(${CONFIG.EMA_PERIOD}):* ${formattedEma}\n` +
      `*Difference:* ${difference.toFixed(2)}%\n` +
      `*24h Change:* ${stats.priceChangePercent}%\n` +
      `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
      `*Timeframe:* ${CONFIG.TIMEFRAME}\n` +
      `*Brain.js Prediction:* ${confidenceEmoji} ${prediction.toUpperCase()}\n` +
      `*Confidence:* ${(confidenceScore * 100).toFixed(1)}%\n\n` +
      `*Time:* ${new Date().toLocaleString()}\n\n` +
      `[View Chart on TradingView](${tradingViewUrl})`;

    await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
      parse_mode: 'Markdown',
      disable_web_page_preview: false
    });

    // Show desktop notification
    showDesktopNotification(
      `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
      `Price: ${formattedPrice}, ML Prediction: ${prediction.toUpperCase()}`,
      crossType === 'up' ? 'info' : 'warning'
    );

    log(`ML-enhanced Telegram alert sent for ${symbol} (${crossType})`, 'success');

    // Update model performance tracking
    if (modelPerformance.has(symbol)) {
      const perf = modelPerformance.get(symbol);
      perf.predictions = (perf.predictions || 0) + 1;
      modelPerformance.set(symbol, perf);

      // Schedule a check after 24 hours to see if prediction was correct
      setTimeout(() => {
        checkPredictionAccuracy(symbol, prediction, price);
      }, 24 * 60 * 60 * 1000);
    }
  } catch (error) {
    handleError(error, `ML Telegram Alert for ${symbol}`, 'error');

    // Fall back to regular alert
    sendTelegramAlert(symbol, crossType, price, ema, difference).catch(fallbackError => {
      handleError(fallbackError, `Fallback Alert for ${symbol}`, 'error');
    });
  }
}

/**
 * Setup WebSockets for all tracked pairs
 */
async function setupAllWebSockets() {
  try {
    const pairs = await getFuturesPairs();

    log(`Setting up WebSockets for ${pairs.length} pairs`, 'info');

    // Close any existing WebSockets for pairs that are no longer tracked
    for (const [symbol, ws] of activeWebSockets.entries()) {
      if (!pairs.includes(symbol)) {
        log(`Closing WebSocket for ${symbol} (no longer tracked)`, 'info');
        try {
          ws.close();
        } catch (e) {
          // Ignore errors when closing
        }
        activeWebSockets.delete(symbol);
      }
    }

    // Setup WebSockets for all tracked pairs
    for (const symbol of pairs) {
      if (!activeWebSockets.has(symbol) || activeWebSockets.get(symbol).readyState !== WebSocket.OPEN) {
        setupSymbolWebSocket(symbol);

        // Add a small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    log(`WebSocket setup completed for ${pairs.length} pairs`, 'success');
  } catch (error) {
    handleError(error, 'Setup All WebSockets', 'error');
  }
}

/**
 * Check for EMA crossovers (traditional method, still used for initial load and periodic checks)
 */
async function checkEMACross() {
  try {
    // Check memory usage before heavy operation
    const memoryStatus = checkMemoryUsage();
    if (!memoryStatus.isHealthy) {
      log('Skipping EMA check due to high memory usage', 'warning');
      return;
    }

    const pairs = await getFuturesPairs();
    const timestamp = new Date().toLocaleString();

    console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
    process.stdout.write('Processing: '.cyan);


        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair =>
            getKlines(pair)
              .then(klines => ({ pair, klines, error: null }))
              .catch(error => ({ pair, klines: [], error }))
          );
      
          const results = await Promise.all(klinesPromises);
      
          for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');
      
            if (error || klines.length < CONFIG.EMA_PERIOD) {
              if (klines.length < CONFIG.EMA_PERIOD) {
                log(`Skipping ${pair}: Not enough candles (${klines.length}/${CONFIG.EMA_PERIOD})`, 'warning');
              }
              continue;
            }
      
            const closes = klines.map(k => k.close);
            const ema = technicalIndicators.calculateEMA(closes, CONFIG.EMA_PERIOD);
      
            // Make sure we have enough EMA values
            if (ema.length < 2) {
              log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
              continue;
            }
      
            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];
      
            // Check for crossover
            checkForCrossover(pair, prevPrice, lastPrice, prevEMA, lastEMA);
          }
      
          console.log('\n');
          console.log(`Check completed at ${timestamp}. WebSockets are now monitoring in real-time.`.gray);
          console.log('='.repeat(80).dim);
        } catch (error) {
          handleError(error, 'Check EMA Cross', 'error');
        }
      }
      
      /**
       * Update future price change for training data
       * @param {string} symbol - The trading pair symbol
       * @param {number} timestamp - Timestamp of the data point
       */
      async function updateFuturePriceChange(symbol, timestamp) {
        try {
          if (!validateSymbol(symbol)) {
            return;
          }
      
          if (!trainingData.has(symbol)) return;
      
          const data = trainingData.get(symbol);
          const dataPoint = data.find(d => d.timestamp === timestamp);
      
          if (!dataPoint) return;
      
          // Get current price
          const currentPrice = await getCurrentPrice(symbol);
          const originalPrice = dataPoint.close;
      
          // Calculate price change percentage
          const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);
      
          // Update the data point
          dataPoint.future_price_change = priceChange;
          dataPoint.label = priceChange >= 0 ? 1 : 0;
      
          log(`Updated future price change for ${symbol}: ${priceChange.toFixed(2)}%`, 'info');
      
          // Save training data to disk periodically
          saveTrainingData();
      
          // Export updated data to CSV
          if (data.filter(d => d.future_price_change !== null).length % 50 === 0) {
            // Export to CSV every 50 completed data points
            await exportToCSV(symbol, data);
          }
        } catch (error) {
          handleError(error, `Update Future Price for ${symbol}`, 'warning');
        }
      }
      
      /**
       * Get current price for a symbol
       * @param {string} symbol - The trading pair symbol
       * @returns {Promise<number>} Current price
       */
      async function getCurrentPrice(symbol) {
        try {
          if (!validateSymbol(symbol)) {
            throw new Error('Invalid symbol');
          }
      
          const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/price', {
            params: { symbol },
            timeout: 10000 // 10 second timeout
          });
          return parseFloat(response.data.price);
        } catch (error) {
          handleError(error, `Get Current Price for ${symbol}`, 'warning');
          throw error;
        }
      }
      
      /**
       * Save training data to disk
       */
      async function saveTrainingData() {
        try {
          // Check memory usage before heavy operation
          const memoryStatus = checkMemoryUsage();
          if (!memoryStatus.isHealthy) {
            log('Skipping training data save due to high memory usage', 'warning');
            return;
          }
          
          // Save each symbol's data to a separate file
          for (const [symbol, data] of trainingData.entries()) {
            if (!validateSymbol(symbol)) {
              continue;
            }
            
            if (!fsSync.existsSync(DIRECTORIES.DATA_DIR)) {
              fsSync.mkdirSync(DIRECTORIES.DATA_DIR, { recursive: true });
            }
      
            await fs.writeFile(
              path.join(DIRECTORIES.DATA_DIR, `${symbol}_training.json`),
              JSON.stringify(data)
            );
      
            // Export to CSV if we have enough data points with outcomes
            const completedData = data.filter(d => d.future_price_change !== null);
            if (completedData.length >= 50) {
              exportToCSV(symbol, data).catch(err => {
                handleError(err, `Export CSV for ${symbol}`, 'warning');
              });
            }
          }
      
          // Save model performance data
          await fs.writeFile(
            path.join(DIRECTORIES.DATA_DIR, 'model_performance.json'),
            JSON.stringify(Array.from(modelPerformance.entries()))
          );
      
          log(`Saved training data for ${trainingData.size} symbols`, 'info');
        } catch (error) {
          handleError(error, 'Save Training Data', 'error');
        }
      }
      
      /**
       * Load training data from disk
       */
      async function loadTrainingData() {
        try {
          if (!fsSync.existsSync(DIRECTORIES.DATA_DIR)) {
            fsSync.mkdirSync(DIRECTORIES.DATA_DIR, { recursive: true });
            return;
          }
      
          // Load each symbol's data
          const files = fsSync.readdirSync(DIRECTORIES.DATA_DIR).filter(f => f.endsWith('_training.json'));
      
          for (const file of files) {
            try {
              const symbol = file.replace('_training.json', '');
      
              if (!validateSymbol(symbol)) {
                log(`Skipping invalid symbol file: ${file}`, 'warning');
                continue;
              }
      
              const data = JSON.parse(await fs.readFile(path.join(DIRECTORIES.DATA_DIR, file), 'utf8'));
              trainingData.set(symbol, data);
              log(`Loaded ${data.length} training points for ${symbol}`, 'info');
            } catch (e) {
              handleError(e, `Load Data for ${file}`, 'warning');
            }
          }
      
          // Load model performance data
          const perfFile = path.join(DIRECTORIES.DATA_DIR, 'model_performance.json');
          if (fsSync.existsSync(perfFile)) {
            const perfData = JSON.parse(await fs.readFile(perfFile, 'utf8'));
            for (const [symbol, data] of perfData) {
              if (validateSymbol(symbol)) {
                modelPerformance.set(symbol, data);
              }
            }
            log(`Loaded performance data for ${modelPerformance.size} models`, 'info');
          }
        } catch (error) {
          handleError(error, 'Load Training Data', 'error');
        }
      }
      
      /**
       * Export data to CSV
       * @param {string} symbol - The trading pair symbol
       * @param {Array} data - Data to export
       * @returns {Promise<boolean>} Success status
       */
      async function exportToCSV(symbol, data) {
        try {
          if (!validateSymbol(symbol)) {
            return false;
          }
      
          // Create directory for this symbol if it doesn't exist
          const symbolDir = path.join(DIRECTORIES.CSV_DATA, symbol);
          if (!fsSync.existsSync(symbolDir)) {
            fsSync.mkdirSync(symbolDir, { recursive: true });
          }
      
          const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);
      
          // Filter out data points without future price change
          const validData = data.filter(d => d.future_price_change !== null);
      
          if (validData.length === 0) {
            log(`No valid data points with outcomes for ${symbol}`, 'warning');
            return false;
          }
      
          // Create CSV writer
          const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
              { id: 'timestamp', title: 'Timestamp' },
              { id: 'open', title: 'Open' },
              { id: 'high', title: 'High' },
              { id: 'low', title: 'Low' },
              { id: 'close', title: 'Close' },
              { id: 'volume', title: 'Volume' },
              { id: 'ema', title: 'EMA' },
              { id: 'ema_diff', title: 'EMA_Diff_Pct' },
              { id: 'rsi', title: 'RSI' },
              { id: 'macd', title: 'MACD' },
              { id: 'macd_signal', title: 'MACD_Signal' },
              { id: 'macd_hist', title: 'MACD_Hist' },
              { id: 'bb_width', title: 'BB_Width' },
              { id: 'atr', title: 'ATR' },
              { id: 'volume_change', title: 'Volume_Change' },
              { id: 'future_price_change', title: 'Future_Price_Change' }
            ]
          });
      
          // Write data to CSV
          await csvWriter.writeRecords(validData);
      
          log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
          return true;
        } catch (error) {
          handleError(error, `Export CSV for ${symbol}`, 'error');
          return false;
        }
      }
      
      /**
       * Check if a prediction was accurate after 24 hours
       * @param {string} symbol - The trading pair symbol
       * @param {string} prediction - The predicted direction
       * @param {number} originalPrice - The price at time of prediction
       */
      async function checkPredictionAccuracy(symbol, prediction, originalPrice) {
        try {
          if (!validateSymbol(symbol)) {
            return;
          }
      
          // Get current price
          const currentPrice = await getCurrentPrice(symbol);
      
          // Calculate actual price change
          const actualChange = ((currentPrice - originalPrice) / originalPrice) * 100;
      
          // Check if direction was correct
          const predictionDirection = prediction === 'bullish';
          const actualDirection = actualChange > 0;
          const isCorrect = predictionDirection === actualDirection;
      
          log(`Prediction check for ${symbol}: Predicted ${prediction}, Actual ${actualChange.toFixed(2)}%, Correct: ${isCorrect}`,
            isCorrect ? 'success' : 'warning');
      
          // Update model performance
          if (modelPerformance.has(symbol)) {
            const perf = modelPerformance.get(symbol);
            if (isCorrect) {
              perf.correctPredictions = (perf.correctPredictions || 0) + 1;
            }
      
            // Update direction accuracy
            if (perf.predictions > 0) {
              perf.directionAccuracy = perf.correctPredictions / perf.predictions;
            }
      
            modelPerformance.set(symbol, perf);
      
            // Save updated performance data
            await fs.writeFile(
              path.join(DIRECTORIES.DATA_DIR, 'model_performance.json'),
              JSON.stringify(Array.from(modelPerformance.entries()))
            );
          }
        } catch (error) {
          handleError(error, `Check Prediction for ${symbol}`, 'warning');
        }
      }
      
      /**
       * WebSocket heartbeat function to keep connections alive
       */
      function startWebSocketHeartbeat() {
        // Check WebSocket connections every minute
        setInterval(() => {
          try {
            let reconnected = 0;
      
            for (const [symbol, ws] of activeWebSockets.entries()) {
              // If WebSocket is closed or closing, reconnect
              if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                // Only log to file, not to console
                fsSync.appendFileSync(
                  path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                  `[${new Date().toISOString()}] WebSocket for ${symbol} is closed or closing. Reconnecting...\n`
                );
                setupSymbolWebSocket(symbol);
                reconnected++;
              }
            }
      
            if (reconnected > 0) {
              // Only log to file, not to console
              fsSync.appendFileSync(
                path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Reconnected ${reconnected} WebSocket connections during heartbeat check\n`
              );
            }
      
            // Check memory usage periodically
            checkMemoryUsage();
          } catch (error) {
            // Only log to file, not to console
            fsSync.appendFileSync(
              path.join(DIRECTORIES.LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
              `[${new Date().toISOString()}] Error in WebSocket heartbeat: ${error.message}\n`
            );
          }
        }, 60000); // Check every minute
      }
      
      /**
       * Initialize the terminal and start monitoring
       */
      async function initialize() {
        try {
          // Initialize terminal and load settings
          initializeTerminal();
      
          console.log('\nStarting initial check...'.green);
      
          startWatcher();
      
          // Initialize ML components
          console.log('Initializing Brain.js machine learning components...'.cyan);
      
          // Create directories if they don't exist
          Object.values(DIRECTORIES).forEach(dir => {
            if (!fsSync.existsSync(dir)) {
              fsSync.mkdirSync(dir, { recursive: true });
            }
          });
      
          // Send startup message
          await sendStartupMessage();
      
          // Do initial check to populate data
          await checkEMACross();
      
          // Setup WebSockets for all tracked pairs
          await setupAllWebSockets();
      
          // Start WebSocket heartbeat
          startWebSocketHeartbeat();
      
          // Load ML training data
          await loadTrainingData();
      
          // Schedule periodic ML model training if enabled
          if (CONFIG.ML_ENABLED) {
            setInterval(async () => {
              if (trainingData.size > 0) {
                try {
                  await mlModule.trainModel(trainingData);
                  log('ML model training completed successfully', 'success');
                } catch (error) {
                  handleError(error, 'Periodic ML Training', 'error');
                }
              }
            }, CONFIG.CHECK_INTERVAL * 6);
          }

              // Schedule periodic memory check
    setInterval(checkMemoryUsage, 5 * 60 * 1000); // Check every 5 minutes

    // Now set flag to enable volume threshold notifications for subsequent checks
    initialLoadComplete = true;
    log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');

    // Run the check at the specified interval as a backup
    // This is in addition to the real-time WebSocket monitoring
    monitoringInterval = setInterval(async () => {
      log('Running periodic check as backup to WebSockets...', 'info');
      await checkEMACross();
    }, CONFIG.CHECK_INTERVAL);

    log('Initialization complete. Bot is now monitoring in real-time via WebSockets with Brain.js ML enhancement.', 'success');
  } catch (error) {
    handleError(error, 'Initialization', 'error');

    // Show desktop notification for startup failure
    showDesktopNotification(
      'EMA Tracker Failed to Start',
      `Error: ${error.message}`,
      'error'
    );

    // Try to send error message to Telegram
    try {
      await bot.sendMessage(TELEGRAM_CHAT_ID, `âŒ *Error Starting Bot*\n\n${error.message}`, {
        parse_mode: 'Markdown'
      });
    } catch (e) {
      console.error(`Could not send error message to Telegram: ${e.message}`.red);
    }
  }
}

/**
 * Validate symbol to prevent security issues
 * @param {string} symbol - The symbol to validate
 * @returns {boolean} True if symbol is valid, false otherwise
 */
function validateSymbol(symbol) {
  // Only allow alphanumeric characters and limited special chars
  if (!symbol || typeof symbol !== 'string' || !/^[A-Z0-9]+$/.test(symbol)) {
    log(`Invalid symbol format: ${symbol}`, 'error');
    return false;
  }
  return true;
}

/**
 * Validate numeric values
 * @param {number} value - The value to validate
 * @param {string} name - Name of the value for logging
 * @param {number} min - Minimum allowed value
 * @returns {boolean} True if value is valid, false otherwise
 */
function validateNumeric(value, name, min = null) {
  if (value === undefined || value === null || isNaN(value)) {
    log(`Invalid ${name}: ${value} is not a number`, 'error');
    return false;
  }
  
  if (min !== null && value < min) {
    log(`Invalid ${name}: ${value} is less than minimum ${min}`, 'error');
    return false;
  }
  
  return true;
}

/**
 * Centralized error handler
 * @param {Error} error - The error object
 * @param {string} context - Context where the error occurred
 * @param {string} level - Error level (error, warning, info)
 */
function handleError(error, context, level = 'error') {
  const message = `Error in ${context}: ${error.message}`;
  
  // Log with appropriate level
  log(message, level, error);
  
  // For critical errors, send notification
  if (level === 'error') {
    try {
      // Show desktop notification for critical errors
      showDesktopNotification(
        `Error in ${context}`,
        error.message,
        'error'
      );
      
      // For truly critical errors, try to send Telegram alert
      if (context.includes('Initialization') || 
          context.includes('WebSocket') || 
          context.includes('Check EMA Cross')) {
        bot.sendMessage(TELEGRAM_CHAT_ID, 
          `âŒ *Error Alert*\n\n*Context:* ${context}\n*Error:* ${error.message}`, 
          { parse_mode: 'Markdown' }
        ).catch(() => {}); // Ignore errors in error handler
      }
    } catch (notificationError) {
      // Just log, don't do anything else to avoid loops
      console.error(`Failed to send error notification: ${notificationError.message}`.red);
    }
  }
}

/**
 * Check memory usage and log warning if high
 * @returns {Object} Memory status and metrics
 */
function checkMemoryUsage() {
  const memoryUsage = process.memoryUsage();
  const metrics = {
    heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024),
    heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024),
    rss: Math.round(memoryUsage.rss / 1024 / 1024),
    external: Math.round(memoryUsage.external / 1024 / 1024)
  };

  // Memory usage thresholds
  const maxMemory = CONFIG.MAX_MEMORY_USAGE_MB;
  const warningThreshold = maxMemory * 0.8;
  const criticalThreshold = maxMemory * 0.95;

  // Log warnings
  if (metrics.heapUsed > criticalThreshold) {
    log(`CRITICAL: Memory usage extremely high (${metrics.heapUsed}MB / ${maxMemory}MB). Attempting emergency cleanup.`, 'error');

    // Emergency cleanup
    klineCache.clear();
    emaCache.clear();

    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }

    return { isHealthy: false, metrics };
  } else if (metrics.heapUsed > warningThreshold) {
    log(`WARNING: High memory usage detected (${metrics.heapUsed}MB / ${metrics.heapTotal}MB)`, 'warning');
  }

  return { isHealthy: metrics.heapUsed < maxMemory, metrics };
}

/**
 * Send startup message to Telegram
 */
async function sendStartupMessage() {
  try {
    const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
      `*Configuration:*\n` +
      `- EMA Period: ${CONFIG.EMA_PERIOD}\n` +
      `- Timeframe: ${CONFIG.TIMEFRAME}\n` +
      `- Volume Threshold: ${formatVolume(CONFIG.VOLUME_THRESHOLD)}\n` +
      `- Check Interval: ${(CONFIG.CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
      `- Alert Cooldown: ${(CONFIG.ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n` +
      `- WebSocket Monitoring: Enabled\n` +
      `- Brain.js ML: ${CONFIG.ML_ENABLED ? 'Enabled' : 'Disabled'}\n\n` +
      `Bot is now monitoring for EMA crossovers in real-time with ML predictions...`;

    await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
    log('Startup message sent to Telegram', 'success');

    // Show desktop notification
    showDesktopNotification(
      'EMA Tracker Started',
      `Monitoring ${CONFIG.TIMEFRAME} timeframe with ${CONFIG.EMA_PERIOD} EMA in real-time`,
      'info'
    );
  } catch (error) {
    handleError(error, 'Send Startup Message', 'error');
  }
}

// Handle process termination gracefully
process.on('SIGINT', async () => {
  try {
    log('Received SIGINT. Shutting down gracefully...', 'warning');

    // Close all WebSocket connections
    for (const [symbol, ws] of activeWebSockets.entries()) {
      try {
        ws.close();
      } catch (e) {
        // Ignore errors when closing
      }
    }

    // Save training data before exit
    await saveTrainingData();

    try {
      await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');
      await bot.stopPolling();
    } catch (e) {
      // Ignore errors when shutting down
    }

    // Show desktop notification
    showDesktopNotification(
      'EMA Tracker Shutting Down',
      'The bot is shutting down gracefully',
      'warning'
    );

    log('Bot stopped gracefully', 'info');
    process.exit(0);
  } catch (error) {
    handleError(error, 'Shutdown', 'error');
    process.exit(1);
  }
});

// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
  handleError(
    reason instanceof Error ? reason : new Error(String(reason)), 
    'Unhandled Rejection', 
    'error'
  );

  // Show desktop notification for unhandled rejection
  showDesktopNotification(
    'Error in EMA Tracker',
    'An unhandled rejection occurred. Check logs for details.',
    'error'
  );
});

// Start the bot
initialize();



Works ml module but there was a problem with the main manue.







const axios = require('axios');
const figlet = require('figlet');
const path = require('path');
const fs = require('fs');
const TelegramBot = require('node-telegram-bot-api');
const notifier = require('node-notifier');
const WebSocket = require('ws');
const { createObjectCsvWriter } = require('csv-writer');
const brainML = require('./ml_alternative');

let initialLoadComplete = false;
// ML configuration
let ML_ENABLED = true;

// Configuration (Consider externalizing these variables or using environment variables)
let EMA_PERIOD = parseInt(process.env.EMA_PERIOD, 10) || 200;
let TIMEFRAME = process.env.TIMEFRAME || '15m';
let VOLUME_THRESHOLD = parseInt(process.env.VOLUME_THRESHOLD, 10) || 100_000_000;
const CHECK_INTERVAL = parseInt(process.env.CHECK_INTERVAL, 10) || 5 * 60 * 1000; // 5 minutes
const ALERT_COOLDOWN = parseInt(process.env.ALERT_COOLDOWN, 10) || 15 * 60 * 1000; // 15 minutes cooldown for alerts

// Telegram configuration with your provided credentials
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '7986381613:AAGPKqQuOb7d1Mb-ARuVwNPi9bS5mX3y_ZQ';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '2066913287';

// Initialize Telegram bot with polling enabled
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Store last alert times and states for each symbol
const lastAlerts = new Map();
const coinStates = new Map(); // Tracks the current state of each coin (above/below EMA)
const trackedPairs = new Set(); // Keep track of pairs we're already monitoring

// WebSocket related variables
const activeWebSockets = new Map(); // Track active WebSocket connections
const klineCache = new Map(); // Cache for kline data
const emaCache = new Map(); // Cache for calculated EMAs
const trainingData = new Map(); // Store historical data for ML training
// Track model performance
const modelPerformance = new Map();

// ML directories
const ML_DATA_DIR = path.join(__dirname, 'ml_data');
const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
const MODEL_PATH = path.join(__dirname, 'ml_models');

// Create a log directory for persistent logging
const LOG_DIR = path.join(__dirname, 'logs');
if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR);
}

// Create ML directories
if (!fs.existsSync(ML_DATA_DIR)) {
    fs.mkdirSync(ML_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(CSV_DATA_DIR)) {
    fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
}

if (!fs.existsSync(MODEL_PATH)) {
    fs.mkdirSync(MODEL_PATH, { recursive: true });
}

// Log function that writes to both console and file
function log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;

    // Console logging with colors
    switch (type) {
        case 'error':
            console.error(logMessage.red);
            break;
        case 'success':
            console.log(logMessage.green);
            break;
        case 'warning':
            console.log(logMessage.yellow);
            break;
        default:
            console.log(logMessage);
    }

    // File logging
    const logFile = path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`);
    fs.appendFileSync(logFile, logMessage + '\n');
}

// Check if Brain.js is available
function checkMLAvailability() {
    try {
        require('brain.js');
        log('Brain.js is available for ML predictions', 'success');
        return true;
    } catch (e) {
        try {
            // Try to install brain.js
            log('Brain.js not found, attempting to install...', 'warning');
            require('child_process').execSync('npm install brain.js csv-writer --save');
            log('Brain.js installed successfully', 'success');
            return true;
        } catch (installError) {
            log(`Failed to install Brain.js: ${installError.message}`, 'error');
            log('ML predictions will be disabled', 'warning');
            return false;
        }
    }
}

// Show desktop notification using node-notifier
function showDesktopNotification(title, message, type = 'info') {
    try {
        notifier.notify({
            title: title,
            message: message,
            sound: true,
            wait: true,
            icon: path.join(__dirname, type === 'error' ? 'error.png' :
                type === 'warning' ? 'warning.png' : 'info.png')
        });

        log(`Desktop notification shown: ${title} - ${message}`);
    } catch (error) {
        log(`Failed to show desktop notification: ${error.message}`, 'error');
    }
}

// Initialize terminal
function initializeTerminal() {
    console.clear();
    console.log(figlet.textSync('EMA Tracker', { font: 'Standard' }).green);
    console.log('Monitoring Binance Futures for EMA Crossovers'.yellow.bold);
    console.log(`Configuration: ${EMA_PERIOD} EMA | ${TIMEFRAME} Timeframe | Volume > ${VOLUME_THRESHOLD.toLocaleString()}`.cyan);
    console.log(`Alert Cooldown: ${ALERT_COOLDOWN / 60000} minutes`.magenta);
    console.log(`Telegram Alerts: Enabled for Chat ID ${TELEGRAM_CHAT_ID}`.blue);
    console.log(`WebSocket Real-Time Monitoring: Enabled`.green);
    console.log(`Machine Learning: ${ML_ENABLED ? 'Enabled'.green : 'Disabled'.red}`);
    console.log('='.repeat(80).dim);
    console.log('\nCROSSOVER EVENTS:'.cyan.bold);

    log(`EMA Tracker started with configuration: EMA=${EMA_PERIOD}, Timeframe=${TIMEFRAME}, Volume Threshold=${VOLUME_THRESHOLD}, ML=${ML_ENABLED}`);
}

// Helper function to format volume
function formatVolume(volume) {
    if (volume >= 1_000_000_000) {
        return (volume / 1_000_000_000).toFixed(2) + 'B';
    } else if (volume >= 1_000_000) {
        return (volume / 1_000_000).toFixed(2) + 'M';
    } else if (volume >= 1_000) {
        return (volume / 1_000).toFixed(2) + 'K';
    }
    return volume.toFixed(2);
}

// Format price with appropriate precision based on value
function formatPrice(price) {
    if (price < 0.001) return price.toFixed(8);
    if (price < 1) return price.toFixed(6);
    if (price < 100) return price.toFixed(4);
    return price.toFixed(2);
}

// Function to get 24hr stats for a symbol
async function get24HrStats(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
            params: { symbol }
        });
        return {
            priceChangePercent: parseFloat(response.data.priceChangePercent).toFixed(2),
            quoteVolume: parseFloat(response.data.quoteVolume)
        };
    } catch (error) {
        log(`Error fetching 24hr stats for ${symbol}: ${error.message}`, 'error');
        return { priceChangePercent: '0.00', quoteVolume: '0' };
    }
}

// Fetch Binance Futures pairs with 24hr quote volume above the threshold
async function getFuturesPairs() {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        const newPairs = [];

        const pairs = response.data
            .filter(pair => {
                const volume = parseFloat(pair.quoteVolume);
                const symbol = pair.symbol;

                if (volume > VOLUME_THRESHOLD) {
                    // Only track new pairs that cross threshold after initial load
                    if (initialLoadComplete && !trackedPairs.has(symbol)) {
                        newPairs.push({
                            symbol,
                            volume,
                            price: parseFloat(pair.lastPrice),
                            change: parseFloat(pair.priceChangePercent)
                        });
                    }
                    trackedPairs.add(symbol);
                    return true;
                }
                return false;
            })
            .map(pair => pair.symbol);

        // Alert for new pairs that crossed the volume threshold (only after initial load)
        if (newPairs.length > 0) {
            alertNewHighVolumePairs(newPairs);
        }

        return pairs;
    } catch (error) {
        log(`Error fetching futures pairs: ${error.message}`, 'error');
        return [];
    }
}

// Alert when new pairs cross the volume threshold
async function alertNewHighVolumePairs(newPairs) {
    for (const pair of newPairs) {
        const message = `ðŸ”” *NEW HIGH VOLUME PAIR DETECTED*\n\n` +
            `*Symbol:* ${pair.symbol}\n` +
            `*Volume:* ${formatVolume(pair.volume)}\n` +
            `*Price:* ${formatPrice(pair.price)}\n` +
            `*24h Change:* ${pair.change.toFixed(2)}%\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `This pair has been added to the monitoring list.`;

        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

            // Show desktop notification
            showDesktopNotification(
                'New High Volume Pair',
                `${pair.symbol} with volume ${formatVolume(pair.volume)} added to monitoring`,
                'info'
            );

            log(`New high volume pair alert sent for ${pair.symbol} with volume ${formatVolume(pair.volume)}`, 'success');

            // Setup WebSocket for the new pair
            setupSymbolWebSocket(pair.symbol);
        } catch (error) {
            log(`Error sending new pair alert for ${pair.symbol}: ${error.message}`, 'error');
        }
    }
}

// Retrieve historical candlestick data for the given symbol
async function getKlines(symbol) {
    try {
        const limit = EMA_PERIOD + 100; // Request extra candles to be safe

        const response = await axios.get('https://fapi.binance.com/fapi/v1/klines', {
            params: { symbol, interval: TIMEFRAME, limit: limit }
        });

        const klines = response.data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));

        // Update the kline cache
        klineCache.set(symbol, klines);

        // Calculate and cache EMA
        const closes = klines.map(k => k.close);
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        if (klines.length < EMA_PERIOD) {
            log(`Warning: Not enough candles for ${symbol}. Needed ${EMA_PERIOD}, got ${klines.length}`, 'warning');
        }

        return klines;
    } catch (error) {
        log(`Error fetching klines for ${symbol}: ${error.message}`, 'error');
        return [];
    }
}

// Calculate the EMA for an array of prices given a period
function calculateEMA(prices, period) {
    if (prices.length < period) {
        log(`Warning: Not enough prices for EMA calculation. Needed ${period}, got ${prices.length}`, 'warning');
        return [];
    }

    const k = 2 / (period + 1);
    let emaArray = [];

    // Start with the simple moving average as the first EMA
    let sma = prices.slice(0, period).reduce((sum, p) => sum + p, 0) / period;
    let ema = sma;

    // Add the first EMA (which is the SMA)
    emaArray.push(ema);

    // Calculate EMA for the remaining prices
    for (let i = period; i < prices.length; i++) {
        ema = (prices[i] - ema) * k + ema;
        emaArray.push(ema);
    }

    return emaArray;
}

// Update EMA with a new price (for real-time updates)
function updateEMA(symbol, newPrice) {
    // Get cached EMA values
    let emaValues = emaCache.get(symbol);

    // If no cached values, we need to fetch historical data first
    if (!emaValues || emaValues.length === 0) {
        log(`No cached EMA values for ${symbol}, fetching historical data...`, 'warning');
        return false;
    }

    const k = 2 / (EMA_PERIOD + 1);
    const lastEMA = emaValues[emaValues.length - 1];
    const newEMA = (newPrice - lastEMA) * k + lastEMA;

    // Add the new EMA to the cache
    emaValues.push(newEMA);

    // Keep the cache size reasonable by removing older values
    if (emaValues.length > EMA_PERIOD * 2) {
        emaValues = emaValues.slice(-EMA_PERIOD * 2);
    }

    emaCache.set(symbol, emaValues);
    return true;
}

// Send Telegram notification with enhanced formatting
async function sendTelegramAlert(symbol, crossType, price, ema, difference) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, EMA: ${formattedEma}, Diff: ${difference.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending Telegram message: ${error.message}`, 'error');

        // Retry with simpler message if parse_mode might be the issue
        try {
            const simpleMessage = `${crossType === 'up' ? 'ðŸŸ¢ BULLISH' : 'ðŸ”´ BEARISH'} SIGNAL: ${symbol} at ${formatPrice(price)}`;
            await bot.sendMessage(TELEGRAM_CHAT_ID, simpleMessage);
            log(`Sent simplified alert for ${symbol} after error`, 'warning');
        } catch (retryError) {
            log(`Failed to send even simplified message: ${retryError.message}`, 'error');
        }
    }
}

// Check if we should alert for this symbol based on direction change and cooldown
function shouldAlert(symbol, currentState) {
    const now = Date.now();
    const previousState = coinStates.get(symbol);
    const lastAlertTime = lastAlerts.get(symbol) || 0;

    if (previousState !== currentState) {
        coinStates.set(symbol, currentState);
        if (now - lastAlertTime >= ALERT_COOLDOWN) {
            lastAlerts.set(symbol, now);
            return true;
        } else {
            log(`Alert for ${symbol} skipped due to cooldown.`, 'warning');
        }
    }
    return false; // No alert if state hasn't changed or cooldown active
}

// WebSocket setup for a symbol
function setupSymbolWebSocket(symbol) {
    // Close existing connection if any
    if (activeWebSockets.has(symbol)) {
        try {
            activeWebSockets.get(symbol).close();
        } catch (e) {
            // Ignore errors when closing
        }
    }

    // Create WebSocket URL based on timeframe
    const wsSymbol = symbol.toLowerCase();
    const wsUrl = `wss://fstream.binance.com/ws/${wsSymbol}@kline_${TIMEFRAME}`;

    // Only log to file, not to console
    fs.appendFileSync(
        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
        `[${new Date().toISOString()}] Setting up WebSocket for ${symbol} on ${TIMEFRAME} timeframe\n`
    );

    try {
        const ws = new WebSocket(wsUrl);

        ws.on('open', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection established for ${symbol}\n`
            );
        });

        ws.on('message', (data) => {
            try {
                const message = JSON.parse(data);

                // Process kline data
                if (message.e === 'kline') {
                    const kline = message.k;

                    // Only process if the candle is closed or if we want to process real-time
                    if (kline.x === true) { // Candle closed
                        processClosedCandle(symbol, kline);
                    } else {
                        // Process real-time candle updates without logging unconfirmed events
                        processRealtimeCandle(symbol, kline, false); // Added parameter to suppress logging
                    }
                }
            } catch (error) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Error processing WebSocket message for ${symbol}: ${error.message}\n`
                );
            }
        });

        ws.on('error', (error) => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket error for ${symbol}: ${error.message}\n`
            );
            // Try to reconnect after a delay
            setTimeout(() => setupSymbolWebSocket(symbol), 5000);
        });

        ws.on('close', () => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] WebSocket connection closed for ${symbol}\n`
            );
            // Try to reconnect after a delay if it wasn't intentionally closed
            if (trackedPairs.has(symbol)) {
                setTimeout(() => setupSymbolWebSocket(symbol), 5000);
            }
        });

        // Store the WebSocket connection
        activeWebSockets.set(symbol, ws);

        // Initialize with historical data
        getKlines(symbol).then(() => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Historical data loaded for ${symbol}\n`
            );
        }).catch(error => {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error loading historical data for ${symbol}: ${error.message}\n`
            );
        });

        return ws;
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSocket for ${symbol}: ${error.message}\n`
        );
        return null;
    }
}

// Calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) {
        return 0;
    }

    const trueRanges = [];

    // Calculate True Range for each candle
    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        // True Range is the greatest of:
        // 1. Current High - Current Low
        // 2. |Current High - Previous Close|
        // 3. |Current Low - Previous Close|
        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        const trueRange = Math.max(tr1, tr2, tr3);
        trueRanges.push(trueRange);
    }

    // Calculate ATR (simple average of true ranges)
    if (trueRanges.length < period) {
        return trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    }

    // Use the last 'period' true ranges
    const recentTrueRanges = trueRanges.slice(-period);
    return recentTrueRanges.reduce((sum, tr) => sum + tr, 0) / period;
}

// Collect data for ML training
async function collectDataForML(symbol, kline) {
    try {
        if (!ML_ENABLED) return;

        // Get cached klines
        const klines = klineCache.get(symbol) || [];
        if (klines.length < 30) return; // Need enough data for indicators

        // Get closes for indicators
        const closes = klines.map(k => k.close);
        const volumes = klines.map(k => k.volume);

        // Calculate indicators
        const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
        const rsi = calculateRSI(closes);
        const macd = calculateMACD(closes);
        const bb = calculateBollingerBands(closes);
        const atr = calculateATR(klines);

        // Create data point
        const dataPoint = {
            timestamp: kline.t,
            symbol: symbol,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v),
            ema: emaCache.get(symbol)[emaCache.get(symbol).length - 1],
            ema_diff: (parseFloat(kline.c) - emaCache.get(symbol)[emaCache.get(symbol).length - 1]) /
                emaCache.get(symbol)[emaCache.get(symbol).length - 1] * 100,
            rsi: rsi[rsi.length - 1],
            macd: macd.macd[macd.macd.length - 1],
            macd_signal: macd.signal[macd.signal.length - 1],
            macd_hist: macd.histogram[macd.histogram.length - 1],
            bb_upper: bb.upper[bb.upper.length - 1],
            bb_middle: bb.middle[bb.middle.length - 1],
            bb_lower: bb.lower[bb.lower.length - 1],
            bb_width: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) /
                bb.middle[bb.middle.length - 1],
            atr: atr,
            volume_change: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
            future_price_change: null, // To be filled later
            label: null // To be filled later
        };

        // Initialize training data array for this symbol if it doesn't exist
        if (!trainingData.has(symbol)) {
            trainingData.set(symbol, []);
        }

        // Add to training data
        trainingData.get(symbol).push(dataPoint);

        // Keep training data size manageable (last 1000 candles)
        if (trainingData.get(symbol).length > 1000) {
            trainingData.set(symbol, trainingData.get(symbol).slice(-1000));
        }

        // Schedule update of future price change (after 24 hours)
        setTimeout(() => updateFuturePriceChange(symbol, kline.t), 8 * 60 * 60 * 1000);
    } catch (error) {
        log(`Error collecting ML data for ${symbol}: ${error.message}`, 'error');
    }
}

// Process a closed candle from WebSocket
async function processClosedCandle(symbol, kline) {
    try {
        // Get cached klines or initialize if not exists
        let klines = klineCache.get(symbol) || [];

        // Create new kline object
        const newKline = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
        };

        // Add new kline to cache
        klines.push(newKline);

        // Keep cache size reasonable
        if (klines.length > EMA_PERIOD * 2) {
            klines = klines.slice(-EMA_PERIOD * 2);
        }

        klineCache.set(symbol, klines);

        // Get closes for EMA calculation
        const closes = klines.map(k => k.close);

        // Calculate new EMA values
        const emaValues = calculateEMA(closes, EMA_PERIOD);
        emaCache.set(symbol, emaValues);

        // Collect data for ML training
        await collectDataForML(symbol, kline);

        // Check for crossover
        if (emaValues.length >= 2) {
            const lastPrice = closes[closes.length - 1];
            const prevPrice = closes[closes.length - 2];
            const lastEMA = emaValues[emaValues.length - 1];
            const prevEMA = emaValues[emaValues.length - 2];

            checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA);
        }
    } catch (error) {
        log(`Error processing closed candle for ${symbol}: ${error.message}`, 'error');
    }
}

// Process real-time candle updates
function processRealtimeCandle(symbol, kline, logUnconfirmed = true) {
    try {
        // Get cached klines
        const klines = klineCache.get(symbol);
        if (!klines || klines.length === 0) {
            return; // No historical data yet
        }

        // Get current price
        const currentPrice = parseFloat(kline.c);

        // Get cached EMA values
        const emaValues = emaCache.get(symbol);
        if (!emaValues || emaValues.length < 2) {
            return; // Not enough EMA values yet
        }

        // Get the last closed price and EMA
        const lastClosedPrice = klines[klines.length - 1].close;
        const lastEMA = emaValues[emaValues.length - 1];

        // Determine current state (above or below)
        // Determine current state (above or below EMA)
        const prevState = lastClosedPrice > lastEMA ? 'above' : 'below';
        const currentState = currentPrice > lastEMA ? 'above' : 'below';

        // If state changed, we have a potential real-time crossover
        if (prevState !== currentState) {
            // Calculate difference percentage
            const difference = (currentPrice - lastEMA) / lastEMA * 100;

            // Only log if explicitly requested (for debugging)
            if (logUnconfirmed) {
                // Log the potential crossover but don't send alert yet
                console.log('\n');
                const crossType = currentState === 'above' ? 'up' : 'down';
                const crossLabel = crossType === 'up' ?
                    'â–²'.yellow + ' POTENTIAL UPWARD CROSSOVER '.black.bgYellow :
                    'â–¼'.yellow + ' POTENTIAL DOWNWARD CROSSOVER '.black.bgYellow;

                console.log(crossLabel + ' ' + symbol.bold);
                console.log(`  Current Price: ${formatPrice(currentPrice)[crossType === 'up' ? 'green' : 'red']}`);
                console.log(`  EMA(${EMA_PERIOD}): ${formatPrice(lastEMA).cyan}`);
                console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);
                console.log(`  Status: ${'REAL-TIME (Unconfirmed)'.yellow}`);
            }

            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Potential ${currentState === 'above' ? 'upward' : 'downward'} crossover detected for ${symbol} (unconfirmed)\n`
            );
        }
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error processing real-time candle for ${symbol}: ${error.message}\n`
        );
    }
}

// Check for crossover and send alerts if needed
async function checkForCrossover(symbol, prevPrice, lastPrice, prevEMA, lastEMA) {
    try {
        // Determine current state (above or below EMA)
        const currentState = lastPrice > lastEMA ? 'above' : 'below';
        const difference = (lastPrice - lastEMA) / lastEMA * 100;

        // Get ML prediction if available, but handle errors gracefully
        let prediction = null;
        if (ML_ENABLED) {
            try {
                // Get additional technical indicators
                const klines = klineCache.get(symbol) || [];
                if (klines.length >= 30) {
                    const closes = klines.map(k => k.close);
                    const volumes = klines.map(k => k.volume || 0);

                    // Calculate indicators
                    const { calculateRSI, calculateMACD, calculateBollingerBands } = require('./technical_indicators');
                    const rsi = calculateRSI(closes);
                    const macd = calculateMACD(closes);
                    const bb = calculateBollingerBands(closes);
                    const atr = calculateATR(klines);

                    // Prepare features for prediction
                    const features = {
                        priceDiff: difference,
                        rsi: rsi[rsi.length - 1],
                        macdHist: macd.histogram[macd.histogram.length - 1],
                        bbWidth: (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.middle[bb.middle.length - 1],
                        volumeChange: volumes.length > 1 ? volumes[volumes.length - 1] / volumes[volumes.length - 2] - 1 : 0,
                        atr: atr,
                        volume24h: volumes[volumes.length - 1]
                    };

                    // Get prediction using Brain.js
                    prediction = await brainML.predictPriceChange(symbol, features);

                    if (prediction !== null) {
                        console.log(`  ML Prediction: ${prediction.toFixed(2)}% expected change`.cyan);
                    }
                }
            } catch (predictionError) {
                log(`Error getting prediction for ${symbol}: ${predictionError.message}`, 'warning');
                // Continue without prediction
            }
        }

        // Upward crossover: price crossing from below to above EMA
        if (prevPrice < prevEMA && lastPrice > lastEMA) {
            console.log('\n');
            console.log('â–²'.green + ' UPWARD CROSSOVER '.white.bgGreen + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).green}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'up', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'up', lastPrice, lastEMA, difference);
                }
            }
        }
        // Downward crossover: price crossing from above to below EMA
        else if (prevPrice > prevEMA && lastPrice < lastEMA) {
            console.log('\n');
            console.log('â–¼'.red + ' DOWNWARD CROSSOVER '.white.bgRed + ' ' + symbol.bold);
            console.log(`  Previous Price: ${formatPrice(prevPrice).gray} â†’ Current Price: ${formatPrice(lastPrice).red}`);
            console.log(`  Previous EMA: ${formatPrice(prevEMA).gray} â†’ Current EMA: ${formatPrice(lastEMA).cyan}`);
            console.log(`  Difference: ${difference.toFixed(2)}%`.yellow);

            if (shouldAlert(symbol, currentState)) {
                if (prediction !== null) {
                    await sendTelegramAlertWithML(symbol, 'down', lastPrice, lastEMA, difference, prediction);
                } else {
                    await sendTelegramAlert(symbol, 'down', lastPrice, lastEMA, difference);
                }
            }
        } else {
            // Update state even if no crossover
            coinStates.set(symbol, currentState);
        }
    } catch (error) {
        log(`Error checking for crossover for ${symbol}: ${error.message}`, 'error');
    }
}

// Setup WebSockets for all tracked pairs
async function setupAllWebSockets() {
    try {
        const pairs = await getFuturesPairs();

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Setting up WebSockets for ${pairs.length} pairs\n`
        );

        // Close any existing WebSockets for pairs that are no longer tracked
        for (const [symbol, ws] of activeWebSockets.entries()) {
            if (!pairs.includes(symbol)) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Closing WebSocket for ${symbol} (no longer tracked)\n`
                );
                try {
                    ws.close();
                } catch (e) {
                    // Ignore errors when closing
                }
                activeWebSockets.delete(symbol);
            }
        }

        // Setup WebSockets for all tracked pairs
        for (const symbol of pairs) {
            if (!activeWebSockets.has(symbol) || activeWebSockets.get(symbol).readyState !== WebSocket.OPEN) {
                setupSymbolWebSocket(symbol);

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] WebSocket setup completed for ${pairs.length} pairs\n`
        );
    } catch (error) {
        // Only log to file, not to console
        fs.appendFileSync(
            path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
            `[${new Date().toISOString()}] Error setting up WebSockets: ${error.message}\n`
        );
    }
}

// Check for EMA crossovers (traditional method, still used for initial load and periodic checks)
async function checkEMACross() {
    try {
        const pairs = await getFuturesPairs();
        const timestamp = new Date().toLocaleString();

        console.log(`\n[${timestamp}] ${'Checking'.cyan} ${pairs.length.toString().yellow} ${'pairs...'.cyan}`);
        process.stdout.write('Processing: '.cyan);

        // Fetch klines for all pairs concurrently with error handling
        const klinesPromises = pairs.map(pair =>
            getKlines(pair)
                .then(klines => ({ pair, klines, error: null }))
                .catch(error => ({ pair, klines: [], error }))
        );

        const results = await Promise.all(klinesPromises);

        for (let i = 0; i < results.length; i++) {
            const { pair, klines, error } = results[i];
            process.stdout.write('.');
            if ((i + 1) % 50 === 0) process.stdout.write('\n  ');

            if (error || klines.length < EMA_PERIOD) {
                if (klines.length < EMA_PERIOD) {
                    log(`Skipping ${pair}: Not enough candles (${klines.length}/${EMA_PERIOD})`, 'warning');
                }
                continue;
            }

            const closes = klines.map(k => k.close);
            const ema = calculateEMA(closes, EMA_PERIOD);

            // Make sure we have enough EMA values
            if (ema.length < 2) {
                log(`Skipping ${pair}: Not enough EMA values calculated`, 'warning');
                continue;
            }

            // Get the last two prices and EMAs for comparison
            const lastPrice = closes[closes.length - 1];
            const lastEMA = ema[ema.length - 1];
            const prevPrice = closes[closes.length - 2];
            const prevEMA = ema[ema.length - 2];

            // Check for crossover
            checkForCrossover(pair, prevPrice, lastPrice, prevEMA, lastEMA);
        }

        console.log('\n');
        console.log(`Check completed at ${timestamp}. WebSockets are now monitoring in real-time.`.gray);
        console.log('='.repeat(80).dim);
    } catch (error) {
        log(`Error in checkEMACross: ${error.message}`, 'error');
        console.error('Stack trace:', error.stack);
    }
}

// Update future price change for training data
async function updateFuturePriceChange(symbol, timestamp) {
    try {
        if (!trainingData.has(symbol)) return;

        const data = trainingData.get(symbol);
        const dataPoint = data.find(d => d.timestamp === timestamp);

        if (!dataPoint) return;

        // Get current price
        const currentPrice = await getCurrentPrice(symbol);
        const originalPrice = dataPoint.close;

        // Calculate price change percentage
        const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);

        // Update the data point
        Point.future_price_change = priceChange;
        Point.label = priceChange >= 0 ? 1 : 0;

        log(`Updated future price change for ${symbol}: ${priceChange.toFixed(2)}%`, 'info');

        // Save training data to disk periodically
        saveTrainingData();

        // Export updated data to CSV
        if (data.filter(d => d.future_price_change !== null).length % 50 === 0) {
            // Export to CSV every 50 completed data points
            await brainML.exportToCSV(symbol, data);
        }
    } catch (error) {
        log(`Error updating future price change: ${error.message}`, 'error');
    }
}

// Function to get current price
async function getCurrentPrice(symbol) {
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/price', {
            params: { symbol }
        });
        return parseFloat(response.data.price);
    } catch (error) {
        log(`Error getting current price for ${symbol}: ${error.message}`, 'error');
        throw error;
    }
}

// Save training data to disk
function saveTrainingData() {
    try {
        const dataDir = path.join(__dirname, 'data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir);
        }

        // Save each symbol's data to a separate file
        for (const [symbol, data] of trainingData.entries()) {
            fs.writeFileSync(
                path.join(dataDir, `${symbol}_training.json`),
                JSON.stringify(data)
            );

            // Export to CSV if we have enough data points with outcomes
            const completedData = data.filter(d => d.future_price_change !== null);
            if (completedData.length >= 50) {
                brainML.exportToCSV(symbol, data).catch(err => {
                    log(`Error exporting CSV for ${symbol}: ${err.message}`, 'error');
                });
            }
        }

        // Save model performance data
        fs.writeFileSync(
            path.join(dataDir, 'model_performance.json'),
            JSON.stringify(Array.from(modelPerformance.entries()))
        );

        log(`Saved training data for ${trainingData.size} symbols`, 'info');
    } catch (error) {
        log(`Error saving training data: ${error.message}`, 'error');
    }
}

// Add this to the initialize function
async function updateIncompleteDataPoints() {
    log('Checking for incomplete data points from previous sessions...', 'info');
    let updatedCount = 0;
    
    for (const [symbol, data] of trainingData.entries()) {
      const incompletePoints = data.filter(d => d.future_price_change === null);
      if (incompletePoints.length > 0) {
        log(`Found ${incompletePoints.length} incomplete data points for ${symbol}`, 'info');
        
        for (const point of incompletePoints) {
          try {
            const currentPrice = await getCurrentPrice(symbol);
            const originalPrice = point.close;
            const priceChange = ((currentPrice - originalPrice) / originalPrice * 100);
            point.future_price_change = priceChange;
            point.label = priceChange >= 0 ? 1 : 0;
            updatedCount++;
          } catch (error) {
            log(`Error updating data point for ${symbol}: ${error.message}`, 'error');
          }
        }
      }
    }
    
    if (updatedCount > 0) {
      log(`Updated ${updatedCount} incomplete data points from previous sessions`, 'success');
      saveTrainingData();
    }
  }  

// Load training data from disk
function loadTrainingData() {
    try {
        const dataDir = path.join(__dirname, 'data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir);
            return;
        }

        // Load each symbol's data
        const files = fs.readdirSync(dataDir).filter(f => f.endsWith('_training.json'));

        for (const file of files) {
            try {
                const symbol = file.replace('_training.json', '');
                const data = JSON.parse(fs.readFileSync(path.join(dataDir, file), 'utf8'));
                trainingData.set(symbol, data);
                log(`Loaded ${data.length} training points for ${symbol}`, 'info');
            } catch (e) {
                log(`Error loading data for ${file}: ${e.message}`, 'warning');
            }
        }

        // Load model performance data
        const perfFile = path.join(dataDir, 'model_performance.json');
        if (fs.existsSync(perfFile)) {
            const perfData = JSON.parse(fs.readFileSync(perfFile, 'utf8'));
            for (const [symbol, data] of perfData) {
                modelPerformance.set(symbol, data);
            }
            log(`Loaded performance data for ${modelPerformance.size} models`, 'info');
        }
    } catch (error) {
        log(`Error loading training data: ${error.message}`, 'error');
    }
}

// Function to train all models
async function trainAllModels(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ§  Starting Brain.js model training. This may take some time...');

        // Get all symbols with sufficient data
        const symbolsToTrain = Array.from(trainingData.keys())
            .filter(symbol => {
                const data = trainingData.get(symbol);
                const validData = data.filter(d => d.future_price_change !== null);
                return validData.length >= 100;
            });

        if (symbolsToTrain.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No symbols have enough data for training yet.');
            return;
        }

        await bot.sendMessage(chatId, `Training models for ${symbolsToTrain.length} symbols...`);

        let trainedCount = 0;
        let failedCount = 0;

        // Train models sequentially
        for (const symbol of symbolsToTrain) {
            try {
                // Export data to CSV first
                const data = trainingData.get(symbol);
                await brainML.exportToCSV(symbol, data);

                // Train model
                const result = await brainML.trainModelForSymbol(symbol);

                if (result) {
                    trainedCount++;

                    // Update model performance tracking
                    if (!modelPerformance.has(symbol)) {
                        modelPerformance.set(symbol, {
                            predictions: 0,
                            correctPredictions: 0,
                            directionAccuracy: 0,
                            mae: result.performance.mae || 0,
                            lastTraining: new Date().toISOString(),
                            dataPoints: data.filter(d => d.future_price_change !== null).length
                        });
                    } else {
                        const perf = modelPerformance.get(symbol);
                        perf.lastTraining = new Date().toISOString();
                        perf.dataPoints = data.filter(d => d.future_price_change !== null).length;
                        perf.mae = result.performance.mae || 0;
                        perf.directionAccuracy = result.performance.directionAccuracy || 0;
                        modelPerformance.set(symbol, perf);
                    }

                    // Send progress updates every 5 models
                    if (trainedCount % 5 === 0) {
                        await bot.sendMessage(
                            chatId,
                            `Progress: ${trainedCount}/${symbolsToTrain.length} models trained`
                        );
                    }
                } else {
                    failedCount++;
                }

                // Add a small delay between training sessions
                await new Promise(resolve => setTimeout(resolve, 5000));
            } catch (error) {
                log(`Error training model for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        await bot.sendMessage(
            chatId,
            `ðŸ§  *Brain.js ML Training Complete*\n\n` +
            `âœ… Successfully trained: ${trainedCount} models\n` +
            `âŒ Failed: ${failedCount} models\n\n` +
            `Use /mlstatus to check model performance.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in trainAllModels: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error training models: ${error.message}`);
    }
}

// Enhanced Telegram alert with ML prediction
async function sendTelegramAlertWithML(symbol, crossType, price, ema, difference, prediction) {
    try {
        const emoji = crossType === 'up' ? 'ðŸŸ¢' : 'ðŸ”´';
        const signal = crossType === 'up' ? 'BULLISH SIGNAL' : 'BEARISH SIGNAL';
        const formattedPrice = formatPrice(price);
        const formattedEma = formatPrice(ema);

        // Get 24hr stats for the symbol
        const stats = await get24HrStats(symbol);

        // Format ML prediction with confidence emoji
        let confidenceEmoji = 'âš ï¸'; // Neutral/uncertain
        if (Math.abs(prediction) > 3) {
            confidenceEmoji = prediction > 0 ? 'ðŸ”¥' : 'â„ï¸'; // Strong signal
        } else if (Math.abs(prediction) > 1) {
            confidenceEmoji = prediction > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰'; // Moderate signal
        }

        // Create a TradingView link
        const tvSymbol = symbol.replace('USDT', '');
        const tradingViewUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${tvSymbol}USDT.P`;

        const message = `${emoji} *${signal}* ${emoji}\n\n` +
            `*Symbol:* ${symbol}\n` +
            `*Price:* ${formattedPrice}\n` +
            `*EMA(${EMA_PERIOD}):* ${formattedEma}\n` +
            `*Difference:* ${difference.toFixed(2)}%\n` +
            `*24h Change:* ${stats.priceChangePercent}%\n` +
            `*24h Volume:* ${formatVolume(stats.quoteVolume)}\n` +
            `*Timeframe:* ${TIMEFRAME}\n` +
            `*Brain.js Prediction:* ${confidenceEmoji} ${prediction.toFixed(2)}% (24h)\n\n` +
            `*Time:* ${new Date().toLocaleString()}\n\n` +
            `[View Chart on TradingView](${tradingViewUrl})`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: false
        });

        // Show desktop notification
        showDesktopNotification(
            `${crossType === 'up' ? 'Bullish' : 'Bearish'} Signal: ${symbol}`,
            `Price: ${formattedPrice}, ML Prediction: ${prediction.toFixed(2)}%`,
            crossType === 'up' ? 'info' : 'warning'
        );

        log(`ML-enhanced Telegram alert sent for ${symbol} (${crossType})`, 'success');
    } catch (error) {
        log(`Error sending ML-enhanced Telegram message: ${error.message}`, 'error');

        // Fall back to regular alert
        sendTelegramAlert(symbol, crossType, price, ema, difference);
    }
}

// Function to manually collect data for all tracked pairs
async function startManualDataCollection(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ“Š Starting manual data collection for all tracked pairs...');

        const pairs = await getFuturesPairs();
        if (pairs.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No pairs are currently being tracked.');
            return;
        }

        await bot.sendMessage(chatId, `Collecting data for ${pairs.length} pairs...`);

        let successCount = 0;
        let failedCount = 0;

        for (const symbol of pairs) {
            try {
                // Get historical klines
                const klines = await getKlines(symbol);
                if (klines.length < 30) {
                    log(`Skipping ${symbol}: Not enough candles`, 'warning');
                    failedCount++;
                    continue;
                }

                // Process each candle
                for (let i = 0; i < klines.length; i++) {
                    // Skip very old candles
                    if (i < klines.length - 100) continue;

                    const candle = klines[i];

                    // Create kline object in the format expected by processClosedCandle
                    const klineObj = {
                        t: candle.time,
                        o: candle.open.toString(),
                        h: candle.high.toString(),
                        l: candle.low.toString(),
                        c: candle.close.toString(),
                        v: candle.volume.toString()
                    };

                    // Process this candle
                    await processClosedCandle(symbol, klineObj);
                }

                successCount++;

                // Send progress updates
                if ((successCount + failedCount) % 10 === 0) {
                    await bot.sendMessage(
                        chatId,
                        `Progress: ${successCount + failedCount}/${pairs.length} pairs processed`
                    );
                }

                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                log(`Error collecting data for ${symbol}: ${error.message}`, 'error');
                failedCount++;
            }
        }

        // Save all collected data
        saveTrainingData();

        // Send completion message
        await bot.sendMessage(
            chatId,
            `ðŸ“Š *Data Collection Complete*\n\n` +
            `âœ… Successfully collected data for ${successCount} pairs\n` +
            `âŒ Failed: ${failedCount} pairs\n\n` +
            `Future price changes will be updated in 24 hours.`,
            { parse_mode: 'Markdown' }
        );
    } catch (error) {
        log(`Error in manual data collection: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error during data collection: ${error.message}`);
    }
}

// Export data to CSV
async function exportToCSV(symbol, data) {
    try {
        // Create directory for this symbol if it doesn't exist
        const symbolDir = path.join(CSV_DATA_DIR, symbol);
        if (!fs.existsSync(symbolDir)) {
            fs.mkdirSync(symbolDir, { recursive: true });
        }

        const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

        // Filter out data points without future price change
        const validData = data.filter(d => d.future_price_change !== null);

        if (validData.length === 0) {
            log(`No valid data points with outcomes for ${symbol}`, 'warning');
            return;
        }

        // Create CSV writer
        const csvWriter = createObjectCsvWriter({
            path: csvPath,
            header: [
                { id: 'timestamp', title: 'Timestamp' },
                { id: 'open', title: 'Open' },
                { id: 'high', title: 'High' },
                { id: 'low', title: 'Low' },
                { id: 'close', title: 'Close' },
                { id: 'volume', title: 'Volume' },
                { id: 'ema', title: 'EMA' },
                { id: 'ema_diff', title: 'EMA_Diff_Pct' },
                { id: 'rsi', title: 'RSI' },
                { id: 'macd', title: 'MACD' },
                { id: 'macd_signal', title: 'MACD_Signal' },
                { id: 'macd_hist', title: 'MACD_Hist' },
                { id: 'bb_width', title: 'BB_Width' },
                { id: 'atr', title: 'ATR' },
                { id: 'volume_change', title: 'Volume_Change' },
                { id: 'future_price_change', title: 'Future_Price_Change' }
            ]
        });

        // Write data to CSV
        await csvWriter.writeRecords(validData);

        log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
        return true;
    } catch (error) {
        log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error');
        return false;
    }
}

// Send model performance data
async function sendModelPerformance(chatId) {
    try {
        if (modelPerformance.size === 0) {
            await bot.sendMessage(chatId, 'âŒ No model performance data available yet.');
            return;
        }

        let message = '*Brain.js Model Performance*\n\n';

        // Sort symbols by direction accuracy
        const sortedSymbols = Array.from(modelPerformance.keys())
            .sort((a, b) => {
                const aMetrics = modelPerformance.get(a);
                const bMetrics = modelPerformance.get(b);
                return (bMetrics.directionAccuracy || 0) - (aMetrics.directionAccuracy || 0);
            })
            .slice(0, 10); // Top 10 performing models

        for (const symbol of sortedSymbols) {
            const metrics = modelPerformance.get(symbol);
            if (!metrics.dataPoints || metrics.dataPoints < 50) continue; // Skip models with few data points

            message += `*${symbol}*\n` +
                `- Direction Accuracy: ${((metrics.directionAccuracy || 0) * 100).toFixed(2)}%\n` +
                `- Mean Absolute Error: ${(metrics.mae || 0).toFixed(4)}\n` +
                `- Data Points: ${metrics.dataPoints}\n` +
                `- Last Trained: ${new Date(metrics.lastTraining).toLocaleString()}\n\n`;
        }

        // Add information about CSV data
        const csvSymbols = fs.existsSync(CSV_DATA_DIR) ?
            fs.readdirSync(CSV_DATA_DIR).filter(item => fs.statSync(path.join(CSV_DATA_DIR, item)).isDirectory()) : [];

        if (csvSymbols.length > 0) {
            message += `\n*CSV Training Data Available*\n`;
            message += `${csvSymbols.length} symbols have CSV data for visualization.\n`;
            message += `CSV files are stored in: ${CSV_DATA_DIR}\n\n`;
            message += `You can use these CSV files with external tools for data analysis.`;
        }

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Train All Models', callback_data: 'train_models' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending model performance: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching model performance data');
    }
}

// Command handler
function handleMessage(msg) {
    const chatId = msg.chat.id;

    if (msg.text === '/start' || msg.text === '/menu') {
        sendMainMenu(chatId);
    } else if (msg.text === '/status') {
        sendStatusUpdate(chatId);
    } else if (msg.text === '/settings') {
        sendSettingsMenu(chatId);
    } else if (msg.text === '/help') {
        sendHelpMessage(chatId);
    } else if (msg.text === '/top') {
        sendTopPerformers(chatId);
    } else if (msg.text === '/refresh') {
        refreshWebSockets(chatId);
    } else if (msg.text === '/mlstatus') {
        sendModelPerformance(chatId);
    } else if (msg.text === '/train') {
        trainAllModels(chatId);
    } else if (msg.text === '/collectdata') {
        startManualDataCollection(chatId);
    } else if (msg.text === '/listdata') {
        listAvailableCSVData(chatId);
    } else if (msg.text && msg.text.startsWith('/viewdata ')) {
        const symbol = msg.text.split(' ')[1].toUpperCase();
        viewSymbolCSVData(chatId, symbol);
    }
}

// List available CSV data
async function listAvailableCSVData(chatId) {
    try {
        if (!fs.existsSync(CSV_DATA_DIR)) {
            await bot.sendMessage(chatId, 'âŒ No CSV data directory found. Run data collection first.');
            return;
        }

        const symbols = fs.readdirSync(CSV_DATA_DIR)
            .filter(item => fs.statSync(path.join(CSV_DATA_DIR, item)).isDirectory());

        if (symbols.length === 0) {
            await bot.sendMessage(chatId, 'âŒ No CSV data available yet. Run data collection first.');
            return;
        }

        // Get data points count for each symbol
        const symbolData = [];
        for (const symbol of symbols) {
            const csvPath = path.join(CSV_DATA_DIR, symbol, `${symbol}_training_data.csv`);
            if (fs.existsSync(csvPath)) {
                const stats = fs.statSync(csvPath);
                const fileSize = (stats.size / 1024).toFixed(2) + ' KB';

                // Count lines (data points) - simple approach
                const content = fs.readFileSync(csvPath, 'utf8');
                const lines = content.split('\n').length - 1; // -1 for header

                symbolData.push({
                    symbol,
                    dataPoints: lines,
                    fileSize
                });
            }
        }

        // Sort by data points (descending)
        symbolData.sort((a, b) => b.dataPoints - a.dataPoints);

        let message = '*Available CSV Training Data*\n\n';

        for (const data of symbolData) {
            message += `*${data.symbol}*: ${data.dataPoints} data points (${data.fileSize})\n`;
        }

        message += '\nUse /viewdata SYMBOL to get details about a specific symbol\'s data.';

        // Create inline keyboard with symbols
        const keyboard = [];
        const buttonsPerRow = 3;

        for (let i = 0; i < symbolData.length; i += buttonsPerRow) {
            const row = [];
            for (let j = 0; j < buttonsPerRow && i + j < symbolData.length; j++) {
                row.push({
                    text: symbolData[i + j].symbol,
                    callback_data: `viewdata_${symbolData[i + j].symbol}`
                });
            }
            keyboard.push(row);
        }

        keyboard.push([{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]);

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        log(`Error listing CSV data: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error listing CSV data: ${error.message}`);
    }
}

// View CSV data for a specific symbol
async function viewSymbolCSVData(chatId, symbol) {
    try {
        const csvPath = path.join(CSV_DATA_DIR, symbol, `${symbol}_training_data.csv`);

        if (!fs.existsSync(csvPath)) {
            await bot.sendMessage(chatId, `âŒ No CSV data found for ${symbol}`);
            return;
        }

        // Get file stats
        const stats = fs.statSync(csvPath);
        const fileSize = (stats.size / 1024).toFixed(2) + ' KB';
        const modifiedDate = new Date(stats.mtime).toLocaleString();

        // Count lines (data points)
        const content = fs.readFileSync(csvPath, 'utf8');
        const lines = content.split('\n');
        const dataPoints = lines.length - 1; // -1 for header

        // Get a preview of the data (first 5 rows)
        const preview = lines.slice(0, 6).join('\n');

        // Calculate some basic stats from the data
        const rows = content.split('\n').slice(1).filter(row => row.trim() !== '');

        let avgPriceChange = 0;
        let positiveChanges = 0;
        let negativeChanges = 0;

        for (const row of rows) {
            const columns = row.split(',');
            if (columns.length > 15) { // Make sure we have enough columns
                const priceChange = parseFloat(columns[15]); // Future_Price_Change column
                if (!isNaN(priceChange)) {
                    avgPriceChange += priceChange;
                    if (priceChange > 0) positiveChanges++;
                    else if (priceChange < 0) negativeChanges++;
                }
            }
        }

        avgPriceChange = avgPriceChange / rows.length;

        // Create message
        let message = `*CSV Data for ${symbol}*\n\n`;
        message += `ðŸ“Š *Statistics:*\n`;
        message += `- Data Points: ${dataPoints}\n`;
        message += `- File Size: ${fileSize}\n`;
        message += `- Last Modified: ${modifiedDate}\n`;
        message += `- Avg Price Change: ${avgPriceChange.toFixed(2)}%\n`;
        message += `- Positive Changes: ${positiveChanges} (${((positiveChanges / rows.length) * 100).toFixed(2)}%)\n`;
        message += `- Negative Changes: ${negativeChanges} (${((negativeChanges / rows.length) * 100).toFixed(2)}%)\n\n`;

        // Check if model exists for this symbol
        const modelPath = path.join(MODEL_PATH, symbol, 'model.json');
        if (fs.existsSync(modelPath)) {
            message += `âœ… *Brain.js model is available for this symbol*\n\n`;
        } else {
            message += `âš ï¸ *No Brain.js model trained yet for this symbol*\n\n`;
        }

        message += `The CSV file contains the following columns:\n`;
        message += `Timestamp, Open, High, Low, Close, Volume, EMA, EMA_Diff_Pct, RSI, MACD, MACD_Signal, MACD_Hist, BB_Width, ATR, Volume_Change, Future_Price_Change\n\n`;

        message += `You can use this data with external tools for visualization and analysis.`;

        // Send message with inline keyboard
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“Š List All Data', callback_data: 'list_data' },
                        { text: 'ðŸ§  Train Model', callback_data: 'train_models' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });

        // Send CSV file
        await bot.sendDocument(chatId, csvPath, {
            caption: `CSV training data for ${symbol} with ${dataPoints} data points`
        });
    } catch (error) {
        log(`Error viewing CSV data for ${symbol}: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error viewing CSV data: ${error.message}`);
    }
}

// Refresh WebSockets command
async function refreshWebSockets(chatId) {
    try {
        await bot.sendMessage(chatId, 'ðŸ”„ Refreshing WebSocket connections...');

        // Close all existing WebSockets
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
            } catch (e) {
                // Ignore errors when closing
            }
            activeWebSockets.delete(symbol);
        }

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        await bot.sendMessage(chatId, 'âœ… WebSocket connections refreshed successfully!');
    } catch (error) {
        log(`Error refreshing WebSockets: ${error.message}`, 'error');
        await bot.sendMessage(chatId, `âŒ Error refreshing WebSockets: ${error.message}`);
    }
}

// Callback query handler for inline buttons
async function handleCallbackQuery(callbackQuery) {
    const action = callbackQuery.data;
    const chatId = callbackQuery.message.chat.id;

    try {
        if (action === 'status') {
            await sendStatusUpdate(chatId);
        } else if (action === 'settings') {
            await sendSettingsMenu(chatId);
        } else if (action === 'top_gainers') {
            await sendTopPerformers(chatId, 'gainers');
        } else if (action === 'top_losers') {
            await sendTopPerformers(chatId, 'losers');
        } else if (action === 'top_volume') {
            await sendTopPerformers(chatId, 'volume');
        } else if (action === 'menu') {
            await sendMainMenu(chatId);
        } else if (action === 'help') {
            await sendHelpMessage(chatId);
        } else if (action === 'refresh_ws') {
            await refreshWebSockets(chatId);
        } else if (action.startsWith('timeframe_')) {
            const newTimeframe = action.replace('timeframe_', '');
            // Update the timeframe
            TIMEFRAME = newTimeframe;
            log(`Timeframe updated to ${newTimeframe}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new timeframe
            await bot.sendMessage(chatId, `âœ… Timeframe updated to ${newTimeframe}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('ema_')) {
            const newEma = parseInt(action.replace('ema_', ''), 10);
            // Update the EMA period
            EMA_PERIOD = newEma;
            log(`EMA period updated to ${newEma}`, 'success');
            saveSettings();

            // Refresh WebSockets to use the new EMA period
            await bot.sendMessage(chatId, `âœ… EMA period updated to ${newEma}. Refreshing WebSockets...`);
            await refreshWebSockets(chatId);

            await sendSettingsMenu(chatId);
        } else if (action.startsWith('volume_')) {
            const newVolume = parseInt(action.replace('volume_', ''), 10);
            // Update the volume threshold
            VOLUME_THRESHOLD = newVolume;
            log(`Volume threshold updated to ${newVolume}`, 'success');
            saveSettings();

            // Refresh tracked pairs based on new volume threshold
            await bot.sendMessage(chatId, `âœ… Volume threshold updated to ${formatVolume(newVolume)}. Refreshing tracked pairs...`);
            await setupAllWebSockets();

            await sendSettingsMenu(chatId);
        } else if (action === 'ml_status') {
            await sendModelPerformance(chatId);
        } else if (action === 'train_models') {
            await trainAllModels(chatId);
        } else if (action === 'list_data') {
            await listAvailableCSVData(chatId);
        } else if (action === 'collect_data') {
            await startManualDataCollection(chatId);
        } else if (action.startsWith('viewdata_')) {
            const symbol = action.replace('viewdata_', '');
            await viewSymbolCSVData(chatId, symbol);
        }

        // Answer callback query to remove loading state
        await bot.answerCallbackQuery(callbackQuery.id);
    } catch (error) {
        log(`Error handling callback query: ${error.message}`, 'error');
        await bot.answerCallbackQuery(callbackQuery.id, { text: 'An error occurred' });
    }
}

// Add this function to save settings to a file
function saveSettings() {
    try {
        const settings = {
            EMA_PERIOD,
            TIMEFRAME,
            VOLUME_THRESHOLD,
            CHECK_INTERVAL,
            ALERT_COOLDOWN,
            ML_ENABLED
        };

        fs.writeFileSync(
            path.join(__dirname, 'settings.json'),
            JSON.stringify(settings, null, 2)
        );
        log('Settings saved to file', 'success');
    } catch (error) {
        log(`Error saving settings: ${error.message}`, 'error');
    }
}

// Add this function to load settings from file
function loadSettings() {
    try {
        const settingsPath = path.join(__dirname, 'settings.json');
        if (fs.existsSync(settingsPath)) {
            const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

            // Update variables with saved settings
            EMA_PERIOD = settings.EMA_PERIOD || EMA_PERIOD;
            TIMEFRAME = settings.TIMEFRAME || TIMEFRAME;
            VOLUME_THRESHOLD = settings.VOLUME_THRESHOLD || VOLUME_THRESHOLD;
            ML_ENABLED = settings.ML_ENABLED !== undefined ? settings.ML_ENABLED : ML_ENABLED;

            log('Settings loaded from file', 'success');
        }
    } catch (error) {
        log(`Error loading settings: ${error.message}`, 'error');
    }
}

// Send main menu with Brain.js options
async function sendMainMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [{ text: 'ðŸ“Š Status', callback_data: 'status' }],
            [{ text: 'âš™ï¸ Settings', callback_data: 'settings' }],
            [
                { text: 'ðŸ“ˆ Top Gainers', callback_data: 'top_gainers' },
                { text: 'ðŸ“‰ Top Losers', callback_data: 'top_losers' }
            ],
            [{ text: 'ðŸ’° Highest Volume', callback_data: 'top_volume' }],
            [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
            [
                { text: 'ðŸ§  ML Status', callback_data: 'ml_status' },
                { text: 'ðŸ”¬ Train Models', callback_data: 'train_models' }
            ],
            [
                { text: 'ðŸ“Š List Data', callback_data: 'list_data' },
                { text: 'ðŸ“¥ Collect Data', callback_data: 'collect_data' }
            ],
            [{ text: 'â“ Help', callback_data: 'help' }]
        ]
    };

    await bot.sendMessage(chatId, '*EMA Tracker Bot Menu*\nSelect an option:', {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send status update
async function sendStatusUpdate(chatId) {
    try {
        const pairs = await getFuturesPairs();
        const activeWsCount = Array.from(activeWebSockets.values())
            .filter(ws => ws.readyState === WebSocket.OPEN).length;

        // Get Brain.js model stats
        const modelCount = fs.existsSync(MODEL_PATH) ?
            fs.readdirSync(MODEL_PATH).filter(item => fs.existsSync(path.join(MODEL_PATH, item, 'model.json'))).length : 0;

        // Get data collection stats
        const dataPointCount = Array.from(trainingData.entries())
            .reduce((sum, [_, data]) => sum + data.length, 0);

        const message = `*EMA Tracker Status*\n\n` +
            `*Active Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Monitoring: ${pairs.length} pairs\n` +
            `- Active WebSockets: ${activeWsCount}/${pairs.length}\n` +
            `- Last Check: ${new Date().toLocaleString()}\n\n` +
            `*Brain.js ML Status:*\n` +
            `- ML Enabled: ${ML_ENABLED ? 'âœ…' : 'âŒ'}\n` +
            `- Trained Models: ${modelCount}\n` +
            `- Data Points Collected: ${dataPointCount}\n\n` +
            `Bot is actively monitoring for EMA crossovers in real-time.`;

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ðŸ”„ Refresh WebSockets', callback_data: 'refresh_ws' }],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error sending status update: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching status');
    }
}

// Send settings menu
async function sendSettingsMenu(chatId) {
    const keyboard = {
        inline_keyboard: [
            [
                { text: '1m', callback_data: 'timeframe_1m' },
                { text: '5m', callback_data: 'timeframe_5m' },
                { text: '15m', callback_data: 'timeframe_15m' },
                { text: '1h', callback_data: 'timeframe_1h' },
                { text: '4h', callback_data: 'timeframe_4h' }
            ],
            [
                { text: 'EMA 50', callback_data: 'ema_50' },
                { text: 'EMA 100', callback_data: 'ema_100' },
                { text: 'EMA 200', callback_data: 'ema_200' }
            ],
            [
                { text: 'Vol 50M', callback_data: 'volume_50000000' },
                { text: 'Vol 100M', callback_data: 'volume_100000000' },
                { text: 'Vol 200M', callback_data: 'volume_200000000' }
            ],
            [
                { text: ML_ENABLED ? 'ðŸ§  Disable ML' : 'ðŸ§  Enable ML', callback_data: 'toggle_ml' }
            ],
            [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
        ]
    };

    await bot.sendMessage(chatId, `*Settings*\n\nCurrent Configuration:\n- EMA: ${EMA_PERIOD}\n- Timeframe: ${TIMEFRAME}\n- Volume Threshold: ${formatVolume(VOLUME_THRESHOLD)}\n- ML Enabled: ${ML_ENABLED ? 'âœ…' : 'âŒ'}\n\nSelect a new setting:`, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
    });
}

// Send help message
async function sendHelpMessage(chatId) {
    const helpText = `*EMA Tracker Bot Help*\n\n` +
        `This bot monitors Binance Futures markets for EMA crossovers and sends alerts when they occur.\n\n` +
        `*Available Commands:*\n` +
        `/menu - Show the main menu\n` +
        `/status - Check bot status\n` +
        `/settings - Configure bot settings\n` +
        `/top - View top performing coins\n` +
        `/refresh - Refresh WebSocket connections\n` +
        `/mlstatus - Check ML model performance\n` +
        `/train - Train ML models\n` +
        `/collectdata - Manually collect training data\n` +
        `/listdata - List available CSV data\n` +
        `/viewdata SYMBOL - View data for a specific symbol\n` +
        `/help - Show this help message\n\n` +
        `*How It Works:*\n` +
        `The bot uses WebSockets to track price movements in real-time and detect when price crosses above or below the ${EMA_PERIOD} EMA on the ${TIMEFRAME} timeframe for high-volume coins.\n\n` +
        `*Brain.js ML Integration:*\n` +
        `The bot collects data and trains neural network models to predict price movements after EMA crossovers. These predictions are included in the alerts to help you make more informed trading decisions.`;

    await bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]]
        }
    });
}

// Send top performers (gainers, losers, or by volume)
async function sendTopPerformers(chatId, type = 'gainers') {
    try {
        await bot.sendMessage(chatId, 'â³ Fetching data...');

        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        let coins = response.data.filter(coin => coin.symbol.endsWith('USDT'));

        // Sort based on type
        if (type === 'gainers') {
            coins.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 gainers
        } else if (type === 'losers') {
            coins.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
            coins = coins.slice(0, 10); // Top 10 losers
        } else if (type === 'volume') {
            coins.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
            coins = coins.slice(0, 10); // Top 10 by volume
        }

        let title;
        if (type === 'gainers') title = 'ðŸ“ˆ *Top Gainers (24h)*';
        else if (type === 'losers') title = 'ðŸ“‰ *Top Losers (24h)*';
        else title = 'ðŸ’° *Highest Volume (24h)*';

        let message = `${title}\n\n`;

        coins.forEach((coin, index) => {
            const symbol = coin.symbol;
            const price = formatPrice(parseFloat(coin.lastPrice));
            const change = parseFloat(coin.priceChangePercent).toFixed(2);
            const volume = formatVolume(parseFloat(coin.quoteVolume));

            const changeEmoji = parseFloat(change) >= 0 ? 'ðŸŸ¢' : 'ðŸ”´';
            message += `${index + 1}. ${symbol}: ${price} (${changeEmoji} ${change}%) - Vol: ${volume}\n`;
        });

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        { text: 'ðŸ“ˆ Gainers', callback_data: 'top_gainers' },
                        { text: 'ðŸ“‰ Losers', callback_data: 'top_losers' },
                        { text: 'ðŸ’° Volume', callback_data: 'top_volume' }
                    ],
                    [{ text: 'ðŸ”™ Back to Menu', callback_data: 'menu' }]
                ]
            }
        });
    } catch (error) {
        log(`Error fetching top performers: ${error.message}`, 'error');
        await bot.sendMessage(chatId, 'âŒ Error fetching data');
    }
}

// Send initial startup message to Telegram
async function sendStartupMessage() {
    try {
        const message = `ðŸ¤– *EMA Tracker Bot Started* ðŸ¤–\n\n` +
            `*Configuration:*\n` +
            `- EMA Period: ${EMA_PERIOD}\n` +
            `- Timeframe: ${TIMEFRAME}\n` +
            `- Volume Threshold: ${VOLUME_THRESHOLD.toLocaleString()}\n` +
            `- Check Interval: ${(CHECK_INTERVAL / 60000).toFixed(1)} minutes\n` +
            `- Alert Cooldown: ${(ALERT_COOLDOWN / 60000).toFixed(1)} minutes\n` +
            `- WebSocket Monitoring: Enabled\n` +
            `- Brain.js ML: ${ML_ENABLED ? 'Enabled' : 'Disabled'}\n\n` +
            `Bot is now monitoring for EMA crossovers in real-time with ML predictions...`;

        await bot.sendMessage(TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });
        log('Startup message sent to Telegram', 'success');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Started',
            `Monitoring ${TIMEFRAME} timeframe with ${EMA_PERIOD} EMA in real-time`,
            'info'
        );

        // Send the menu after startup message
        await sendMainMenu(TELEGRAM_CHAT_ID);
    } catch (error) {
        log(`Error sending startup message: ${error.message}`, 'error');
    }
}

// WebSocket heartbeat function to keep connections alive
function startWebSocketHeartbeat() {
    // Check WebSocket connections every minute
    setInterval(() => {
        try {
            let reconnected = 0;

            for (const [symbol, ws] of activeWebSockets.entries()) {
                // If WebSocket is closed or closing, reconnect
                if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    // Only log to file, not to console
                    fs.appendFileSync(
                        path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                        `[${new Date().toISOString()}] WebSocket for ${symbol} is closed or closing. Reconnecting...\n`
                    );
                    setupSymbolWebSocket(symbol);
                    reconnected++;
                }
            }

            if (reconnected > 0) {
                // Only log to file, not to console
                fs.appendFileSync(
                    path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                    `[${new Date().toISOString()}] Reconnected ${reconnected} WebSocket connections during heartbeat check\n`
                );
            }
        } catch (error) {
            // Only log to file, not to console
            fs.appendFileSync(
                path.join(LOG_DIR, `ema-tracker-${new Date().toISOString().split('T')[0]}.log`),
                `[${new Date().toISOString()}] Error in WebSocket heartbeat: ${error.message}\n`
            );
        }
    }, 60000); // Check every minute
}

// Set up message and callback query handlers
bot.on('message', handleMessage);
bot.on('callback_query', handleCallbackQuery);

// Handle process termination gracefully
process.on('SIGINT', async () => {
    try {
        log('Received SIGINT. Shutting down gracefully...', 'warning');

        // Close all WebSocket connections
        for (const [symbol, ws] of activeWebSockets.entries()) {
            try {
                ws.close();
                log(`Closed WebSocket for ${symbol}`, 'info');
            } catch (e) {
                // Ignore errors when closing
            }
        }

        await bot.sendMessage(TELEGRAM_CHAT_ID, 'âš ï¸ EMA Tracker Bot is shutting down...');

        // Show desktop notification
        showDesktopNotification(
            'EMA Tracker Shutting Down',
            'The bot is shutting down gracefully',
            'warning'
        );

        process.exit(0);
    } catch (error) {
        log(`Error during shutdown: ${error.message}`, 'error');
        process.exit(1);
    }
});

// Error handling for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');

    // Show desktop notification for unhandled rejection
    showDesktopNotification(
        'Error in EMA Tracker',
        'An unhandled rejection occurred. Check logs for details.',
        'error'
    );
});

// Initialize Brain.js ML module
const brainML = {
    trainModelForSymbol: async function (symbol) {
        try {
            // Check if we have enough data
            if (!trainingData.has(symbol)) {
                log(`No training data for ${symbol}`, 'warning');
                return null;
            }

            const data = trainingData.get(symbol);
            const validData = data.filter(d => d.future_price_change !== null);

            if (validData.length < 100) {
                log(`Not enough valid data for ${symbol}: ${validData.length} points`, 'warning');
                return null;
            }

            log(`Training Brain.js model for ${symbol} with ${validData.length} data points`, 'info');

            // Import the ml_alternative.js module
            const ml_alternative = require('./ml_alternative');

            // Train the model using Brain.js
            const result = await ml_alternative.trainModelForSymbol(symbol);

            if (result) {
                log(`Successfully trained Brain.js model for ${symbol}`, 'success');
                return result;
            } else {
                log(`Failed to train Brain.js model for ${symbol}`, 'error');
                return null;
            }
        } catch (error) {
            log(`Error training Brain.js model for ${symbol}: ${error.message}`, 'error');
            return null;
        }
    },

    predictPriceChange: async function (symbol, features) {
        try {
            // Import the ml_alternative.js module
            const ml_alternative = require('./ml_alternative');

            // Make prediction using Brain.js
            const prediction = await ml_alternative.predictPriceChange(symbol, features);

            return prediction;
        } catch (error) {
            log(`Error making Brain.js prediction for ${symbol}: ${error.message}`, 'error');
            return null;
        }
    },

    exportToCSV: async function (symbol, data) {
        try {
            // Create CSV data directory if it doesn't exist
            const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
            if (!fs.existsSync(CSV_DATA_DIR)) {
                fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
            }

            // Create directory for this symbol if it doesn't exist
            const symbolDir = path.join(CSV_DATA_DIR, symbol);
            if (!fs.existsSync(symbolDir)) {
                fs.mkdirSync(symbolDir, { recursive: true });
            }

            const csvPath = path.join(symbolDir, `${symbol}_training_data.csv`);

            // Filter out data points without future price change
            const validData = data.filter(d => d.future_price_change !== null);

            if (validData.length === 0) {
                log(`No valid data points with outcomes for ${symbol}`, 'warning');
                return false;
            }

            // Create CSV content
            let csvContent = 'timestamp,open,high,low,close,volume,ema,ema_diff,rsi,macd,macd_signal,macd_hist,bb_width,volume_change,future_price_change\n';

            for (const point of validData) {
                csvContent += `${point.timestamp},${point.open},${point.high},${point.low},${point.close},${point.volume},${point.ema},${point.ema_diff},${point.rsi},${point.macd || 0},${point.macd_signal || 0},${point.macd_hist || 0},${point.bb_width},${point.volume_change || 0},${point.future_price_change}\n`;
            }

            // Write to file
            //fs.writeFileSync(csvPath, csvContent); // fs.writeFileSync() may slow down applications with concurrent processes due to its blocking nature
            fs.writeFile(csvPath, csvContent);


            log(`Exported ${validData.length} data points to CSV for ${symbol}`, 'success');
            return true;
        } catch (error) {
            log(`Error exporting CSV for ${symbol}: ${error.message}`, 'error');
            return false;
        }
    }
};

// Calculate ATR (Average True Range)
function calculateATR(klines, period = 14) {
    if (klines.length < period + 1) {
        return 0;
    }

    const trueRanges = [];

    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevClose = klines[i - 1].close;

        // True Range is the greatest of:
        // 1. Current High - Current Low
        // 2. |Current High - Previous Close|
        // 3. |Current Low - Previous Close|
        const tr1 = high - low;
        const tr2 = Math.abs(high - prevClose);
        const tr3 = Math.abs(low - prevClose);

        const trueRange = Math.max(tr1, tr2, tr3);
        trueRanges.push(trueRange);
    }

    // Calculate simple moving average of true ranges
    if (trueRanges.length < period) {
        return trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    }

    const atr = trueRanges.slice(-period).reduce((sum, tr) => sum + tr, 0) / period;
    return atr;
}

// Install required packages if not already installed
async function installRequiredPackages() {
    const { exec } = require('child_process');
    const requiredPackages = ['ws', 'brain.js']; // WebSocket and Brain.js packages

    for (const pkg of requiredPackages) {
        try {
            require.resolve(pkg);
            log(`Package ${pkg} is already installed`, 'info');
        } catch (e) {
            log(`Installing required package: ${pkg}...`, 'info');

            try {
                await new Promise((resolve, reject) => {
                    exec(`npm install ${pkg}`, (error, stdout, stderr) => {
                        if (error) {
                            log(`Error installing ${pkg}: ${error.message}`, 'error');
                            reject(error);
                            return;
                        }
                        log(`Successfully installed ${pkg}`, 'success');
                        resolve();
                    });
                });
            } catch (error) {
                log(`Failed to install ${pkg}: ${error.message}`, 'error');
                throw error;
            }
        }
    }
}

// Initialize the terminal and start monitoring
async function initialize() {
    try {
        // Install required packages
        await installRequiredPackages();

        // Initialize terminal and load settings
        initializeTerminal();
        loadSettings();

        console.log('\nStarting initial check...'.green);

        // Initialize ML components
        console.log('Initializing Brain.js machine learning components...'.cyan);

        // Create models directory if it doesn't exist
        const modelsDir = path.join(__dirname, 'ml_models');
        if (!fs.existsSync(modelsDir)) {
            fs.mkdirSync(modelsDir, { recursive: true });
        }

        // Create CSV data directory if it doesn't exist
        const CSV_DATA_DIR = path.join(__dirname, 'csv_data');
        if (!fs.existsSync(CSV_DATA_DIR)) {
            fs.mkdirSync(CSV_DATA_DIR, { recursive: true });
        }

        // Send startup message
        await sendStartupMessage();

        // Do initial check to populate data
        await checkEMACross();

        // Setup WebSockets for all tracked pairs
        await setupAllWebSockets();

        // Start WebSocket heartbeat
        startWebSocketHeartbeat();

        // Load ML training data
        loadTrainingData();

        await updateIncompleteDataPoints();

        // Schedule periodic saving of training data
        setInterval(saveTrainingData, 30 * 60 * 1000); // Save every 30 minutes

        // Now set flag to enable volume threshold notifications for subsequent checks
        initialLoadComplete = true;
        log('Initial load complete. Volume threshold notifications enabled for new pairs.', 'info');

        // Run the check at the specified interval as a backup
        // This is in addition to the real-time WebSocket monitoring
        monitoringInterval = setInterval(async () => {
            log('Running periodic check as backup to WebSockets...', 'info');
            await checkEMACross();
        }, CHECK_INTERVAL);

        log('Initialization complete. Bot is now monitoring in real-time via WebSockets with Brain.js ML enhancement.', 'success');
    } catch (error) {
        log(`Failed to initialize: ${error.message}`, 'error');

        // Show desktop notification for startup failure
        showDesktopNotification(
            'EMA Tracker Failed to Start',
            `Error: ${error.message}`,
            'error'
        );

        // Try to send error message to Telegram
        try {
            await bot.sendMessage(TELEGRAM_CHAT_ID, `âŒ *Error Starting Bot*\n\n${error.message}`, {
                parse_mode: 'Markdown'
            });
        } catch (e) {
            log(`Could not send error message to Telegram: ${e.message}`, 'error');
        }
    }
}

// Start the bot
initialize();
// Function to send a message to Telegram








some module is problemetic no issue don't use it it saved by node2.js